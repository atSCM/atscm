{"version":3,"sources":["../../src/util/fs.js"],"names":["getStat","validateDirectoryExists","path","Promise","resolve","reject","err","stats","directoryPath","then","isDirectory","Error"],"mappings":";;;;;QASgBA,O,GAAAA,O;QAkBAC,uB,GAAAA,uB;;AA3BhB;;AACA;;AAEA;;;;;;AAMO,SAASD,OAAT,CAAiBE,IAAjB,EAAuB;AAC5B,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,kBAAK,mBAAYH,IAAZ,CAAL,EAAwB,CAACI,GAAD,EAAMC,KAAN,KAAgB;AACtC,UAAID,GAAJ,EAAS;AACPD,eAAOC,GAAP;AACD,OAFD,MAEO;AACLF,gBAAQG,KAAR;AACD;AACF,KAND;AAOD,GARM,CAAP;AASD;;AAED;;;;;;AAMO,SAASN,uBAAT,CAAiCO,aAAjC,EAAgD;AACrD,SAAOR,QAAQQ,aAAR,EACJC,IADI,CACCF,SAAS;AACb,QAAI,CAAEA,MAAMG,WAAN,EAAN,EAA4B;AAC1B,YAAM,IAAIC,KAAJ,CAAW,GAAE,mBAAYH,aAAZ,CAA2B,qBAAxC,CAAN;AACD;;AAED;AACD,GAPI,CAAP;AAQD","file":"fs.js","sourcesContent":["import { resolve as resolvePath } from 'path';\nimport { stat } from 'fs';\n\n/**\n * Returns the {@link fs~Stats} for a path.\n * @param {string} path The path to look at.\n * @return {Promise<fs~Stats, Error>} Fulfilled with the requested stats or rejected with the error\n * that occurred.\n */\nexport function getStat(path) {\n  return new Promise((resolve, reject) => {\n    stat(resolvePath(path), (err, stats) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(stats);\n      }\n    });\n  });\n}\n\n/**\n * Checks it a given path holds a directory and returns it's {@link fs~Stats} if found.\n * @param {string} directoryPath The path to look at.\n * @return {Promise<fs~Stats, Error>} Fulfilled with the directory's stats or rejected with the\n * error that occurred.\n */\nexport function validateDirectoryExists(directoryPath) {\n  return getStat(directoryPath)\n    .then(stats => {\n      if (!(stats.isDirectory())) {\n        throw new Error(`${resolvePath(directoryPath)} is not a directory`);\n      }\n\n      return stat;\n    });\n}\n"]}