{"version":3,"sources":["../../src/tasks/watch.js"],"names":["watch","WatchTask","constructor","browserSyncInstance","create","_pulling","_pushing","_lastPull","_lastPushed","directoryToWatch","_waitForWatcher","watcher","Promise","resolve","reject","on","err","startFileWatcher","catch","code","info","Object","assign","message","then","glob","watchman","process","platform","startServerWatcher","initBrowserSync","options","init","proxy","host","port","http","ws","handleFileChange","path","root","stats","normalizeMtime","mtime","source","base","recursive","file","nodeId","toString","reload","handleServerChange","readResult","stream","run","open","all","fileWatcher","serverWatcher","emitter","debug","bind","description"],"mappings":"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","file":"watch.js","sourcesContent":["import { join } from 'path';\nimport sane from 'sane';\nimport browserSync from 'browser-sync';\nimport Logger from 'gulplog';\nimport src from '../lib/gulp/src';\nimport PushStream from '../lib/gulp/PushStream';\nimport PullStream from '../lib/gulp/PullStream';\nimport AtviseFile from '../lib/server/AtviseFile';\nimport ServerWatcher from '../lib/server/Watcher';\nimport ProjectConfig from '../config/ProjectConfig';\nimport { validateDirectoryExists } from '../util/fs';\nimport NodeStream from '../lib/server/NodeStream';\n\n/**\n * The task executed when running `atscm watch`.\n */\nexport class WatchTask {\n\n  /**\n   * Creates a new watch task instance. Also creates a new Browsersync instance.\n   */\n  constructor() {\n    /**\n     * The Browsersync instance used.\n     * @type {events~Emitter}\n     */\n    this.browserSyncInstance = browserSync.create();\n\n    /**\n     * If the task is currently pulling.\n     * @type {boolean}\n     */\n    this._pulling = false;\n\n    /**\n     * If the task is currently pushing.\n     * @type {boolean}\n     */\n    this._pushing = false;\n\n    /**\n     * Timestamp of the last pull\n     * @type {number}\n     */\n    this._lastPull = 0;\n\n    /**\n     * The {@link NodeId} of the last push.\n     * @type {?NodeId}\n     */\n    this._lastPushed = null;\n  }\n\n  /**\n   * The directory to watch.\n   * @type {string}\n   */\n  get directoryToWatch() {\n    return './src';\n  }\n\n  /**\n   * Waits for a watcher (which can actually be any kind of {@link events~Emitter}) to emit a\n   * \"ready\" event.\n   * @param {events~Emitter} watcher The watcher to wait for.\n   * @return {Promise<events~Emitter, Error>} Fulfilled with the set up watcher or rejected with the\n   * watcher error that occurred while waiting for it to get ready.\n   */\n  _waitForWatcher(watcher) {\n    return new Promise((resolve, reject) => {\n      watcher.on('error', err => reject(err));\n      watcher.on('ready', () => resolve(watcher));\n    });\n  }\n\n  /**\n   * Starts a file watcher for the directory {@link WatchTask#directoryToWatch}.\n   * @return {Promise<sane~Watcher, Error>} Fulfilled with the file watcher once it is ready or\n   * rejected with the error that occurred while starting the watcher.\n   */\n  startFileWatcher() {\n    return validateDirectoryExists(this.directoryToWatch)\n      .catch(err => {\n        if (err.code === 'ENOENT') {\n          Logger.info(`Create a directory at ${this.directoryToWatch} or run \\`atscm pull\\` first`);\n\n          Object.assign(err, {\n            message: `Directory ${this.directoryToWatch} does not exist`,\n          });\n        }\n\n        throw err;\n      })\n      .then(() => this._waitForWatcher(sane(this.directoryToWatch, {\n        glob: '**/*.*',\n        watchman: process.platform === 'darwin',\n      })));\n  }\n\n  /**\n   * Starts a watcher that watches the atvise server for changes.\n   * @return {Promise<Watcher, Error>} Fulfilled with the server watcher once it is ready or\n   * rejected with the error that occurred while starting the watcher.\n   */\n  startServerWatcher() {\n    return this._waitForWatcher(new ServerWatcher());\n  }\n\n  /**\n   * Initializes {@link WatchTask#browserSyncInstance}.\n   * @param {Object} options The options to pass to browsersync.\n   * @see https://browsersync.io/docs/options\n   */\n  initBrowserSync(options) {\n    this.browserSyncInstance.init(Object.assign({\n      proxy: `${ProjectConfig.host}:${ProjectConfig.port.http}`,\n      ws: true,\n      // logLevel: 'debug', FIXME: Use log level specified in cli options\n      // logPrefix: '',\n    }, options));\n\n    /* bs.logger.logOne = function(args, msg, level, unprefixed) {\n      args = args.slice(2);\n\n      if (this.config.useLevelPrefixes && !unprefixed) {\n        msg = this.config.prefixes[level] + msg;\n      }\n\n      msg = this.compiler.compile(msg, unprefixed);\n\n      args.unshift(msg);\n\n      Logger[level](format(...args));\n\n      this.resetTemps();\n\n      return this;\n    }; */\n  }\n\n  /**\n   * Handles a file change.\n   * @param {string} path The path of the file that changed.\n   * @param {string} root The root of the file that changed.\n   * @param {fs~Stats} stats The stats of the file that changed.\n   * @return {Promise<boolean>} Resolved with `true` if the change triggered a push operation,\n   * with `false` otherwise.\n   */\n  handleFileChange(path, root, stats) {\n    return new Promise(resolve => {\n      if (!this._pulling && AtviseFile.normalizeMtime(stats.mtime) > this._lastPull) {\n        this._pushing = true;\n        Logger.info(path, 'changed');\n\n        const source = src(join(root, path), { base: root, recursive: false });\n\n        (new PushStream(source))\n          .on('data', file => (this._lastPushed = file.nodeId.toString()))\n          .on('end', () => {\n            this._pushing = false;\n            this.browserSyncInstance.reload();\n\n            resolve(true);\n          });\n      } else {\n        resolve(false);\n      }\n    });\n  }\n\n  /**\n   * Handles an atvise server change.\n   * @param {ReadStream.ReadResult} readResult The read result of the modification.\n   * @return {Promise<boolean>} Resolved with `true` if the change triggered a pull operation,\n   * with `false` otherwise.\n   */\n  handleServerChange(readResult) {\n    return new Promise(resolve => {\n      if (!this._pushing) {\n        if (readResult.nodeId.toString() !== this._lastPushed) {\n          this._pulling = true;\n          Logger.info(readResult.nodeId.toString(), 'changed');\n\n          // FIXME: Reuse read value\n          const stream = new NodeStream([readResult.nodeId], { recursive: false });\n\n          (new PullStream(stream))\n            .on('finish', () => {\n              this._pulling = false;\n              this._lastPull = AtviseFile.normalizeMtime(readResult.mtime);\n              this.browserSyncInstance.reload();\n\n              resolve(true);\n            });\n        } else {\n          this._lastPushed = null;\n\n          resolve(false);\n        }\n      } else {\n        resolve(false);\n      }\n    });\n  }\n\n  /**\n   * Starts the file and server watchers, initializes Browsersync and registers change event\n   * handlers.\n   * @param {Object} [options] The options to pass to browsersync.\n   * @param {boolean} [options.open=true] If the browser should be opened once browsersync is up.\n   * @return {Promise<{ serverWatcher: Watcher, fileWatcher: sane~Watcher }, Error>} Fulfilled once\n   * all watchers are set up and Browsersync was initialized.\n   */\n  run({ open = true } = { open: true }) {\n    return Promise.all([\n      this.startFileWatcher(),\n      this.startServerWatcher(),\n    ])\n      .then(([fileWatcher, serverWatcher]) => {\n        this.browserSyncInstance.emitter.on('service:running', () => {\n          Logger.info('Watching for changes...');\n          Logger.debug('Press Ctrl-C to exit');\n        });\n\n        fileWatcher.on('change', this.handleFileChange.bind(this));\n        serverWatcher.on('change', this.handleServerChange.bind(this));\n\n        this.initBrowserSync({ open });\n\n        return { fileWatcher, serverWatcher };\n      });\n  }\n\n}\n\n/**\n * The gulp task invoced when running `atscm watch`.\n * @param {Object} options The options to pass to the watch task, see {@link WatchTask#run} for\n * available options.\n * @return {Promise<{ serverWatcher: Watcher, fileWatcher: sane~Watcher }, Error>} Fulfilled once\n * all watchers are set up and Browsersync was initialized.\n */\nexport default function watch(options) {\n  return (new WatchTask()).run(options);\n}\n\nwatch.description = 'Watch local files and atvise server nodes to trigger pull/push on change';\n"]}