{"version":3,"sources":["../../src/tasks/watch.js"],"names":["WatchTask","constructor","browserSyncInstance","browserSync","create","_pulling","_pushing","_lastPull","_lastPushed","directoryToWatch","_waitForWatcher","watcher","Promise","resolve","reject","on","err","startFileWatcher","catch","code","Logger","info","Object","assign","message","then","glob","watchman","process","platform","startServerWatcher","ServerWatcher","initBrowserSync","options","init","proxy","ProjectConfig","host","port","http","ws","printTaskError","contextMessage","refined","error","stack","handleFileChange","path","root","_handlingChange","debug","singleNode","reload","handleServerChange","readResult","nodeId","value","recursive","run","open","all","fileWatcher","serverWatcher","emitter","bind","watch","context","description"],"mappings":"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","sourcesContent":["import { join } from 'path';\nimport sane from 'sane';\nimport browserSync from 'browser-sync';\nimport Logger from 'gulplog';\nimport ServerWatcher from '../lib/server/Watcher';\nimport { delay } from '../lib/helpers/async';\nimport { handleTaskError } from '../lib/helpers/tasks';\nimport ProjectConfig from '../config/ProjectConfig';\nimport { validateDirectoryExists } from '../util/fs';\nimport { setupContext } from '../hooks/hooks';\nimport checkAtserver from '../hooks/check-atserver';\nimport checkServerscripts from '../hooks/check-serverscripts';\nimport { performPull } from './pull';\nimport { performPush } from './push';\n\n/**\n * The task executed when running `atscm watch`.\n */\nexport class WatchTask {\n  /**\n   * Creates a new watch task instance. Also creates a new Browsersync instance.\n   */\n  constructor() {\n    /**\n     * The Browsersync instance used.\n     * @type {events~Emitter}\n     */\n    this.browserSyncInstance = browserSync.create();\n\n    /**\n     * If the task is currently pulling.\n     * @type {boolean}\n     */\n    this._pulling = false;\n\n    /**\n     * If the task is currently pushing.\n     * @type {boolean}\n     */\n    this._pushing = false;\n\n    /**\n     * Timestamp of the last pull\n     * @type {number}\n     */\n    this._lastPull = 0;\n\n    /**\n     * The {@link NodeId} of the last push.\n     * @type {?NodeId}\n     */\n    this._lastPushed = null;\n  }\n\n  /**\n   * The directory to watch.\n   * @type {string}\n   */\n  get directoryToWatch() {\n    return './src';\n  }\n\n  /**\n   * Waits for a watcher (which can actually be any kind of {@link events~Emitter}) to emit a\n   * \"ready\" event.\n   * @param {events~Emitter} watcher The watcher to wait for.\n   * @return {Promise<events~Emitter, Error>} Fulfilled with the set up watcher or rejected with the\n   * watcher error that occurred while waiting for it to get ready.\n   */\n  _waitForWatcher(watcher) {\n    return new Promise((resolve, reject) => {\n      watcher.on('error', err => reject(err));\n      watcher.on('ready', () => resolve(watcher));\n    });\n  }\n\n  /**\n   * Starts a file watcher for the directory {@link WatchTask#directoryToWatch}.\n   * @return {Promise<sane~Watcher, Error>} Fulfilled with the file watcher once it is ready or\n   * rejected with the error that occurred while starting the watcher.\n   */\n  startFileWatcher() {\n    return validateDirectoryExists(this.directoryToWatch)\n      .catch(err => {\n        if (err.code === 'ENOENT') {\n          Logger.info(`Create a directory at ${this.directoryToWatch} or run \\`atscm pull\\` first`);\n\n          Object.assign(err, {\n            message: `Directory ${this.directoryToWatch} does not exist`,\n          });\n        }\n\n        throw err;\n      })\n      .then(() =>\n        this._waitForWatcher(\n          sane(this.directoryToWatch, {\n            glob: '**/*.*',\n            watchman: process.platform === 'darwin',\n          })\n        )\n      );\n  }\n\n  /**\n   * Starts a watcher that watches the atvise server for changes.\n   * @return {Promise<Watcher, Error>} Fulfilled with the server watcher once it is ready or\n   * rejected with the error that occurred while starting the watcher.\n   */\n  startServerWatcher() {\n    return this._waitForWatcher(new ServerWatcher());\n  }\n\n  /**\n   * Initializes {@link WatchTask#browserSyncInstance}.\n   * @param {Object} options The options to pass to browsersync.\n   * @see https://browsersync.io/docs/options\n   */\n  initBrowserSync(options) {\n    this.browserSyncInstance.init(\n      Object.assign(\n        {\n          proxy: `${ProjectConfig.host}:${ProjectConfig.port.http}`,\n          ws: true,\n          // logLevel: 'debug', FIXME: Use log level specified in cli options\n          // logPrefix: '',\n        },\n        options\n      )\n    );\n\n    /* bs.logger.logOne = function(args, msg, level, unprefixed) {\n      args = args.slice(2);\n\n      if (this.config.useLevelPrefixes && !unprefixed) {\n        msg = this.config.prefixes[level] + msg;\n      }\n\n      msg = this.compiler.compile(msg, unprefixed);\n\n      args.unshift(msg);\n\n      Logger[level](format(...args));\n\n      this.resetTemps();\n\n      return this;\n    }; */\n  }\n\n  /**\n   * Prints an error that happened while handling a change.\n   * @param {string} contextMessage Describes the currently run action.\n   * @param {Error} err The error that occured.\n   */\n  printTaskError(contextMessage, err) {\n    try {\n      handleTaskError(err);\n    } catch (refined) {\n      Logger.error(contextMessage, refined.message, refined.stack);\n    }\n  }\n\n  /**\n   * Handles a file change.\n   * @param {string} path The path of the file that changed.\n   * @param {string} root The root of the file that changed.\n   * @return {Promise<boolean>} Resolved with `true` if the change triggered a push operation,\n   * with `false` otherwise.\n   */\n  handleFileChange(path, root) {\n    if (this._handlingChange) {\n      Logger.debug('Ignoring', path, 'changed');\n      return Promise.resolve(false);\n    }\n\n    this._handlingChange = true;\n    Logger.info(path, 'changed');\n\n    return performPush(join(root, path), { singleNode: true })\n      .catch(err => this.printTaskError('Push failed', err))\n      .then(async () => {\n        this.browserSyncInstance.reload();\n\n        await delay(500);\n\n        this._handlingChange = false;\n      });\n  }\n\n  /**\n   * Handles an atvise server change.\n   * @param {ReadStream.ReadResult} readResult The read result of the modification.\n   * @return {Promise<boolean>} Resolved with `true` if the change triggered a pull operation,\n   * with `false` otherwise.\n   */\n  handleServerChange(readResult) {\n    if (this._handlingChange) {\n      Logger.debug('Ignoring', readResult.nodeId.value, 'changed');\n      return Promise.resolve(false);\n    }\n\n    this._handlingChange = true;\n    Logger.info(readResult.nodeId.value, 'changed');\n\n    return performPull([readResult.nodeId], { recursive: false })\n      .catch(err => this.printTaskError('Pull failed', err))\n      .then(async () => {\n        this.browserSyncInstance.reload();\n\n        await delay(500);\n\n        this._handlingChange = false;\n      });\n  }\n\n  /**\n   * Starts the file and server watchers, initializes Browsersync and registers change event\n   * handlers.\n   * @param {Object} [options] The options to pass to browsersync.\n   * @param {boolean} [options.open=true] If the browser should be opened once browsersync is up.\n   * @return {Promise<{ serverWatcher: Watcher, fileWatcher: sane~Watcher }, Error>} Fulfilled once\n   * all watchers are set up and Browsersync was initialized.\n   */\n  run({ open = true } = {}) {\n    return Promise.all([this.startFileWatcher(), this.startServerWatcher()]).then(\n      ([fileWatcher, serverWatcher]) => {\n        this.browserSyncInstance.emitter.on('service:running', () => {\n          Logger.info('Watching for changes...');\n          Logger.debug('Press Ctrl-C to exit');\n        });\n\n        fileWatcher.on('change', this.handleFileChange.bind(this));\n        serverWatcher.on('change', this.handleServerChange.bind(this));\n\n        this.initBrowserSync({ open });\n\n        return { fileWatcher, serverWatcher };\n      }\n    );\n  }\n}\n\n/**\n * The gulp task invoced when running `atscm watch`.\n * @param {Object} options The options to pass to the watch task, see {@link WatchTask#run} for\n * available options.\n * @return {Promise<{ serverWatcher: Watcher, fileWatcher: sane~Watcher }, Error>} Fulfilled once\n * all watchers are set up and Browsersync was initialized.\n */\nexport default async function watch(options) {\n  const context = setupContext();\n  await checkAtserver(context);\n  await checkServerscripts(context);\n\n  return new WatchTask().run(options);\n}\n\nwatch.description = 'Watch local files and atvise server nodes to trigger pull/push on change';\n"],"file":"watch.js"}