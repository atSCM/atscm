{"version":3,"sources":["../../src/tasks/watch.js"],"names":["watch","WatchTask","constructor","browserSyncInstance","create","_pulling","_pushing","_lastPull","_lastPushed","_waitForWatcher","watcher","Promise","resolve","reject","on","err","startFileWatcher","RelativeSourceDirectoryPath","catch","code","info","Object","assign","message","then","glob","watchman","process","platform","startServerWatcher","initBrowserSync","init","proxy","target","host","port","http","ws","handleFileChange","path","root","stats","normalizeMtime","mtime","nodePath","nodeId","fromFilePath","toString","_lastPulled","pushStream","nodesToPush","createNodes","file","reload","handleServerChange","readNodeMappingItem","readStream","write","end","pullStream","useInputStream","inputStream","configObj","run","all","fileWatcher","serverWatcher","emitter","bind","description"],"mappings":"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","file":"watch.js","sourcesContent":["import { dirname } from 'path';\nimport sane from 'sane';\nimport browserSync from 'browser-sync';\nimport Logger from 'gulplog';\nimport { obj as createStream } from 'through2';\nimport PushStream from '../lib/gulp/PushStream';\nimport PullStream from '../lib/gulp/PullStream';\nimport AtviseFile from '../lib/mapping/AtviseFile';\nimport ServerWatcher from '../lib/watch/Watcher';\nimport ProjectConfig from '../config/ProjectConfig';\nimport NodeId from '../lib/ua/NodeId';\nimport { validateDirectoryExists } from '../util/fs';\n\n/**\n * The task executed when running `atscm watch`.\n */\nexport class WatchTask {\n\n  /**\n   * Creates a new watch task instance. Also creates a new Browsersync instance.\n   */\n  constructor() {\n    /**\n     * The Browsersync instance used.\n     * @type {events~Emitter}\n     */\n    this.browserSyncInstance = browserSync.create();\n\n    /**\n     * If the task is currently pulling.\n     * @type {boolean}\n     */\n    this._pulling = false;\n\n    /**\n     * If the task is currently pushing.\n     * @type {boolean}\n     */\n    this._pushing = false;\n\n    /**\n     * Timestamp of the last pull\n     * @type {number}\n     */\n    this._lastPull = 0;\n\n    /**\n     * The {@link NodeId} of the last push.\n     * @type {?NodeId}\n     */\n    this._lastPushed = null;\n  }\n\n  /**\n   * Waits for a watcher (which can actually be any kind of {@link events~Emitter}) to emit a\n   * 'ready' event.\n   * @param {events~Emitter} watcher The watcher to wait for.\n   * @return {Promise<events~Emitter, Error>} Fulfilled with the set up watcher or rejected with the\n   * watcher error that occurred while waiting for it to get ready.\n   */\n  _waitForWatcher(watcher) {\n    return new Promise((resolve, reject) => {\n      watcher.on('error', err => reject(err));\n      watcher.on('ready', () => resolve(watcher));\n    });\n  }\n\n  /**\n   * Starts a file watcher for the directory {@link WatchTask#directoryToWatch}.\n   * @return {Promise<sane~Watcher, Error>} Fulfilled with the file watcher once it is ready or\n   * rejected with the error that occurred while starting the watcher.\n   */\n  startFileWatcher() {\n    return validateDirectoryExists(ProjectConfig.RelativeSourceDirectoryPath)\n      .catch(err => {\n        if (err.code === 'ENOENT') {\n          Logger.info(\n            `Create a directory at ${ProjectConfig.RelativeSourceDirectoryPath}`,\n            'or run \"atscm pull\" first'\n          );\n\n          Object.assign(err, {\n            message: `Directory ${ProjectConfig.RelativeSourceDirectoryPath} does not exist`,\n          });\n        }\n\n        throw err;\n      })\n      .then(() => this._waitForWatcher(sane(ProjectConfig.RelativeSourceDirectoryPath, {\n        glob: '**/*.*',\n        watchman: process.platform === 'darwin',\n      })));\n  }\n\n  /**\n   * Starts a watcher that watches the atvise server for changes.\n   * @return {Promise<Watcher, Error>} Fulfilled with the server watcher once it is ready or\n   * rejected with the error that occurred while starting the watcher.\n   */\n  startServerWatcher() {\n    return this._waitForWatcher(new ServerWatcher());\n  }\n\n  /**\n   * Initializes {@link WatchTask#browserSyncInstance}.\n   */\n  initBrowserSync() {\n    this.browserSyncInstance.init({\n      proxy: {\n        target: `${ProjectConfig.host}:${ProjectConfig.port.http}`,\n        ws: true,\n      },\n      // logLevel: 'debug', FIXME: Use log level specified in cli options\n      // logPrefix: '',\n    });\n\n    /* bs.logger.logOne = function(args, msg, level, unprefixed) {\n      args = args.slice(2);\n\n      if (this.config.useLevelPrefixes && !unprefixed) {\n        msg = this.config.prefixes[level] + msg;\n      }\n\n      msg = this.compiler.compile(msg, unprefixed);\n\n      args.unshift(msg);\n\n      Logger[level](format(...args));\n\n      this.resetTemps();\n\n      return this;\n    }; */\n  }\n\n  /**\n   * Handles a file change.\n   * @param {string} path The path of the file that changed.\n   * @param {string} root The root of the file that changed.\n   * @param {fs~Stats} stats The stats of the file that changed.\n   * @return {Promise<boolean>} Resolved with `true` if the change triggered a push operation,\n   * with `false` otherwise.\n   */\n  handleFileChange(path, root, stats) {\n    return new Promise(resolve => {\n      if (!this._pulling && AtviseFile.normalizeMtime(stats.mtime) > this._lastPull) {\n        const nodePath = dirname(path);\n        let nodeId = {};\n\n        nodeId = NodeId.fromFilePath(nodePath);\n\n        if (nodeId.toString() !== this._lastPulled) {\n          const pushStream = new PushStream({\n            nodesToPush: [nodeId],\n            createNodes: false,\n          });\n\n          this._pushing = true;\n          Logger.info('File change:', path, 'changed');\n\n          pushStream\n            .on('write-successful', file => {\n              this._lastPushed = file.nodeId.toString();\n            })\n            .on('finish', () => {\n              this._pushing = false;\n              this.browserSyncInstance.reload();\n\n              resolve(true);\n            });\n        }\n      } else {\n        resolve(false);\n      }\n    });\n  }\n  /**\n   * Handles an atvise server change.\n   * @param {ReadNodeItem} readNodeMappingItem The resultung rad node mapping\n   * item of the modification.\n   * @return {Promise<boolean>} Resolved with `true` if the change triggered a pull operation,\n   * with `false` otherwise.\n   */\n  handleServerChange(readNodeMappingItem) {\n    return new Promise(resolve => {\n      if (!this._pushing) {\n        const nodeId = readNodeMappingItem.nodeId.toString();\n\n        if (nodeId !== this._lastPushed) {\n          const readStream = createStream();\n          this._pulling = true;\n\n          Logger.info('Server change:', nodeId, 'changed');\n          readStream.write(readNodeMappingItem);\n          readStream.end();\n\n          const pullStream = new PullStream({\n            useInputStream: true,\n            inputStream: readStream,\n          });\n\n          pullStream\n            .on('end', () => {\n              this._pulling = false;\n              this._lastPull = AtviseFile.normalizeMtime(readNodeMappingItem.configObj.mtime);\n              this.browserSyncInstance.reload();\n\n              resolve(true);\n            });\n        } else {\n          this._lastPushed = null;\n\n          resolve(false);\n        }\n      } else {\n        resolve(false);\n      }\n    });\n  }\n\n  /**\n   * Starts the file and server watchers, initializes Browsersync and registers change event\n   * handlers.\n   * @return {Promise<undefined, Error>} Fulfilled once all watchers are set up and Browsersync was\n   * initialized.\n   */\n  run() {\n    return Promise.all([\n      this.startFileWatcher(),\n      this.startServerWatcher(),\n    ])\n      .then(([fileWatcher, serverWatcher]) => {\n        this.browserSyncInstance.emitter.on('service:running', () => {\n          Logger.info('Watching for changes...');\n          Logger.info('Press Ctrl-C to exit');\n        });\n\n        fileWatcher.on('change', this.handleFileChange.bind(this));\n        // Rename von Files, Anlegen von neuen Files usw hier hinzufügen\n        serverWatcher.on('change', this.handleServerChange.bind(this));\n\n        this.initBrowserSync();\n      });\n  }\n\n}\n\n/**\n * The gulp task invoced when running `atscm watch`.\n * @return {Promise<undefined, Error>} Fulfilled once all watchers are set up and Browsersync was\n * initialized.\n */\nexport default function watch() {\n  return (new WatchTask()).run();\n}\n\nwatch.description = 'Watch local files and atvise server nodes to trigger pull/push on change';\n"]}