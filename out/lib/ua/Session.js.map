{"version":3,"sources":["../../../src/lib/ua/Session.js"],"names":["emitter","openSessions","openingSessions","Session","create","then","client","Promise","resolve","reject","createSession","userName","login","username","password","err","session","includes","message","response","responseHeader","serviceResult","BadUserAccessDenied","Error","Object","assign","_emitter","push","emit","close","deleteSubscriptions","_closed","_closing","on","markAsClosed","splice","indexOf","BadSessionIdInvalid","debug","_client","disconnect","clientErr","open","closeOpen","closeSessions","sessions","all","map","length","once"],"mappings":";;;;;;AAAA;;;;AACA;;AACA;;;;AACA;;;;AACA;;;;;;AAEA;;;;AAIA,MAAMA,UAAU,sBAAhB;;AAEA;;;;AAIA,MAAMC,eAAe,EAArB;;AAEA;;;;AAIA,IAAIC,kBAAkB,CAAtB;;AAEA;;;AAGe,MAAMC,OAAN,CAAc;;AAE3B;;;;AAIA,aAAWH,OAAX,GAAqB;AACnB,WAAOA,OAAP;AACD;;AAED;;;;;;AAMA,SAAOI,MAAP,GAAgB;AACdF;;AAEA,WAAO,iBAAOE,MAAP,GACJC,IADI,CACCC,UAAU,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC/CH,aAAOI,aAAP,CAAqB;AACnBC,kBAAU,wBAAcC,KAAd,CAAoBC,QADX;AAEnBC,kBAAU,wBAAcF,KAAd,CAAoBE;AAFX,OAArB,EAGG,CAACC,GAAD,EAAMC,OAAN,KAAkB;AACnB,YAAID,GAAJ,EAAS;AACP,cACE,CACE,mDADF,EAEE,mDAFF,EAGEE,QAHF,CAGWF,IAAIG,OAHf,KAICH,IAAII,QAAJ,IACDJ,IAAII,QAAJ,CAAaC,cAAb,CAA4BC,aAA5B,KAA8C,uBAAYC,mBAN5D,EAOE;AACAb,mBAAO,IAAIc,KAAJ,CAAU,yCAAV,CAAP;AACD,WATD,MASO;AACLd,mBAAO,IAAIc,KAAJ,CAAW,6BAA4BR,IAAIG,OAAQ,EAAnD,CAAP;AACD;AACF,SAbD,MAaO;AACLM,iBAAOC,MAAP,CAAcT,OAAd,EAAuB,EAAEU,UAAU,sBAAZ,EAAvB;;AAEAzB,uBAAa0B,IAAb,CAAkBX,OAAlB;AACAR,kBAAQQ,OAAR;AACD;;AAEDd;AACA,YAAIA,oBAAoB,CAAxB,EAA2B;AACzBF,kBAAQ4B,IAAR,CAAa,UAAb;AACD;AACF,OA5BD;AA6BD,KA9Be,CADX,CAAP;AAgCD;;AAED;;;;;;;AAOA,SAAOC,KAAP,CAAab,OAAb,EAAsBc,sBAAsB,IAA5C,EAAkD;AAChD,QAAI,CAACd,OAAD,IAAY,EAAEA,2CAAF,CAAhB,EAAqD;AACnD,aAAOT,QAAQE,MAAR,CAAe,IAAIc,KAAJ,CAAU,qBAAV,CAAf,CAAP;AACD;;AAED,QAAIP,QAAQe,OAAZ,EAAqB;AACnB,aAAOxB,QAAQC,OAAR,EAAP;AACD;;AAED,QAAIQ,QAAQgB,QAAZ,EAAsB;AACpB,aAAO,IAAIzB,OAAJ,CAAYC,WAAW;AAC5BQ,gBAAQU,QAAR,CAAiBO,EAAjB,CAAoB,cAApB,EAAoC,MAAMzB,QAAQQ,OAAR,CAA1C;AACD,OAFM,CAAP;AAGD;;AAEDQ,WAAOC,MAAP,CAAcT,OAAd,EAAuB,EAAEgB,UAAU,IAAZ,EAAvB;;AAEA,WAAO,IAAIzB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,eAASyB,YAAT,GAAwB;AACtBjC,qBAAakC,MAAb,CAAoBlC,aAAamC,OAAb,CAAqBpB,OAArB,CAApB,EAAmD,CAAnD;AACAQ,eAAOC,MAAP,CAAcT,OAAd,EAAuB,EAAEe,SAAS,IAAX,EAAvB;;AAEAvB,gBAAQQ,OAAR;AACAA,gBAAQU,QAAR,CAAiBE,IAAjB,CAAsB,cAAtB;AACD;;AAEDZ,cAAQa,KAAR,CAAcC,mBAAd,EAAmCf,OAAO;AACxC,YAAIA,GAAJ,EAAS;AACP,cAAIA,IAAII,QAAJ,IACFJ,IAAII,QAAJ,CAAaC,cAAb,CAA4BC,aAA5B,KAA8C,uBAAYgB,mBAD5D,EAEE;AACA,8BAAOC,KAAP,CAAa,kDAAb;AACAJ,yBAAalB,OAAb;AACD,WALD,MAKO,IAAID,IAAIG,OAAJ,KAAgB,YAApB,EAAkC;AACvC;AACAgB,yBAAalB,OAAb;AACD,WAHM,MAGA;AACLP,mBAAO,IAAIc,KAAJ,CAAW,4BAA2BR,IAAIG,OAAQ,EAAlD,CAAP;AACD;AACF,SAZD,MAYO;AACLF,kBAAQuB,OAAR,CAAgBC,UAAhB,CAA2BC,aAAa;AACtC,gBAAIA,SAAJ,EAAe;AACbhC,qBAAO,IAAIc,KAAJ,CAAW,gCAA+BkB,UAAUvB,OAAQ,EAA5D,CAAP;AACD,aAFD,MAEO;AACLgB,2BAAalB,OAAb;AACD;AACF,WAND;AAOD;AACF,OAtBD;AAuBD,KAhCM,CAAP;AAiCD;;AAED;;;;AAIA,aAAW0B,IAAX,GAAkB;AAChB,WAAOzC,YAAP;AACD;;AAED;;;;;AAKA,SAAO0C,SAAP,GAAmB;AACjB,aAASC,aAAT,CAAuBC,QAAvB,EAAiC;AAC/B,aAAOtC,QAAQuC,GAAR,CACLD,SAASE,GAAT,CAAa/B,WAAWb,QAAQ0B,KAAR,CAAcb,OAAd,CAAxB,CADK,CAAP;AAGD;;AAED,QAAId,oBAAoB,CAAxB,EAA2B;AACzB,UAAID,aAAa+C,MAAb,KAAwB,CAA5B,EAA+B;AAC7B,eAAOzC,QAAQC,OAAR,CAAgB,EAAhB,CAAP;AACD;;AAED,aAAOoC,cAAc3C,YAAd,CAAP;AACD;;AAED,WAAO,IAAIM,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCT,cAAQiD,IAAR,CAAa,UAAb,EAAyB,MAAM;AAC7BL,sBAAc3C,YAAd,EACGI,IADH,CACQG,OADR,EACiBC,MADjB;AAED,OAHD;AAID,KALM,CAAP;AAMD;;AAlJ0B;kBAARN,O","file":"Session.js","sourcesContent":["import Emitter from 'events';\nimport { StatusCodes, ClientSession } from 'node-opcua';\nimport Logger from 'gulplog';\nimport Client from './Client';\nimport ProjectConfig from '../../config/ProjectConfig';\n\n/**\n * The global EventEmitter used to emit events.\n * @type {events~Emitter}\n */\nconst emitter = new Emitter();\n\n/**\n * The currently open sessions.\n * @type {node-opcua~ClientSession[]}\n */\nconst openSessions = [];\n\n/**\n * The number of session currently being opened.\n * @type {Number}\n */\nlet openingSessions = 0;\n\n/**\n * A wrapper around {@link node-opcua~ClientSession} used to connect to atvise server.\n */\nexport default class Session {\n\n  /**\n   * An {@link events~Emitter} that emits events when creating / closing sessions.\n   * @type {events~Emitter}\n   */\n  static get emitter() {\n    return emitter;\n  }\n\n  /**\n   * Creates and opens a new {@link node-opcua~ClientSession}.\n   * @return {Promise<node-opcua~ClientSession, Error>} Fulfilled with an already opened\n   * {@link node-opcua~ClientSession}.\n   * @emits {undefined} Emits an `all-open` event once all opening sessions are open.\n   */\n  static create() {\n    openingSessions++;\n\n    return Client.create()\n      .then(client => new Promise((resolve, reject) => {\n        client.createSession({\n          userName: ProjectConfig.login.username,\n          password: ProjectConfig.login.password,\n        }, (err, session) => {\n          if (err) {\n            if (\n              [\n                'userName === null || typeof userName === \"string\"',\n                'password === null || typeof password === \"string\"',\n              ].includes(err.message) ||\n              (err.response &&\n              err.response.responseHeader.serviceResult === StatusCodes.BadUserAccessDenied)\n            ) {\n              reject(new Error('Unable to create session: Invalid login'));\n            } else {\n              reject(new Error(`Unable to create session: ${err.message}`));\n            }\n          } else {\n            Object.assign(session, { _emitter: new Emitter() });\n\n            openSessions.push(session);\n            resolve(session);\n          }\n\n          openingSessions--;\n          if (openingSessions === 0) {\n            emitter.emit('all-open');\n          }\n        });\n      }));\n  }\n\n  /**\n   * Closes the given session.\n   * @param {node-opcua~ClientSession} session The session to close.\n   * @param {Boolean} [deleteSubscriptions=true] If active subscriptions should be closed as well.\n   * @return {Promise<node-opcua~ClientSession, Error>} Fulfilled with the (now closed!) session or\n   * rejected with the error that occured while closing.\n   */\n  static close(session, deleteSubscriptions = true) {\n    if (!session || !(session instanceof ClientSession)) {\n      return Promise.reject(new Error('session is required'));\n    }\n\n    if (session._closed) {\n      return Promise.resolve();\n    }\n\n    if (session._closing) {\n      return new Promise(resolve => {\n        session._emitter.on('fully-closed', () => resolve(session));\n      });\n    }\n\n    Object.assign(session, { _closing: true });\n\n    return new Promise((resolve, reject) => {\n      function markAsClosed() {\n        openSessions.splice(openSessions.indexOf(session), 1);\n        Object.assign(session, { _closed: true });\n\n        resolve(session);\n        session._emitter.emit('fully-closed');\n      }\n\n      session.close(deleteSubscriptions, err => {\n        if (err) {\n          if (err.response &&\n            err.response.responseHeader.serviceResult === StatusCodes.BadSessionIdInvalid\n          ) {\n            Logger.debug('Attempted to close a session that does not exist');\n            markAsClosed(session);\n          } else if (err.message === 'no channel') {\n            // Client already disconnected\n            markAsClosed(session);\n          } else {\n            reject(new Error(`Unable to close session: ${err.message}`));\n          }\n        } else {\n          session._client.disconnect(clientErr => {\n            if (clientErr) {\n              reject(new Error(`Unable to disconnect client: ${clientErr.message}`));\n            } else {\n              markAsClosed(session);\n            }\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * The sessions currently open.\n   * @type {Session[]}\n   */\n  static get open() {\n    return openSessions;\n  }\n\n  /**\n   * Closes all open sessions.\n   * @return {Promise<Error, Session[]>} Rejected with the error that occurred while closing the\n   * sessions or fulfilled with the (now closed) sessions affected.\n   */\n  static closeOpen() {\n    function closeSessions(sessions) {\n      return Promise.all(\n        sessions.map(session => Session.close(session))\n      );\n    }\n\n    if (openingSessions === 0) {\n      if (openSessions.length === 0) {\n        return Promise.resolve([]);\n      }\n\n      return closeSessions(openSessions);\n    }\n\n    return new Promise((resolve, reject) => {\n      emitter.once('all-open', () => {\n        closeSessions(openSessions)\n          .then(resolve, reject);\n      });\n    });\n  }\n\n}\n"]}