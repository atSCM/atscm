{"version":3,"sources":["../../../src/lib/helpers/xml.js"],"names":["isElement","type","isElementWithName","name","tagName","textContent","node","elements","contentNode","findChildren","Array","isArray","reduce","nodes","results","n","concat","filter","child","findChild","gotPath","length","remaining","slice","i","removeChildren","removed","push","removeChild","splice","createTextNode","text","createCDataNode","cdata","createElement","undefined","attributes"],"mappings":"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","sourcesContent":["// Nodes properties\n\n/**\n * Tells if the given parsed XML node is an element (not a text / cdata node).\n * @param {Object} node The parsed node.\n * @return {boolean} `true` if the node has type 'element'.\n */\nexport function isElement({ type }) {\n  return type === 'element';\n}\n\n/** Tells if the given parsed XML node is an elment and has the given tag name.\n * @param {Object} node The parsed node.\n * @param {string} tagName The tag name to check for.\n * @return {boolean} `true` if the node is an element with the given tag name.\n */\nexport function isElementWithName({ type, name }, tagName) {\n  return isElement({ type }) && name === tagName;\n}\n\n/**\n * Returns a parsed node's text content. Works for 'text' and 'cdata' nodes.\n * @param {Object} node The parsedNode.\n * @return {string?} The nodes text content.\n */\nexport function textContent(node) {\n  if (!node || !node.elements) { return null; }\n\n  const contentNode = node.elements[0];\n\n  // FIXME: Only works for { type: 'text', text: 'value' } and { type: 'cdata', cdata: 'data' }\n  return contentNode[contentNode.type];\n}\n\n// Traversing nodes\n\n/**\n * Returns a node's child elements with the given tag name.\n * @param {Object} node The node to check in.\n * @param {string|string[]} tagName The tag name to search for. If an array is passed, the tree is\n * traversed.\n * @return {Object[]} The matching child elements.\n */\nexport function findChildren(node, tagName) {\n  if (!node || !node.elements) { return []; }\n\n  if (Array.isArray(tagName)) {\n    return tagName.reduce(\n      (nodes, name) => nodes.reduce(\n        (results, n) => results.concat(findChildren(n, name)),\n        []),\n      [node]\n    );\n  }\n\n  return node.elements.filter(child => isElementWithName(child, tagName));\n}\n\n/**\n * Returns a node's first child element with the given tag name, or `null`.\n * @param {Object} node The node to check in.\n * @param {string|string[]} tagName The tag name to search for. If an array is passed, the tree is\n * traversed.\n * @return {Object?} The matching child elements.\n */\nexport function findChild(node, tagName) {\n  const gotPath = Array.isArray(tagName);\n\n  if (!node || (!node.elements && !gotPath)) { return null; }\n\n  if (gotPath) {\n    if (tagName.length === 0) { return node; }\n\n    const child = findChild(node, tagName[0]);\n    const remaining = tagName.slice(1);\n\n    return remaining.length ? findChild(child, remaining) : child;\n  }\n\n  for (let i = 0; i < node.elements.length; i++) {\n    if (isElementWithName(node.elements[i], tagName)) {\n      return node.elements[i];\n    }\n  }\n\n  return null;\n}\n\n// Manipulating nodes\n\n/**\n * Returns and removes a node's child elements with the given tag name.\n * @param {Object} node The node to check in.\n * @param {string} tagName The tag name to search for.\n * @return {Object[]} The matching child elements.\n */\nexport function removeChildren(node, tagName) {\n  if (!node || !node.elements) { return []; }\n\n  const removed = [];\n\n  // eslint-disable-next-line no-param-reassign\n  node.elements = node.elements.filter(child => {\n    if (isElementWithName(child, tagName)) {\n      removed.push(child);\n      return false;\n    }\n    return true;\n  });\n\n  return removed;\n}\n\n/**\n * Returns and removes a node's first child element with the given tag name, if no match is found\n * `null` is returned.\n * @param {Object} node The node to check in.\n * @param {string} tagName The tag name to search for.\n * @return {Object?} The matching child elements.\n */\nexport function removeChild(node, tagName) {\n  if (!node || !node.elements) { return null; }\n\n  for (let i = 0; i < node.elements.length; i++) {\n    if (isElementWithName(node.elements[i], tagName)) {\n      return node.elements.splice(i, 1)[0];\n    }\n  }\n\n  return null;\n}\n\n// Creating nodes\n\n/**\n * Creates a new text node.\n * @param {string} [text=''] The node's content.\n * @return {Object} A text node containing the given text.\n */\nexport function createTextNode(text = '') {\n  return { type: 'text', text: text || '' };\n}\n\n/**\n * Creates a new CData node.\n * @param {string} [cdata=''] The node's content.\n * @return {Object} A CData node containing the given data.\n */\nexport function createCDataNode(cdata = '') {\n  return { type: 'cdata', cdata };\n}\n\n/**\n * Creates a new element node.\n * @param {string} name The node's name.\n * @param {Object[]} [elements=undefined] The child elements to add.\n * @param {Object} [attributes={}] The attributes the new node should have.\n * @return {Object} An element node.\n */\nexport function createElement(name, elements = undefined, attributes = {}) {\n  return { type: 'element', name, elements, attributes };\n}\n"],"file":"xml.js"}