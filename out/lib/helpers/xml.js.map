{"version":3,"sources":["../../../src/lib/helpers/xml.js"],"names":["isElement","isElementWithName","textContent","findChildren","findChild","removeChildren","removeChild","createTextNode","createCDataNode","createElement","type","name","tagName","node","elements","contentNode","Array","isArray","reduce","nodes","results","n","concat","filter","child","gotPath","length","remaining","slice","i","removed","push","splice","text","cdata","undefined","attributes"],"mappings":"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","file":"xml.js","sourcesContent":["// Nodes properties\n\n/**\n * Tells if the given parsed XML node is an element (not a text / cdata node).\n * @param {Object} node The parsed node.\n * @return {boolean} `true` if the node has type 'element'.\n */\nexport function isElement({ type }) {\n  return type === 'element';\n}\n\n/** Tells if the given parsed XML node is an elment and has the given tag name.\n * @param {Object} node The parsed node.\n * @param {string} tagName The tag name to check for.\n * @return {boolean} `true` if the node is an element with the given tag name.\n */\nexport function isElementWithName({ type, name }, tagName) {\n  return isElement({ type }) && name === tagName;\n}\n\n/**\n * Returns a parsed node's text content. Works for 'text' and 'cdata' nodes.\n * @param {Object} node The parsedNode.\n * @return {string?} The nodes text content.\n */\nexport function textContent(node) {\n  if (!node || !node.elements) { return null; }\n\n  const contentNode = node.elements[0];\n\n  // FIXME: Only works for { type: 'text', text: 'value' } and { type: 'cdata', cdata: 'data' }\n  return contentNode[contentNode.type];\n}\n\n// Traversing nodes\n\n/**\n * Returns a node's child elements with the given tag name.\n * @param {Object} node The node to check in.\n * @param {string|string[]} tagName The tag name to search for. If an array is passed, the tree is\n * traversed.\n * @return {Object[]} The matching child elements.\n */\nexport function findChildren(node, tagName) {\n  if (!node || !node.elements) { return []; }\n\n  if (Array.isArray(tagName)) {\n    return tagName.reduce(\n      (nodes, name) => nodes.reduce(\n        (results, n) => results.concat(findChildren(n, name)),\n        []),\n      [node]\n    );\n  }\n\n  return node.elements.filter(child => isElementWithName(child, tagName));\n}\n\n/**\n * Returns a node's first child element with the given tag name, or `null`.\n * @param {Object} node The node to check in.\n * @param {string|string[]} tagName The tag name to search for. If an array is passed, the tree is\n * traversed.\n * @return {Object?} The matching child elements.\n */\nexport function findChild(node, tagName) {\n  const gotPath = Array.isArray(tagName);\n\n  if (!node || (!node.elements && !gotPath)) { return null; }\n\n  if (gotPath) {\n    if (tagName.length === 0) { return node; }\n\n    const child = findChild(node, tagName[0]);\n    const remaining = tagName.slice(1);\n\n    return remaining.length ? findChild(child, remaining) : child;\n  }\n\n  for (let i = 0; i < node.elements.length; i++) {\n    if (isElementWithName(node.elements[i], tagName)) {\n      return node.elements[i];\n    }\n  }\n\n  return null;\n}\n\n// Manipulating nodes\n\n/**\n * Returns and removes a node's child elements with the given tag name.\n * @param {Object} node The node to check in.\n * @param {string} tagName The tag name to search for.\n * @return {Object[]} The matching child elements.\n */\nexport function removeChildren(node, tagName) {\n  if (!node || !node.elements) { return []; }\n\n  const removed = [];\n\n  // eslint-disable-next-line no-param-reassign\n  node.elements = node.elements.filter(child => {\n    if (isElementWithName(child, tagName)) {\n      removed.push(child);\n      return false;\n    }\n    return true;\n  });\n\n  return removed;\n}\n\n/**\n * Returns and removes a node's first child element with the given tag name, if no match is found\n * `null` is returned.\n * @param {Object} node The node to check in.\n * @param {string} tagName The tag name to search for.\n * @return {Object?} The matching child elements.\n */\nexport function removeChild(node, tagName) {\n  if (!node || !node.elements) { return null; }\n\n  for (let i = 0; i < node.elements.length; i++) {\n    if (isElementWithName(node.elements[i], tagName)) {\n      return node.elements.splice(i, 1)[0];\n    }\n  }\n\n  return null;\n}\n\n// Creating nodes\n\n/**\n * Creates a new text node.\n * @param {string} [text=''] The node's content.\n * @return {Object} A text node containing the given text.\n */\nexport function createTextNode(text = '') {\n  return { type: 'text', text };\n}\n\n/**\n * Creates a new CData node.\n * @param {string} [cdata=''] The node's content.\n * @return {Object} A CData node containing the given data.\n */\nexport function createCDataNode(cdata = '') {\n  return { type: 'cdata', cdata };\n}\n\n/**\n * Creates a new element node.\n * @param {string} name The node's name.\n * @param {Object[]} [elements=undefined] The child elements to add.\n * @param {Object} [attributes={}] The attributes the new node should have.\n * @return {Object} An element node.\n */\nexport function createElement(name, elements = undefined, attributes = {}) {\n  return { type: 'element', name, elements, attributes };\n}\n"]}