{"version":3,"sources":["../../../src/lib/pull/BrowseStream.js"],"names":["ValidReferenceTypes","HasComponent","HasProperty","HasTypeDefinition","HasSubtype","HasEventSource","HasNotifier","HasHistoricalConfiguration","HasModellingRule","BrowseReferenceTypes","AtviseReferenceTypes","Organizes","TypeDefinitionReferenceTypes","BrowseStream","constructor","nodesToBrowse","options","Array","length","Error","ignoreNodes","recursive","undefined","_resultMask","makeResultMask","ignoredRegExp","RegExp","map","n","value","toString","join","forEach","nodeId","write","once","end","shouldBeMappedAsContentFile","ref","isChildNodeRef","$nodeClass","Variable","shouldBeMappedAsAtviseReferenceFile","indexOf","referenceTypeId","shouldBeMappedAsTypeDefinitionFile","shouldBeBrowsed","split","isBaseTypeRef","isValidRef","opcNodeIdToExpandedNodeId","Object","setPrototypeOf","prototype","processErrorMessage","matchesFilter","isIgnored","refNodeId","match","debug","processChunk","handleErrors","session","browse","browseDirection","BrowseDirection","Forward","includeSubtypes","resultMask","err","results","statusCode","done","atvReferences","typeDefinitionReferences","baseTypeReferences","Promise","all","references","filter","push","resolve","then"],"mappings":"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","file":"BrowseStream.js","sourcesContent":["import Logger from 'gulplog';\nimport { browse_service as BrowseService, NodeClass, ReferenceTypeIds } from 'node-opcua';\nimport QueueStream from '../stream/QueueStream';\nimport InstanceTypeDefinitionItem from '../mapping/InstanceTypeDefinitionItem';\nimport AtviseReferenceItem from '../mapping/AtviseReferenceItem';\nimport BaseTypeDefinitionItem from '../mapping/BaseTypeDefinitionItem';\nimport ReadNodeItem from '../mapping/ReadNodeItem';\nimport NodeId from '../ua/NodeId';\nimport Project from '../../config/ProjectConfig';\n\n/**\n * List of valid reference types\n * @type {node-opcua~ReferenceTypeId{}}\n */\nconst ValidReferenceTypes = [\n  ReferenceTypeIds.HasComponent,\n  ReferenceTypeIds.HasProperty,\n  ReferenceTypeIds.HasTypeDefinition,\n  ReferenceTypeIds.HasSubtype,\n  ReferenceTypeIds.HasEventSource,\n  ReferenceTypeIds.HasNotifier,\n  ReferenceTypeIds.HasHistoricalConfiguration,\n  ReferenceTypeIds.HasModellingRule,\n];\n\n/**\n * List of reference types that should be browsed\n * @type {node-opcua~ReferenceTypeId{}}\n */\nconst BrowseReferenceTypes = [\n  ReferenceTypeIds.HasComponent,\n  ReferenceTypeIds.HasProperty,\n  ReferenceTypeIds.HasSubtype,\n  ReferenceTypeIds.HasEventSource,\n  ReferenceTypeIds.HasNotifier,\n];\n\n/**\n * List of reference types that are used for node metadata\n * @type {node-opcua~ReferenceTypeId{}}\n */\nconst AtviseReferenceTypes = [\n  ReferenceTypeIds.HasEventSource,\n  ReferenceTypeIds.HasNotifier,\n  ReferenceTypeIds.HasHistoricalConfiguration,\n  ReferenceTypeIds.Organizes,\n];\n\n/**\n * List of reference types that are used for node metadata\n * @type {node-opcua~ReferenceTypeId{}}\n */\nconst TypeDefinitionReferenceTypes = [\n  ReferenceTypeIds.HasTypeDefinition,\n  ReferenceTypeIds.HasModellingRule,\n];\n\n\n/**\n * A stream that browses the nodes specified and (if *recursive* option is set) it's child nodes.\n */\nexport default class BrowseStream extends QueueStream {\n\n  /**\n   * Creates a new NodeStream based on the nodes to start browsing with and some options.\n   * @param {NodeId[]} nodesToBrowse The nodes to start browsing with.\n   * @param {Object} [options] The options to use.\n   * @param {Boolean} [options.recursive=true] If the discovered nodes should be browsed as well.\n   * @param {NodeId[]} [options.ignoreNodes=ProjectConfig.ignoreNodes] An array of {@link NodeId}s\n   * to ignore.\n   */\n  constructor(nodesToBrowse, options = {}) {\n    if (!nodesToBrowse || !(nodesToBrowse instanceof Array) || nodesToBrowse.length === 0) {\n      throw new Error('nodesToBrowse is required');\n    }\n\n    if (options && options.ignoreNodes && !(options.ignoreNodes instanceof Array)) {\n      throw new Error('ignoreNodes must be an array of node ids');\n    }\n\n    super(options);\n\n    // Handle options\n    /**\n     * If the discovered nodes should be browsed as well.\n     * @type {Boolean}\n     */\n    this.recursive = true;\n    if (options.recursive !== undefined) {\n      this.recursive = options.recursive;\n    }\n\n    let ignoreNodes = Project.ignoreNodes;\n    if (options.ignoreNodes !== undefined) {\n      ignoreNodes = options.ignoreNodes;\n    }\n\n    /**\n     * The result mask to use.\n     * @type {UInt32}\n     */\n    this._resultMask = BrowseService.makeResultMask('ReferenceType | NodeClass | TypeDefinition');\n\n    /**\n     * A regular expression matching all node ids specified in {@link NodeStream#ignoreNodes}\n     * @type {RegExp}\n     */\n    this.ignoredRegExp = new RegExp(`^(${ignoreNodes.map(n => n.value.toString()).join('|')})`);\n\n    // Write nodes to read\n    // Append nodes to queue\n    nodesToBrowse.forEach(nodeId => this.write(nodeId));\n\n    // End once drained\n    this.once('drained', () => {\n      this.end();\n    });\n  }\n\n  /**\n   * Checks if the given reference should be mapped as content file or not\n   * @param{node-opcua~ReferenceDescription} ref The reference description to check\n   * @param{node-opcua~NodeId} nodeId The browsed nodeId\n   * @return {Boolean} reference should be mapped as content file(=true) or not(=false)\n   */\n  static shouldBeMappedAsContentFile(ref, nodeId) {\n    return BrowseStream.isChildNodeRef(ref, nodeId) &&\n      ref.$nodeClass.value === NodeClass.Variable.value;\n  }\n\n  /**\n   * Checks if the given reference should be mapped as atvise reference file\n   * @param{node-opcua~ReferenceDescription} ref The reference description to check\n   * @return {Boolean} reference should be mapped as atvise reference file(=true) or not(=false)\n   */\n  static shouldBeMappedAsAtviseReferenceFile(ref) {\n    return AtviseReferenceTypes.indexOf(ref.referenceTypeId.value) > -1;\n  }\n\n  /**\n   * Checks if the given reference should be mapped as type definition file or not\n   * @param{node-opcua~ReferenceDescription} ref The reference description to check\n   * @return {Boolean} reference should be mapped as type definition(=true) or not(=false)\n   */\n  static shouldBeMappedAsTypeDefinitionFile(ref) {\n    return TypeDefinitionReferenceTypes.indexOf(ref.referenceTypeId.value) > -1;\n  }\n\n  /**\n   * Checks if the given reference should be pushed to NodeStream input or not\n   * @param{node-opcua~ReferenceDescription} ref The reference description to check\n   * @param{node-opcua~NodeId} nodeId The browsed nodeId\n   * @return {Boolean} reference should be pushed(=true) or not(=false)\n   */\n  static shouldBeBrowsed(ref, nodeId) {\n    return BrowseReferenceTypes.indexOf(ref.referenceTypeId.value) > -1 &&\n      BrowseStream.isChildNodeRef(ref, nodeId);\n  }\n\n  /**\n   * Checks if the given reference points to a child node reference or not\n   * @param{node-opcua~ReferenceDescription} ref The reference description to check\n   * @param{node-opcua~NodeId} nodeId The browsed nodeId\n   * @return {Boolean} reference points to a child node(=true) or not(=false)\n   */\n  static isChildNodeRef(ref, nodeId) {\n    return ref.nodeId.toString().split(nodeId.value).length > 1;\n  }\n\n  /**\n   * Checks if the given reference is a object type definition\n   * @param{node-opcua~ReferenceDescription} ref The reference description to check\n   * @return {Bool} reference is a object type definition(=true) or not(=false)\n   */\n  static isBaseTypeRef(ref) {\n    return ref.referenceTypeId.value === ReferenceTypeIds.HasSubtype;\n  }\n\n  /**\n   * Checks if the given reference is a valid browse stream reference or not\n   * @param{node-opcua~ReferenceDescription} ref The reference description to check\n   * @return {Boolean} reference is valid(=true) or not(=false)\n   */\n  static isValidRef(ref) {\n    return ValidReferenceTypes.indexOf(ref.referenceTypeId.value) > -1;\n  }\n\n\n  /**\n   * Casts the nodeId object of the given reference description to a NodeId object\n   * @param{node-opcua~ReferenceDescription} ref The reference description to cast\n   */\n  static opcNodeIdToExpandedNodeId(ref) {\n    // 'cast' reference nodeId to NodeId\n    Object.setPrototypeOf(ref.nodeId, NodeId.prototype);\n  }\n\n  /**\n   * Returns an error message specifically for the given nodeId.\n   * @param {NodeId} nodeId The node id to get the error message for.\n   * @return {String} The specific error message.\n   */\n  processErrorMessage(nodeId) {\n    return `Error browsing ${nodeId.toString()}`;\n  }\n\n  /**\n   * Checks if the given reference matches the defined browse Filters\n   * @param{node-opcua~ReferenceDescription} ref The reference description to check\n   * @return {Boolean} reference matches browse filters(=true) or not(=false)\n   */\n  matchesFilter(ref) {\n    return BrowseStream.isValidRef(ref) && !this.isIgnored(ref);\n  }\n\n  /**\n   * Checks if the given reference description is ignored\n   * @param{node-opcua~ReferenceDescription} ref The reference description to check\n   * @return {Boolean} The given reference description should be ignored(=true) or not(=false)\n   */\n  isIgnored(ref) {\n    const refNodeId = ref.nodeId.value.toString();\n\n    if (refNodeId.match(this.ignoredRegExp)) {\n      Logger.debug(`Ignored node: ${refNodeId}`);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns {MappingItem}s for the given browse node id.\n   * @param {NodeId} nodeId The node id to browse.\n   * @param {function(err: Error, statusCode: node-opcua~StatusCodes, onSuccess: function)}\n   * handleErrors The error handler to call. See {@link QueueStream#processChunk} for details.\n   */\n  processChunk(nodeId, handleErrors) {\n    // browses forward\n    this.session.browse({\n      nodeId,\n      browseDirection: BrowseService.BrowseDirection.Forward,\n      includeSubtypes: true,\n      resultMask: this._resultMask,\n    }, (err, results) => {\n      if (!err && (!results || results.length === 0)) {\n        handleErrors(new Error('No results'));\n      } else {\n        handleErrors(err, results && results.length > 0 ? results[0].statusCode : null, done => {\n          const atvReferences = [];\n          const typeDefinitionReferences = [];\n          const baseTypeReferences = [];\n          const nodesToBrowse = [];\n\n          Promise.all(\n            results[0].references\n              // Remove parent nodes and ignore specified nodes\n              .filter(ref => this.matchesFilter(ref, nodeId))\n              // Push variable and object nodes, recurse\n              .map(ref => {\n                BrowseStream.opcNodeIdToExpandedNodeId(ref);\n\n                if (BrowseStream.isBaseTypeRef(ref)) {\n                  baseTypeReferences.push(ref);\n                } else if (BrowseStream.shouldBeMappedAsTypeDefinitionFile(ref)) {\n                  typeDefinitionReferences.push(ref);\n                } else if (BrowseStream.shouldBeMappedAsAtviseReferenceFile(ref)) {\n                  atvReferences.push(ref);\n                } else if (BrowseStream.shouldBeMappedAsContentFile(ref, nodeId)) {\n                  this.push(new ReadNodeItem(nodeId, ref));\n                }\n\n                // Only browse variable types and objects recursively\n                if (this.recursive && BrowseStream.shouldBeBrowsed(ref, nodeId) &&\n                  nodesToBrowse.indexOf(ref.nodeId.value) < 0) {\n                  nodesToBrowse.push(ref.nodeId.value);\n\n                  return new Promise((resolve) => {\n                    this.write(ref.nodeId, null, resolve);\n                  });\n                }\n\n                return false;\n              })\n          )\n            .then(() => {\n              // create type definition item if browsed item has type definition references\n              if (typeDefinitionReferences.length > 0) {\n                this.push(new InstanceTypeDefinitionItem(nodeId, typeDefinitionReferences));\n              }\n              // create atvise reference item if browsed item has type definition references\n              if (atvReferences.length > 0) {\n                this.push(new AtviseReferenceItem(nodeId, atvReferences));\n              }\n\n              // create type definition items for object types\n              baseTypeReferences.map(ref => this.push(new BaseTypeDefinitionItem(nodeId, ref)));\n              done();\n            });\n        });\n      }\n    });\n  }\n}\n"]}