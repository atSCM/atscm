{"version":3,"sources":["../../../src/lib/stream/Stream.js"],"names":["Stream","objectMode","constructor","options","_keepSessionAlive","keepSessionAlive","create","then","session","emit","catch","err","_flush","callback","close"],"mappings":";;;;;;AAAA;;AACA;;;;;;AAEA;;;AAGe,MAAMA,MAAN,SAAqB,mBAAmB,EAAEC,YAAY,IAAd,EAAnB,CAArB,CAA8D;;AAE3E;;;;;;;;;AASAC,cAAYC,UAAU,EAAtB,EAA0B;AACxB,UAAMA,OAAN;;AAEA;;;;AAIA,SAAKC,iBAAL,GAAyBD,QAAQE,gBAAR,IAA4B,KAArD;;AAEA,sBAAQC,MAAR,GACGC,IADH,CACQC,WAAY,KAAKA,OAAL,GAAeA,OADnC,EAEGD,IAFH,CAEQC,WAAW,KAAKC,IAAL,CAAU,cAAV,EAA0BD,OAA1B,CAFnB,EAGGE,KAHH,CAGSC,OAAO,KAAKF,IAAL,CAAU,OAAV,EAAmBE,GAAnB,CAHhB;AAID;;AAED;;;;AAIAC,SAAOC,QAAP,EAAiB;AACf,QAAI,KAAKL,OAAL,IAAgB,CAAC,KAAKJ,iBAA1B,EAA6C;AAC3C,wBAAQU,KAAR,CAAc,KAAKN,OAAnB,EACGD,IADH,CACQ,MAAMM,UADd,EAEGH,KAFH,CAESC,OAAOE,SAASF,GAAT,CAFhB;AAGD,KAJD,MAIO;AACLE;AACD;AACF;;AAtC0E;kBAAxDb,M","file":"Stream.js","sourcesContent":["import { ctor as throughStreamClass } from 'through2';\nimport Session from '../ua/Session';\n\n/**\n * An object transform stream connected to atvise server.\n */\nexport default class Stream extends throughStreamClass({ objectMode: true }) {\n\n  /**\n   * Creates a new Stream and starts opening a new session to atvise server.\n   * @param {Object} [options] The options to use. See\n   * [through2 documentation](https://github.com/rvagg/through2#options) for details.\n   * @param {Boolean} [options.keepSessionAlive=false] If the ativse server session should be closed\n   * one the stream ends.\n   * @emits {Session} Emits an `session-open` event once the session is open, passing the Session\n   * instance.\n   */\n  constructor(options = {}) {\n    super(options);\n\n    /**\n     * `true` if the stream's atvise server session should be kept alive once the stream ends.\n     * @type {Boolean}\n     */\n    this._keepSessionAlive = options.keepSessionAlive || false;\n\n    Session.create()\n      .then(session => (this.session = session))\n      .then(session => this.emit('session-open', session))\n      .catch(err => this.emit('error', err));\n  }\n\n  /**\n   * Called just before the stream is closed: Closes the open session.\n   * @param {function(err: ?Error, data: Object)} callback Called once the session is closed.\n   */\n  _flush(callback) {\n    if (this.session && !this._keepSessionAlive) {\n      Session.close(this.session)\n        .then(() => callback())\n        .catch(err => callback(err));\n    } else {\n      callback();\n    }\n  }\n\n}\n"]}