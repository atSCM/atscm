{"version":3,"sources":["../../../src/lib/mapping/AtviseFile.js"],"names":["AtviseTypesByValue","reduce","result","type","Object","assign","typeDefinition","value","AtviseTypesByIdentifier","identifier","ArrayValueSeperator","ExtensionForDataType","Boolean","XmlElement","reverseObject","obj","keys","key","DataTypeForExtension","types","typeExtensions","map","t","toLowerCase","VariableTypeDefinition","NodeIdType","NUMERIC","PropertyTypeDefinition","ExtensionRegExp","Decoder","stringValue","String","NodeId","DateTime","Date","UInt64","parseInt","Int64","Int32","SByte","Byte","UInt32","Double","parseFloat","Float","LocalizedText","split","CreateNodeDecoder","ByteString","buffer","toString","getTime","uint32ArraysToInt64","lowerRangeValue","higherRangeValue","int64","isFinite","Error","Encoder","uInt32Array","int32Array","byteString","Buffer","extensionForDataType","dataType","AtviseFile","pathForItemConfig","config","path","nodeId","filePath","browseName","arrayType","fileExtension","keepExtension","atType","Scalar","Array","getAtviseTypesByValue","encodeValue","from","encoder","arrayContent","item","join","trim","decodeValue","useCreateNodeEncoding","decoder","bufferValue","length","arrayValue","normalizeMtime","date","setMilliseconds","fromMappingItem","mappingItem","configObj","contents","_dataType","_arrayType","_typeDefinition","stat","mtime","undefined","_getMetadata","extensions","relPath","relativeFilePath","m","match","dirnameExts","unshift","ifLastExtensionMatches","matches","fn","pop","complete","ext","Matrix","includes","indexOf","foundAtType","forEach","srcPath","process","cwd","RelativeSourceDirectoryPath","isDisplay","isScript","isQuickDynamic","isTypeDefinition","isBaseTypeDefinition","isInstanceTypeDefinition","isAtviseReferenceConfig","newValue","createNodeValue","fromFilePath","clone","options","clonedFile","read","Promise","resolve","reject","err"],"mappings":"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","file":"AtviseFile.js","sourcesContent":["import Int64 from 'node-int64';\nimport { readFile } from 'fs';\nimport { dirname, join, relative } from 'path';\nimport { DataType, VariantArrayType, resolveNodeId, coerceLocalizedText } from 'node-opcua';\nimport File from 'vinyl';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport AtviseTypes from './Types';\nimport NodeId from '../ua/NodeId';\n\n/**\n * A map of AtviseTypes against their definition id's value.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByValue = AtviseTypes\n    .reduce((result, type) => Object.assign(result, {\n      [type.typeDefinition.value]: type,\n    }), {});\n\n/**\n * A map of AtviseTypes against their identifiers.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByIdentifier = AtviseTypes\n    .reduce((result, type) => Object.assign(result, {\n      [type.identifier]: type,\n    }), {});\n\n\n/**\n * Seperator for array values\n * @type {String}\n */\nconst ArrayValueSeperator = '@atscmUaNodeArraySeperator@';\n\n/**\n * A map providing shorter extensions for data types\n * @type {Map<node-opcua~DataType, String>}\n */\nexport const ExtensionForDataType = {\n  [DataType.Boolean]: 'bool',\n  [DataType.XmlElement]: 'xml',\n};\n\n/**\n * Switches keys and values in an object. E.G.: { \"a\": 1 } becomes { 1: \"a\" }.\n * @param {Object} obj The object to reverse.\n * @return {Object} The reversed object.\n */\nfunction reverseObject(obj) {\n  return Object.keys(obj)\n      .reduce((result, key) => Object.assign(result, {\n        [obj[key]]: key,\n      }), {});\n}\n\n/**\n * A map providing data types for shorter extensions (Reverse of {@link DataTypeForExtension}).\n * * @type {Map<String, node-opcua~DataType>}\n */\nexport const DataTypeForExtension = reverseObject(ExtensionForDataType);\n\n// Cache DataType\n/**\n * OPC-UA data type names.\n * @type {String[]}\n */\nconst types = Object.keys(DataType);\n\n/**\n * OPC-UA data type extensions.\n * @type {String[]}\n */\nconst typeExtensions = types.map(t => t.toLowerCase());\n\n// Cache TypeDefinitions\n/**\n * Variable data type definition node id.\n * @type {NodeId}\n */\nconst VariableTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0);\n/**\n * Property data type definition node id.\n * @type {NodeId}\n */\nconst PropertyTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0);\n\n// Cache Regular expressions\n/**\n * A regular expression picking file extensions from file names.\n * @type {RegExp}\n */\nconst ExtensionRegExp = /\\.([^/\\\\]*)$/;\n\n// Value encoding related cache\n/**\n * A set of functions that decode raw stored node values to their original value.\n * @type {Map<node-opcua~DataType, function(rawValue: String): *>}\n */\nconst Decoder = {\n  [DataType.Boolean]: stringValue => stringValue === 'true',\n  [DataType.String]: stringValue => stringValue,\n  [DataType.NodeId]: stringValue => resolveNodeId(stringValue),\n  [DataType.DateTime]: stringValue => new Date(stringValue),\n  [DataType.UInt64]: stringValue => parseInt(stringValue, 10),\n  [DataType.Int64]: stringValue => parseInt(stringValue, 10),\n  [DataType.Int32]: stringValue => parseInt(stringValue, 10),\n  [DataType.SByte]: stringValue => parseInt(stringValue, 10),\n  [DataType.Byte]: stringValue => parseInt(stringValue, 10),\n  [DataType.UInt32]: stringValue => parseInt(stringValue, 10),\n  [DataType.Double]: stringValue => parseFloat(stringValue, 10),\n  [DataType.Float]: stringValue => parseFloat(stringValue, 10),\n  [DataType.XmlElement]: stringValue => stringValue,\n  [DataType.LocalizedText]: stringValue => coerceLocalizedText(stringValue.split('text=')[1]),\n};\n\n\n/**\n * A set of functions that decode node values create node script.\n * @type {Map<node-opcua~DataType, function(value: *): String>}\n */\nconst CreateNodeDecoder = {\n  [DataType.ByteString]: buffer => buffer.toString('binary'),\n  [DataType.DateTime]: buffer => new Date(buffer.toString()).getTime(),\n};\n\n\n/**\n * Converts safely two uint32 array to an int64 number type.\n * @param {Number} lowerRangeValue The value for the lower 32 bits of the int 64 value\n * @param {Number} higherRangeValue The value for the higher 32 bits of the int 64 value\n * @returns {Number} The resulting int64 value\n */\nfunction uint32ArraysToInt64(lowerRangeValue, higherRangeValue) {\n  const int64 = new Int64(lowerRangeValue, higherRangeValue);\n\n  if (!isFinite(int64)) {\n    throw new Error('Value is too big for Javascript Number type');\n  }\n\n  return int64.toString();\n}\n\n\n/**\n * A set of functions that encode node values before storing them.\n * @type {Map<node-opcua~DataType, function(value: *): String>}\n */\nconst Encoder = {\n  [DataType.UInt64]: uInt32Array => uint32ArraysToInt64(uInt32Array[0], uInt32Array[1]),\n  [DataType.Int64]: int32Array => uint32ArraysToInt64(int32Array[0], int32Array[1]),\n  [DataType.ByteString]: byteString => new Buffer(byteString),\n};\n\n\n/**\n * Returns the extension for a specific {@link node-opcua~DataType}.\n * Algorithm:\n *   - if the type has a shortened extension defined in {@link ExtensionForDataType}, return it.\n *   - else return the DataType's name, in lowercase letters.\n * @param {node-opcua~DataType} dataType The datatype to get the extension for.\n * @return {string} The resulting extension.\n */\nfunction extensionForDataType(dataType) {\n  return ExtensionForDataType[dataType] || dataType.toString().toLowerCase();\n}\n\n/**\n * An extension to {@link vinyl~File} providing some additional, atvise-related properties.\n * @property {node-opcua~DataType} AtviseFile#dataType The {@link node-opcua~DataType} the node is\n * stored against on atvise server.\n * @property {NodeId} typeDefinition The file's type definition on atvise server.\n * FIXME: Additional properties not showing in API docs.\n */\nexport default class AtviseFile extends File {\n\n  /**\n   * Returns a storage path for a {@link MappingItem.configObj}.\n   * @param {Object} config The config to create the path for\n   */\n  static pathForItemConfig(config) {\n    let path = `${config.nodeId.filePath}/${config.nodeId.browseName}`;\n\n    const dataType = config.dataType;\n    const arrayType = config.arrayType;\n    const typeDefinition = config.typeDefinition;\n\n    if (typeDefinition.value === VariableTypeDefinition.value) {\n      // Variable nodes are stored with their lowercase datatype as an extension\n      path += `.${extensionForDataType(dataType)}`;\n    } else if (typeDefinition.value === PropertyTypeDefinition.value) {\n      // Property nodes are stored with '.prop' and their lowercase datatype as an extension\n      path += `.prop.${extensionForDataType(dataType)}`;\n    } else {\n      // Handle custom types\n      let identifier = 'var';\n      let fileExtension = false;\n      let keepExtension = false;\n\n      const atType = AtviseTypesByValue[typeDefinition.value];\n      if (atType) {\n        identifier = atType.identifier;\n        fileExtension = atType.fileExtension;\n        keepExtension = atType.keepExtension;\n      }\n\n      if (!keepExtension) {\n        path += `.${identifier}.${fileExtension || extensionForDataType(dataType)}`;\n      }\n    }\n\n    if (arrayType) {\n      // Add 'array' or 'matrix' extensions for corresponding array types\n      if (arrayType.value !== VariantArrayType.Scalar.value) {\n        path += `.${arrayType.value === VariantArrayType.Array.value ? 'array' : 'matrix'}`;\n      }\n    }\n\n    return path;\n  }\n\n  /**\n   * Returns an atvise type with type definition as accessor\n   * @return {AtviseTypes{}} Object containing atvise types\n   */\n  static getAtviseTypesByValue() {\n    return AtviseTypesByValue;\n  }\n\n  /**\n   * Encodes a node's value to file contents.\n   * @param {*} value The value to encode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to encode the value for.\n   * @param {node-opcua~VariantArrayType} arrayType The files array type\n   * @return {?Buffer} The encoded file contents or null.\n   */\n  static encodeValue(value, dataType, arrayType) {\n    if (value === null) {\n      return Buffer.from('');\n    }\n\n    const encoder = Encoder[dataType];\n\n    if (arrayType === VariantArrayType.Array) {\n      const arrayContent = value.map(item => {\n        if (encoder) {\n          return encoder(item);\n        }\n\n        return item;\n      })\n        .join(ArrayValueSeperator);\n\n      return Buffer.from(arrayContent);\n    }\n\n    return Buffer.from(encoder ? encoder(value) : value.toString().trim());\n  }\n\n  /**\n   * Decodes a file's contents to a node's value.\n   * @param {Buffer} buffer The file contents to decode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to decode the contents\n   * @param {node-opcua~VariantArrayType} arrayType The files array type\n   * @param {Boolean} useCreateNodeEncoding If set to `true`, create node decoders will overwrite\n   * the existing decoders\n   * @return {?*} The decoded node value or null.\n   */\n  static decodeValue(buffer, dataType, arrayType, useCreateNodeEncoding) {\n    let decoder = Decoder[dataType];\n    let bufferValue;\n\n    if (buffer === null || buffer.length === 0) {\n      return null;\n    }\n\n    if (useCreateNodeEncoding && CreateNodeDecoder[dataType]) {\n      decoder = CreateNodeDecoder[dataType];\n      bufferValue = buffer;\n    } else {\n      bufferValue = buffer.toString();\n    }\n\n    if (arrayType === VariantArrayType.Array) {\n      const arrayValue = bufferValue.toString().split(ArrayValueSeperator);\n\n      return arrayValue.map(item => {\n        if (decoder) {\n          return decoder(item);\n        }\n\n        return item;\n      });\n    } else if (decoder) {\n      return decoder(bufferValue);\n    }\n\n    return buffer;\n  }\n\n  /**\n   * As file mtimes do not support millisecond resolution these must be removed before storing\n   * files.\n   * @param {Date} date The original mtime.\n   * @return {Date} The normalized mtime.\n   */\n  static normalizeMtime(date) {\n    date.setMilliseconds(0);\n\n    return date;\n  }\n\n\n  /**\n   * Creates a new {@link AtviseFile} for the given {@link MappingItem}.\n   * @param {MappingItem} mappingItem The read result to create the file for.\n   * @return {AtviseFile} The resulting file.\n   */\n  static fromMappingItem(mappingItem) {\n    let configObj = {};\n\n    if (!mappingItem) {\n      throw new Error('Mapping item is undefined');\n    }\n\n    configObj = mappingItem.configObj;\n\n    return new AtviseFile({\n      path: AtviseFile.pathForItemConfig(configObj),\n      contents: AtviseFile.encodeValue(configObj.value, configObj.dataType, configObj.arrayType),\n      _dataType: configObj.dataType,\n      _arrayType: configObj.arrayType,\n      _typeDefinition: configObj.typeDefinition,\n      stat: { mtime: configObj.mtime ? this.normalizeMtime(configObj.mtime) : undefined },\n    });\n  }\n\n  /**\n   * Recalculates {@link AtviseFile#dataType}, {@link AtviseFile#arrayType} and\n   * {@link AtviseFile#typeDefinition}. **Never call this method directly.**.\n   */\n  _getMetadata() {\n    // Set default metadata\n    /**\n     * The node's stored {@link node-opcua~VariantArrayType}.\n     * @type {?node-opcua~VariantArrayType}\n     */\n    this._arrayType = VariantArrayType.Scalar;\n\n    let extensions = [];\n    const relPath = this.relativeFilePath;\n    const m = relPath.match(ExtensionRegExp);\n    if (m) {\n      extensions = m[1].split('.');\n    }\n\n    // For split files, add the directory name extension\n    const dirnameExts = dirname(relPath).split('.');\n    if (dirnameExts.length > 1) {\n      extensions.unshift(dirnameExts[dirnameExts.length - 1]);\n    }\n\n    function ifLastExtensionMatches(matches, fn) {\n      if (matches(extensions[extensions.length - 1])) {\n        fn(extensions.pop());\n      }\n    }\n\n    const complete = () => this._dataType !== undefined && this._typeDefinition !== undefined;\n\n    // Handle array types\n    ifLastExtensionMatches(ext => ext === 'array', () => {\n      this._arrayType = VariantArrayType.Array;\n    });\n\n    ifLastExtensionMatches(ext => ext === 'matrix', () => {\n      this._arrayType = VariantArrayType.Matrix;\n    });\n\n    ifLastExtensionMatches(ext => typeExtensions.includes(ext), ext => {\n      /**\n       * The node's stored {@link node-opcua~DataType}.\n       * @type {?node-opcua~DataType}\n       */\n      this._dataType = DataType[types[typeExtensions.indexOf(ext)]];\n    });\n\n    // Handle wrapped data types (e.g. 'bool' for DataType.Boolean)\n    ifLastExtensionMatches(ext => DataTypeForExtension[ext], ext => {\n      this._dataType = DataType[DataTypeForExtension[ext]];\n    });\n\n    if (extensions.length === 0) { // Got variable\n      /**\n       * The node's stored type definition.\n       * @type {?node-opcua~NodeId}\n       */\n      this._typeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0);\n    }\n\n    ifLastExtensionMatches(ext => ext === 'prop', () => {\n      this._typeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0);\n    });\n\n    ifLastExtensionMatches(ext => ext === 'var', () => {\n      this._typeDefinition = new NodeId('Custom.VarResourceType');\n    });\n\n    if (!complete()) {\n      // Handle atvise types\n      let foundAtType = false;\n\n      Object.keys(AtviseTypesByIdentifier).forEach(identifier => {\n        if (!foundAtType && extensions.includes(identifier)) {\n          foundAtType = true;\n          const type = AtviseTypesByIdentifier[identifier];\n\n          this._typeDefinition = type.typeDefinition;\n          this._dataType = type.dataType;\n        }\n      });\n    }\n\n    if (!complete()) {\n      this._typeDefinition = new NodeId('VariableTypes.ATVISE.Resource.OctetStream');\n      this._dataType = DataType.ByteString;\n    }\n  }\n\n  /**\n   * The file's relative path (base = 'src' folder)\n   * @type {String}\n   */\n  get relativeFilePath() {\n    const path = this.path;\n    // build source path here because Project config is undefined when AtviseFile is loaded\n    const srcPath = join(process.cwd(), ProjectConfig.RelativeSourceDirectoryPath);\n\n    return path.indexOf(srcPath) > -1 ? relative(srcPath, this.path) : path;\n  }\n\n  /**\n   * The file's {@link node-opcua~DataType}.\n   * @type {node-opcua~DataType}\n   */\n  get dataType() {\n    if (!this._dataType) {\n      this._getMetadata();\n    }\n\n    return this._dataType;\n  }\n\n  /**\n   * The file's {@link node-opcua~VariantArrayType}.\n   * @type {node-opcua~VariantArrayType}\n   */\n  get arrayType() {\n    if (!this._arrayType) {\n      this._getMetadata();\n    }\n\n    return this._arrayType;\n  }\n\n  /**\n   * The file's type definition.\n   * @type {node-opcua~NodeId}\n   */\n  get typeDefinition() {\n    if (!this._typeDefinition) {\n      this._getMetadata();\n    }\n\n    return this._typeDefinition;\n  }\n\n  /**\n   * `true` for files containing atvise displays.\n   * @type {boolean}\n   */\n  get isDisplay() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.Display';\n  }\n\n  /**\n   * `true` for files containing atvise scripts.\n   * @type {boolean}\n   */\n  get isScript() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.ScriptCode';\n  }\n\n  /**\n   * `true` for files containing atvise quick dynamics.\n   * @type {boolean}\n   */\n  get isQuickDynamic() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.QuickDynamic';\n  }\n\n  /**\n   * `true` for files containing type definitions.\n   * @type {Boolean}\n   */\n  get isTypeDefinition() {\n    return this.isBaseTypeDefinition || this.isInstanceTypeDefinition;\n  }\n\n\n  /**\n   * `true` for files containing instance type definitions.\n   * @type {Boolean}\n   */\n  get isInstanceTypeDefinition() {\n    return this.typeDefinition.value === 'Custom.InstanceTypeDefinition';\n  }\n\n  /**\n   * `true` for files containing base type definitions.\n   * @type {Boolean}\n   */\n  get isBaseTypeDefinition() {\n    return this.typeDefinition.value === 'Custom.BaseTypeDefinition';\n  }\n\n  /**\n   * `true` for files containing type definitions.\n   * @type {Boolean}\n   */\n  get isAtviseReferenceConfig() {\n    return this.typeDefinition.value === 'Custom.AtvReferenceConfig';\n  }\n\n  /**\n   * Sets the node value for the file.\n   * @param {?*} newValue The value to set.\n   */\n  set value(newValue) {\n    /**\n     * The file's contents.\n     * @type {?Buffer}\n     */\n    this.contents = AtviseFile.encodeValue(newValue, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for the file.\n   * @type {?*} The file's decoded value.\n   */\n  get value() {\n    return AtviseFile.decodeValue(this.contents, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for create node serverscript.\n   * @type {?*} The file's decoded value.\n   */\n  get createNodeValue() {\n    return AtviseFile.decodeValue(this.contents, this.dataType, this.arrayType, true);\n  }\n\n  /**\n   * Returns the node id associated with the file.\n   * @type {NodeId} The file's node id.\n   */\n  get nodeId() {\n    return NodeId.fromFilePath(dirname(this.relativeFilePath));\n  }\n\n  /**\n   * Returns a new file with all attributes of the current file.\n   * @param {Object} options See the {@link vinyl~File} docs for all options available.\n   * @return {AtviseFile} The cloned file.\n   * @see https://github.com/gulpjs/vinyl#filecloneoptions\n   */\n  clone(options) {\n    const clonedFile = super.clone(options);\n\n    clonedFile._arrayType = this._arrayType;\n\n    return clonedFile;\n  }\n\n  /**\n   * Creates a new AtviseFile and reads it's contents.\n   * @param {Object} options See {@link vinyl~File} for available options.\n   * @return {Promise} Resolved with the new file of rejected with the error that occured while\n   * trying to read it's path.\n   */\n  static read(options = {}) {\n    return new Promise((resolve, reject) => {\n      if (!options.path) {\n        reject(new Error('options.path is required'));\n      } else {\n        readFile(options.path, (err, contents) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(new AtviseFile(Object.assign(options, { contents })));\n          }\n        });\n      }\n    });\n  }\n}\n"]}