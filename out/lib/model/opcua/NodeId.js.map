{"version":3,"sources":["../../../../src/lib/model/opcua/NodeId.js"],"names":["Type","NodeIdType","TypeForIdentifier","i","NUMERIC","s","STRING","g","GUID","b","BYTESTRING","possibleResourceChildNodes","Set","NodeId","constructor","typeOrValue","value","namespace","get","m","match","Number","isNaN","parseInt","n","t","v","fromFilePath","path","separator","split","reduce","result","current","index","components","next","replace","has","filePath","parts","join","_lastSeparator","identifierType","indexOf","parent","substr","lastIndexOf","isChildOf","prefix","postfix","length","browseName","inspect","depth","options","stylize"],"mappings":"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","file":"NodeId.js","sourcesContent":["import { sep } from 'path';\nimport { NodeId as OpcNodeId } from 'node-opcua';\n\n/**\n * OPC-UA node id types.\n * @type {Map<String, node-opcua~NodeIdType>}\n */\nconst Type = OpcNodeId.NodeIdType;\n\n/**\n * OPC-UA node id types mapped against node-id identifiers (e.g. i, s ...).\n * @type {Map<String, node-opcua~NodeIdType>}\n */\nconst TypeForIdentifier = {\n  i: Type.NUMERIC,\n  s: Type.STRING,\n  g: Type.GUID,\n  b: Type.BYTESTRING,\n};\n\n/**\n * Resource nodes are only allowed to have these child nodes.\n * @type {Set<string>}\n */\nconst possibleResourceChildNodes = new Set([\n  'Translate',\n  'Compress',\n]);\n\n/**\n * A wrapper around {@link node-opcua~NodeId}.\n */\nexport default class NodeId extends OpcNodeId {\n\n  /**\n   * Creates a new NodeId. Can be called in multiple ways:\n   *  - with a {@link node-opcua~NodeIdType}, a value and a namespace (defaults to 0),\n   *  - with a value only (type will be taken from it, namespace defaults to 1) or\n   *  - with a {@link NodeId}s string representation (for example `ns=1;s=AGENT.DISPLAYS`).\n   * @param {node-opcua~NodeIdType|String|Number} typeOrValue The type or value to use.\n   * @param {(Number|String)} [value] The value to use.\n   * @param {number} [namespace=1] The namespace to use.\n   */\n  constructor(typeOrValue, value, namespace = 1) {\n    if (!(Type.get(typeOrValue))) {\n      let m = null;\n\n      if (typeof typeOrValue === 'string') {\n        m = typeOrValue.match(/^ns=([0-9]+);(i|s|g|b)=(.*)$/);\n      }\n\n      if (m === null) {\n        super(\n          Number.isNaN(Number.parseInt(typeOrValue, 10)) ? Type.STRING : Type.NUMERIC,\n          typeOrValue,\n          1\n        );\n      } else {\n        const n = Number.parseInt(m[1], 10);\n        const t = TypeForIdentifier[m[2]];\n        const v = t === Type.NUMERIC ? Number.parseInt(m[3], 10) : m[3];\n\n        super(t, v, n);\n      }\n    } else {\n      super(typeOrValue, value, namespace);\n    }\n  }\n\n  /**\n   * Creates a new NodeId based on a file path.\n   * @param {string} path The file path to use.\n   * @return {NodeId} The resulting NodeId.\n   */\n  static fromFilePath(path) {\n    let separator = '.';\n\n    const value = path.split(sep)\n      .reduce((result, current, index, components) => {\n        const next = `${result ? `${result}${separator}` : ''}${current.replace('%2F', '/')}`;\n\n        if (current === 'RESOURCES') {\n          separator = '/';\n        } else if (separator === '/' && possibleResourceChildNodes.has(components[index + 1])) {\n          separator = '.';\n        }\n\n        return next;\n      }, '');\n\n    return new NodeId(NodeId.NodeIdType.STRING, value, 1);\n  }\n\n  /**\n   * The node id's value, encoded to a file path.\n   * @type {string}\n   */\n  get filePath() {\n    const parts = this.value.split('RESOURCES');\n    parts[0] = parts[0]\n      .replace('/', '%2F')\n      .split('.')\n      .join('/');\n\n    return parts.join('RESOURCES');\n  }\n\n  // eslint-disable-next-line jsdoc/require-description-complete-sentence\n  /**\n   * Returns the last separator in a string node id's path, e.g.:\n   * - `'/'` for `ns=1;SYSTEM.LIBRARY.RESOURCES/index.htm`,\n   * - `'.'` for `ns=1;AGENT.DISPLAYS.Main`.\n   * @type {?string} `null` for non-string node ids, `'/'` for resource paths, `'.'` for regular\n   * string node ids.\n   */\n  get _lastSeparator() {\n    if (this.identifierType !== NodeId.NodeIdType.STRING) {\n      return null;\n    }\n\n    return ~(this.value.indexOf('/')) ? '/' : '.';\n  }\n\n  /**\n   * The parent node id, or `null`.\n   * @type {?NodeId}\n   * @deprecated Doesn't work properly in some edge cases. Use AtviseFile#parentNodeId instead\n   * whenever possible.\n   */\n  get parent() {\n    if (this.identifierType !== NodeId.NodeIdType.STRING) {\n      return null;\n    }\n\n    return new NodeId(\n      NodeId.NodeIdType.STRING,\n      this.value.substr(0, this.value.lastIndexOf(this._lastSeparator)),\n      this.namespace\n    );\n  }\n\n  /**\n   * Checks if the node is a child of another.\n   * @param {NodeId} parent The possible parent to check.\n   * @return {boolean} `true` if *this* is a child node of *parent*.\n   */\n  isChildOf(parent) {\n    if (this.identifierType !== NodeId.NodeIdType.STRING ||\n      parent.identifierType !== NodeId.NodeIdType.STRING) {\n      return false;\n    }\n\n    if (this.namespace !== parent.namespace || this.value === parent.value) {\n      return false;\n    }\n\n    const [prefix, postfix] = this.value.split(parent.value);\n\n    return (prefix === '' && postfix && (\n      postfix[0] === this._lastSeparator ||\n      (this._lastSeparator === '/' && postfix[0] === '.' && postfix.split('.').length === 2)\n    ));\n  }\n\n  /**\n   * The node id's browsename as string.\n   * @type {string}\n   */\n  get browseName() {\n    if (this.identifierType !== NodeId.NodeIdType.STRING) {\n      return null;\n    }\n\n    return this.value.substr(this.value.lastIndexOf(this._lastSeparator) + 1);\n  }\n\n  /**\n   * Returns a string in the format \"namespace value\" that is printed when inspecting the NodeId\n   * using {@link util~inspect}.\n   * @see https://nodejs.org/api/util.html#util_util_inspect_object_options\n   * @param {number} depth The depth to inspect.\n   * @param {Object} options The options to use.\n   * @return {string} A string in the format \"namespace value\".\n   */\n  inspect(depth, options) {\n    return [\n      options.stylize(this.namespace, 'number'),\n      options.stylize(this.value, this.identifierType === Type.NUMERIC ? 'number' : 'string'),\n    ].join(' ');\n  }\n\n}\n"]}