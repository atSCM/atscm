{"version":3,"sources":["../../../src/lib/model/Node.ts"],"names":["ReferenceTypeIds","OpcReferenceTypeIds","toParent","ReferenceTypeNames","ReferenceMap","Map","addReference","type","nodeId","set","get","add","Set","deleteReference","ref","delete","size","Error","getSingle","Array","from","toJSON","reduce","result","key","value","Object","assign","Node","constructor","name","parent","nodeClass","fileName","idName","_unresolved","parentResolvesMetadata","_parentResolvesMetadata","markAsResolved","_resolved","isResolved","has","id","references","_unresolvedReferences","setReferences","ids","markReferenceAsResolved","_resolvedReferences","markAllReferencesAsResolved","hasUnresolvedReference","_filePath","concat","filePath","_nodeId","specialId","separator","match","typeDefinition","HasTypeDefinition","modellingRule","HasModellingRule","hasTypeDefinition","typeDefName","def","hasUnresolvedMetadata","metadata","meta","isVariableNode","dataType","arrayType","createChild","extension","node","TypeError","isVariable","NodeClass","Variable","isDisplay","isScript","isQuickDynamic","ServerNode","renameTo","SourceNode"],"mappings":"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","sourcesContent":["import { ReferenceTypeIds as OpcReferenceTypeIds } from 'node-opcua/lib/opcua_node_ids';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport { VariantArrayType, DataType, Variant } from 'node-opcua/lib/datamodel/variant';\nimport { ItemOf, KeyOf } from 'node-opcua/lib/misc/enum.js';\nimport { reverse } from '../helpers/Object';\nimport { sortReferences } from '../helpers/mapping';\nimport { ValueOf } from '../helpers/types';\n\n/**\n * References type ids.\n */\nexport const ReferenceTypeIds = {\n  ...OpcReferenceTypeIds,\n  toParent: -1,\n};\n\n/** A reference type name */\ntype ReferenceTypeName = keyof typeof ReferenceTypeIds;\n\n/** A raw (number) reference type */\ntype ReferenceType = ValueOf<typeof ReferenceTypeIds>;\n\n/** Node references stored in definition files */\nexport type ReferenceDefinitions = {\n  [type in ReferenceTypeName]?: (number | string)[];\n};\n\n/** Node definition stored in definition file */\nexport interface NodeDefinition {\n  nodeId?: string;\n  nodeClass?: KeyOf<typeof NodeClass>; // Defaults to 'Variable'\n  dataType?: KeyOf<typeof DataType>;\n  arrayType?: KeyOf<typeof VariantArrayType>;\n  references?: ReferenceDefinitions;\n}\n\n/**\n * Names for references.\n */\nexport const ReferenceTypeNames = reverse(ReferenceTypeIds);\n\n/**\n * A map specialized for holding references.\n */\nclass ReferenceMap extends Map<ReferenceType, Set<number | string>> {\n\n  /**\n   * Adds a new reference.\n   * @param {number} type The reference id.\n   * @param {string} nodeId The reference target node's id.\n   */\n  public addReference(type: ReferenceType, nodeId: number | string): void {\n    const set = this.get(type);\n    if (set) {\n      set.add(nodeId);\n    } else {\n      this.set(type, new Set([nodeId]));\n    }\n  }\n\n  /**\n   * Removes the given reference.\n   * @param {number} type The reference id.\n   * @param {string} nodeId The reference target node's id.\n   */\n  public deleteReference(type: ReferenceType, nodeId: number | string): number | string {\n    const set = this.get(type);\n    if (set) {\n      const ref = set.delete(nodeId);\n\n      if (ref) {\n        if (set.size === 0) {\n          this.delete(type);\n        }\n\n        return nodeId;\n      }\n    }\n\n    throw new Error(`No ${ReferenceTypeNames[type] || type} reference to ${nodeId}`);\n  }\n\n  /**\n   * Returns the first entry of a specific type.\n   * @param type The reference type id to look for.\n   * @return The first reference found or undefined.\n   */\n  public getSingle(type: ReferenceType): number | string | undefined {\n    const set = this.get(type);\n    return set && Array.from(set)[0];\n  }\n\n  /**\n   * Returns a plain object of refernces.\n   * @return A string describing the reference map.\n   */\n  public toJSON(): ReferenceDefinitions {\n    return [...this]\n      .reduce((result, [key, value]) => Object.assign(result, {\n        [ReferenceTypeNames[key] || key]: [...value],\n      }), {});\n  }\n\n}\n\ninterface WithValue {\n  value: Variant;\n}\n\nexport interface NodeOptions {\n  name: string;\n  parent?: Node;\n  nodeClass: ItemOf<typeof NodeClass>;\n}\n\ntype NodeResolveKey = 'nodeClass' | 'dataType' | 'arrayType';\n\n/**\n * The main model class.\n */\nexport default abstract class Node {\n\n  /** The node's name when stored to a file. */\n  protected fileName: string;\n  /** The node's name when written to the server. */\n  protected idName: string;\n  /** The id stored in the definition file. */\n  protected specialId?: string;\n\n  /** The node's parent node. */\n  public readonly parent?: Node;\n  /** The node's class. */\n  public readonly nodeClass: ItemOf<typeof NodeClass>;\n\n  /** A set of resolved properties. */\n  protected _resolved = new Set<NodeResolveKey>();\n  /** A set of unresolved properties. */\n  protected _unresolved: Set<NodeResolveKey>;\n  /** The node's references. */\n  public references = new ReferenceMap();\n  /** The node's unresolved refernces. */\n  protected _resolvedReferences = new ReferenceMap();\n  /** The node's resolved refernces. */\n  protected _unresolvedReferences = new ReferenceMap();\n  /** If the parent node resolves metadata. */\n  protected _parentResolvesMetadata: boolean = false;\n\n  /**\n   * Creates a new node.\n   * @param {Object} options The options to use.\n   * @param {string} options.name The node's name.\n   * @param {Node} options.parent The node's parent node.\n   * @param {node-opcua~NodeClass} options.nodeClass The node's class.\n   */\n  public constructor({ name, parent, nodeClass/* , referenceToParent */ }: NodeOptions) {\n    this.fileName = name;\n    this.idName = name;\n    this.parent = parent;\n    this.nodeClass = nodeClass;\n\n    this._unresolved = new Set([\n      'nodeClass',\n      // Only for variables\n      'dataType',\n      'arrayType',\n    ]);\n  }\n\n  /**\n   * If the parent resolves metadata (for example: split transformer source files).\n   */\n  public get parentResolvesMetadata(): boolean {\n    return this._parentResolvesMetadata;\n  }\n\n  public markAsResolved(key: NodeResolveKey): void {\n    const value = this._unresolved.delete(key);\n\n    // FIXME: Only test if debug / test\n    if (value === false) {\n      throw new Error(`'${key}' is already resolved`);\n    }\n\n    this._resolved.add(key);\n  }\n\n  public isResolved(key: NodeResolveKey): boolean {\n    return this._resolved.has(key);\n  }\n\n  /**\n   * Adds a new reference.\n   * @param {number} type The reference type's id.\n   * @param {string} id The reference target node's id.\n   */\n  public addReference(type: ReferenceType, id: string): void {\n    this.references.addReference(type, id);\n    this._unresolvedReferences.addReference(type, id);\n  }\n\n  public setReferences(type: ReferenceType, ids: string[]): void {\n    this.references.set(type, new Set(ids));\n    this._unresolvedReferences.set(type, new Set(ids));\n  }\n\n  public markReferenceAsResolved(name: ReferenceTypeName, value: string): void {\n    const type = ReferenceTypeIds[name];\n    const ref = this._unresolvedReferences.deleteReference(type, value);\n    this._resolvedReferences.addReference(type, ref);\n  }\n\n  public markAllReferencesAsResolved(name: ReferenceTypeName): void {\n    const type = ReferenceTypeIds[name];\n    this._unresolvedReferences.delete(type);\n  }\n\n  public hasUnresolvedReference(name: ReferenceTypeName): boolean {\n    const type = ReferenceTypeIds[name];\n    return this._unresolvedReferences.has(type);\n  }\n\n  /**\n   * The node's file path, used to compute {@link Node#filePath}.\n   */\n  private get _filePath(): string[] {\n    if (!this.parent) { return [this.fileName]; }\n    return this.parent._filePath.concat(this.fileName);\n  }\n\n  /**\n   * The node's file path.\n   */\n  public get filePath(): string[] {\n    if (!this.parent) { return []; }\n    return this.parent._filePath;\n  }\n\n  /**\n   * The node's id, used to compute {@link Node#nodeId}.\n   */\n  private get _nodeId(): { id: string; separator: '/' | '.' } {\n    if (this.specialId) {\n      return {\n        id: this.specialId,\n        separator: this.specialId.match(/\\.RESOURCES\\/?/) ? '/' : '.',\n      };\n    }\n\n    if (!this.parent) {\n      return {\n        id: this.idName,\n        separator: '.',\n      };\n    }\n\n    const { separator, id } = this.parent._nodeId;\n\n    if (this._parentResolvesMetadata) {\n      return { separator, id };\n    }\n\n    return {\n      separator: this.idName === 'RESOURCES' ? '/' : separator,\n      id: `${id}${separator}${this.idName}`,\n    };\n  }\n\n  /**\n   * The node's id.\n   */\n  public get nodeId(): string {\n    return this._nodeId.id;\n  }\n\n  /**\n   * The node's type definition if given.\n   */\n  public get typeDefinition(): number | string | undefined {\n    return this.references.getSingle(ReferenceTypeIds.HasTypeDefinition);\n  }\n\n  /**\n   * The node's modellingRule if given.\n   * @type {?number}\n   */\n  public get modellingRule(): number | string | undefined {\n    return this.references.getSingle(ReferenceTypeIds.HasModellingRule);\n  }\n\n  /**\n   * Returns `true` if the node has the given type definition.\n   * @param typeDefName - The type definition to check.\n   * @return If the node has the given type definition.\n   */\n  public hasTypeDefinition(typeDefName: number | string): boolean {\n    const def = this.typeDefinition;\n\n    return def ? def === typeDefName : false;\n  }\n\n  /**\n   * `true` at the moment.\n   */\n  public get hasUnresolvedMetadata(): boolean {\n    return true;\n    /* FIXME: Once plugin mapping is implemented\n    const value = !this._parentResolvesMetadata && (Boolean(this._unresolved.size) ||\n      Boolean(this._unresolvedReferences.size) || this.specialId);\n\n    // FIXME: If debug / test\n    if (!value && Object.keys(this.metadata).length > 0) {\n      throw new Error(`#hasUnresolvedMetadata did return invalid result ${\n        value\n      } for ${\n        JSON.stringify(Object.assign(this, {parent: undefined, value: undefined }), null, '  ')\n      }`);\n    } else if (value && Object.keys(this.metadata).length === 0) {\n      throw new Error('#metadata did return invalid result');\n    }\n\n    return value; */\n  }\n\n  /**\n   * The metadata to store in the node's definition file.\n   * @type {Object}\n   */\n  public get metadata(): NodeDefinition {\n    if (this._parentResolvesMetadata) { return {}; }\n\n    const meta: Partial<NodeDefinition> = {};\n\n    if (this.specialId) {\n      meta.nodeId = this.specialId;\n    }\n\n    if (this.isVariableNode()) {\n      meta.dataType = this.value.dataType.key;\n      meta.arrayType = this.value.arrayType.key;\n    } else {\n      meta.nodeClass = this.nodeClass.key;\n    }\n\n    meta.references = sortReferences(this.references.toJSON());\n\n    /* FIXME: Once plugin mapping is implemented\n    for (const unresolved of this._unresolved) {\n      let value = this[unresolved];\n\n      if (unresolved === 'dataType') {\n        value = this.value.dataType ? this.value.dataType.key : 'UNKNOWN';\n      } else if (unresolved === 'arrayType') {\n        value = this.value.arrayType ? this.value.arrayType.key : 'UNKNOWN';\n      }\n\n      meta[unresolved] = value;\n    }\n\n\n    if (this._unresolvedReferences.size) {\n      meta.references = sortReferences(this._unresolvedReferences.toJSON());\n    }\n    */\n\n    return meta;\n  }\n\n  // Manipulation\n\n  /**\n   * Creates a new child node.\n   * @param {Object} options The options to use.\n   * @param {string} options.extension The extension to append to the node's name.\n   */\n  public createChild({ extension }: { extension: string }): Node {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const node: Node = new (this.constructor as any)({\n      name: this.idName,\n      parent: this,\n      nodeClass: this.nodeClass,\n    });\n\n    node.fileName = `${this.fileName}${extension}`;\n\n    node.references = this.references;\n    node._parentResolvesMetadata = true;\n\n    return node;\n  }\n\n  // Convenience getters\n\n  /**\n   * The node's data type.\n   */\n  public get dataType(): ItemOf<typeof DataType> {\n    if (!this.isVariableNode()) { throw new TypeError('Not a variable node'); }\n\n    return this.value.dataType;\n  }\n\n  /**\n   * The node's array type.\n   */\n  public get arrayType(): ItemOf<typeof VariantArrayType> {\n    if (!this.isVariableNode()) { throw new TypeError('Not a variable node'); }\n\n    return this.value.arrayType;\n  }\n\n  /**\n   * If the node is a variable.\n   * @deprecated Use TypeScript compatible {@link Node#isVariableNode} instead.\n   */\n  public get isVariable(): boolean {\n    return this.nodeClass === NodeClass.Variable;\n  }\n\n  public isVariableNode(): this is WithValue {\n    return this.isVariable;\n  }\n\n  // FIXME: Move to display / script transformers\n\n  /**\n   * If the node is an object display.\n   */\n  public get isDisplay(): boolean {\n    return this.hasTypeDefinition('VariableTypes.ATVISE.Display');\n  }\n\n  /**\n   * If the node is a serverside script.\n   */\n  public get isScript(): boolean {\n    return this.hasTypeDefinition('VariableTypes.ATVISE.ScriptCode');\n  }\n\n  /**\n   * If the node is a quickdynamic.\n   */\n  public get isQuickDynamic(): boolean {\n    return this.hasTypeDefinition('VariableTypes.ATVISE.QuickDynamic');\n  }\n\n}\n\n/**\n * A node during a *pull*.\n */\nexport abstract class ServerNode extends Node {\n\n  /**\n   * The node's name.\n   */\n  public get name(): string {\n    return this.fileName;\n  }\n\n  /**\n   * Renames a node.\n   * @param name The name to set.\n   */\n  public renameTo(name: string): void {\n    this.fileName = name;\n  }\n\n}\n\n/**\n * A node during a *push*.\n */\nexport abstract class SourceNode extends Node {\n\n  /**\n   * The node's name.\n   */\n  public get name(): string {\n    return this.idName;\n  }\n\n  /**\n   * Renames a node.\n   * @param name The name to set.\n   */\n  public renameTo(name: string): void {\n    this.idName = name;\n  }\n\n}\n"],"file":"Node.js"}