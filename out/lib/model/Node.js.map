{"version":3,"sources":["../../../src/lib/model/Node.js"],"names":["ReferenceTypeIds","Object","assign","toParent","RealReferenceTypeIds","ReferenceTypeNames","ReferenceMap","Map","addReference","type","nodeId","set","get","add","Set","deleteReference","ref","delete","size","Error","toJSON","reduce","result","key","value","Node","constructor","name","parent","nodeClass","fileName","idName","_unresolved","_resolved","references","_resolvedReferences","_unresolvedReferences","_parentResolvesMetadata","parentResolvesMetadata","markAsResolved","isResolved","has","id","setReferences","ids","markReferenceAsResolved","markAllReferencesAsResolved","hasUnresolvedReference","_filePath","concat","filePath","_nodeId","specialId","separator","match","typeDefinition","refs","HasTypeDefinition","undefined","hasTypeDefinition","typeDefName","def","hasUnresolvedMetadata","metadata","meta","specialName","NodeClass","Variable","dataType","arrayType","createChild","extension","node","setPrototypeOf","prototype","isVariable","isDisplay","isScript","isQuickDynamic","ServerNode","renameTo","SourceNode"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AAEA;;;;AAIO,MAAMA,gBAAgB,GAAGC,MAAM,CAACC,MAAP,CAAc;AAC5CC,EAAAA,QAAQ,EAAE,CAAC;AADiC,CAAd,EAE7BC,gCAF6B,CAAzB;AAIP;;;;;;AAIO,MAAMC,kBAAkB,GAAG,qBAAQL,gBAAR,CAA3B;AAEP;;;;;;AAGA,MAAMM,YAAN,SAA2BC,GAA3B,CAA+B;AAE7B;;;;;AAKAC,EAAAA,YAAY,CAACC,IAAD,EAAOC,MAAP,EAAe;AACzB,UAAMC,GAAG,GAAG,KAAKC,GAAL,CAASH,IAAT,CAAZ;;AACA,QAAIE,GAAJ,EAAS;AACPA,MAAAA,GAAG,CAACE,GAAJ,CAAQH,MAAR;AACD,KAFD,MAEO;AACL,WAAKC,GAAL,CAASF,IAAT,EAAe,IAAIK,GAAJ,CAAQ,CAACJ,MAAD,CAAR,CAAf;AACD;AACF;AAED;;;;;;;AAKAK,EAAAA,eAAe,CAACN,IAAD,EAAOC,MAAP,EAAe;AAC5B,UAAMC,GAAG,GAAG,KAAKC,GAAL,CAASH,IAAT,CAAZ;;AACA,QAAIE,GAAJ,EAAS;AACP,YAAMK,GAAG,GAAGL,GAAG,CAACM,MAAJ,CAAWP,MAAX,CAAZ;;AAEA,UAAIM,GAAJ,EAAS;AACP,YAAIL,GAAG,CAACO,IAAJ,KAAa,CAAjB,EAAoB;AAClB,eAAKD,MAAL,CAAYR,IAAZ;AACD;;AACD,eAAOO,GAAP;AACD;AACF;;AAED,UAAM,IAAIG,KAAJ,CAAW,MAAKd,kBAAkB,CAACI,IAAD,CAAlB,IAA4BA,IAAK,iBAAgBC,MAAO,EAAxE,CAAN;AACD;AAED;;;;;;AAIAU,EAAAA,MAAM,GAAG;AACP,WAAO,CAAC,GAAG,IAAJ,EACJC,MADI,CACG,CAACC,MAAD,EAAS,CAACC,GAAD,EAAMC,KAAN,CAAT,KAA0BvB,MAAM,CAACC,MAAP,CAAcoB,MAAd,EAAsB;AACtD,OAACjB,kBAAkB,CAACkB,GAAD,CAAlB,IAA2BA,GAA5B,GAAkC,CAAC,GAAGC,KAAJ;AADoB,KAAtB,CAD7B,EAGD,EAHC,CAAP;AAID;;AA9C4B;AAkD/B;;;;;AAGe,MAAMC,IAAN,CAAW;AAExB;;;;;;;AAOAC,EAAAA,WAAW,CAAC;AAAEC,IAAAA,IAAF;AAAQC,IAAAA,MAAR;AAAgBC,IAAAA;AAAS;;AAAzB,GAAD,EAAuD;AAChE;AACA,SAAKC,QAAL,GAAgBH,IAAhB;AACA;;AACA,SAAKI,MAAL,GAAcJ,IAAd;AACA;;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA;;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AAEA;;;;;AAIA,SAAKG,WAAL,GAAmB,IAAIlB,GAAJ,CAAQ,CACzB,WADyB,EAEzB;AACA,cAHyB,EAIzB,WAJyB,CAAR,CAAnB;AAMA;;;;;AAIA,SAAKmB,SAAL,GAAiB,IAAInB,GAAJ,EAAjB;AAEA;;;;;AAIA,SAAKoB,UAAL,GAAkB,IAAI5B,YAAJ,EAAlB;AACA;;;;;AAIA,SAAK6B,mBAAL,GAA2B,IAAI7B,YAAJ,EAA3B;AACA;;;;;AAIA,SAAK8B,qBAAL,GAA6B,IAAI9B,YAAJ,EAA7B;AAEA;;;;;AAIA,SAAK+B,uBAAL,GAA+B,KAA/B;AACD;AAED;;;;;;AAIA,MAAIC,sBAAJ,GAA6B;AAC3B,WAAO,KAAKD,uBAAZ;AACD;;AAEDE,EAAAA,cAAc,CAAChB,GAAD,EAAM;AAClB,UAAMC,KAAK,GAAG,KAAKQ,WAAL,CAAiBf,MAAjB,CAAwBM,GAAxB,CAAd,CADkB,CAGlB;;;AACA,QAAIC,KAAK,KAAK,KAAd,EAAqB;AACnB,YAAM,IAAIL,KAAJ,CAAW,IAAGI,GAAI,uBAAlB,CAAN;AACD;;AAED,SAAKU,SAAL,CAAepB,GAAf,CAAmBU,GAAnB;AACD;;AAEDiB,EAAAA,UAAU,CAACjB,GAAD,EAAM;AACd,WAAO,KAAKU,SAAL,CAAeQ,GAAf,CAAmBlB,GAAnB,CAAP;AACD;AAED;;;;;;;AAKAf,EAAAA,YAAY,CAACC,IAAD,EAAOiC,EAAP,EAAW;AACrB,SAAKR,UAAL,CAAgB1B,YAAhB,CAA6BC,IAA7B,EAAmCiC,EAAnC;;AACA,SAAKN,qBAAL,CAA2B5B,YAA3B,CAAwCC,IAAxC,EAA8CiC,EAA9C;AACD;;AAEDC,EAAAA,aAAa,CAAClC,IAAD,EAAOmC,GAAP,EAAY;AACvB,SAAKV,UAAL,CAAgBvB,GAAhB,CAAoBF,IAApB,EAA0B,IAAIK,GAAJ,CAAQ8B,GAAR,CAA1B;;AACA,SAAKR,qBAAL,CAA2BzB,GAA3B,CAA+BF,IAA/B,EAAqC,IAAIK,GAAJ,CAAQ8B,GAAR,CAArC;AACD;;AAEDC,EAAAA,uBAAuB,CAAClB,IAAD,EAAOH,KAAP,EAAc;AACnC,UAAMf,IAAI,GAAGT,gBAAgB,CAAC2B,IAAD,CAA7B;;AACA,UAAMX,GAAG,GAAG,KAAKoB,qBAAL,CAA2BrB,eAA3B,CAA2CN,IAA3C,EAAiDe,KAAjD,CAAZ;;AACA,SAAKW,mBAAL,CAAyB3B,YAAzB,CAAsCC,IAAtC,EAA4CO,GAA5C;AACD;;AAED8B,EAAAA,2BAA2B,CAACnB,IAAD,EAAO;AAChC,UAAMlB,IAAI,GAAGT,gBAAgB,CAAC2B,IAAD,CAA7B;;AACA,SAAKS,qBAAL,CAA2BnB,MAA3B,CAAkCR,IAAlC;AACD;;AAEDsC,EAAAA,sBAAsB,CAACpB,IAAD,EAAO;AAC3B,UAAMlB,IAAI,GAAGT,gBAAgB,CAAC2B,IAAD,CAA7B;AACA,WAAO,KAAKS,qBAAL,CAA2BK,GAA3B,CAA+BhC,IAA/B,CAAP;AACD;AAED;;;;;AAGA,MAAIuC,SAAJ,GAAgB;AACd,QAAI,CAAC,KAAKpB,MAAV,EAAkB;AAAE,aAAO,CAAC,KAAKE,QAAN,CAAP;AAAyB;;AAC7C,WAAO,KAAKF,MAAL,CAAYoB,SAAZ,CAAsBC,MAAtB,CAA6B,KAAKnB,QAAlC,CAAP;AACD;AAED;;;;;;AAIA,MAAIoB,QAAJ,GAAe;AACb,QAAI,CAAC,KAAKtB,MAAV,EAAkB;AAAE,aAAO,EAAP;AAAY;;AAChC,WAAO,KAAKA,MAAL,CAAYoB,SAAnB;AACD;AAED;;;;;;AAIA,MAAIG,OAAJ,GAAc;AACZ,QAAI,KAAKC,SAAT,EAAoB;AAClB,aAAO;AACLV,QAAAA,EAAE,EAAE,KAAKU,SADJ;AAELC,QAAAA,SAAS,EAAE,KAAKD,SAAL,CAAeE,KAAf,CAAqB,gBAArB,IAAyC,GAAzC,GAA+C;AAFrD,OAAP;AAID;;AAED,QAAI,CAAC,KAAK1B,MAAV,EAAkB;AAChB,aAAO;AACLc,QAAAA,EAAE,EAAE,KAAKX,MADJ;AAELsB,QAAAA,SAAS,EAAE;AAFN,OAAP;AAID;;AAED,UAAM;AAAEA,MAAAA,SAAF;AAAaX,MAAAA;AAAb,QAAoB,KAAKd,MAAL,CAAYuB,OAAtC;;AAEA,QAAI,KAAKd,uBAAT,EAAkC;AAChC,aAAO;AAAEgB,QAAAA,SAAF;AAAaX,QAAAA;AAAb,OAAP;AACD;;AAED,WAAO;AACLW,MAAAA,SAAS,EAAE,KAAKtB,MAAL,KAAgB,WAAhB,GAA8B,GAA9B,GAAoCsB,SAD1C;AAELX,MAAAA,EAAE,EAAG,GAAEA,EAAG,GAAEW,SAAU,GAAE,KAAKtB,MAAO;AAF/B,KAAP;AAID;AAED;;;;;;AAIA,MAAIrB,MAAJ,GAAa;AACX,WAAO,KAAKyC,OAAL,CAAaT,EAApB;AACD;AAED;;;;;;AAIA,MAAIa,cAAJ,GAAqB;AACnB,UAAMC,IAAI,GAAG,KAAKtB,UAAL,CAAgBtB,GAAhB,CAAoBZ,gBAAgB,CAACyD,iBAArC,CAAb;AACA,WAAOD,IAAI,GAAG,CAAC,GAAGA,IAAJ,EAAU,CAAV,CAAH,GAAkBE,SAA7B;AACD;AAED;;;;;;;AAKAC,EAAAA,iBAAiB,CAACC,WAAD,EAAc;AAC7B,UAAMC,GAAG,GAAG,KAAKN,cAAjB;AAEA,WAAOM,GAAG,GAAGA,GAAG,KAAKD,WAAX,GAAyB,KAAnC;AACD;AAED;;;;;;AAIA,MAAIE,qBAAJ,GAA4B;AAC1B,WAAO,IAAP;AACA;;;;;;;;;;;;;;AAgBD;AAED;;;;;;AAIA,MAAIC,QAAJ,GAAe;AACb,QAAI,KAAK1B,uBAAT,EAAkC;AAAE,aAAO,EAAP;AAAY;;AAEhD,UAAM2B,IAAI,GAAG,EAAb;;AAEA,QAAI,KAAKZ,SAAT,EAAoB;AAClBY,MAAAA,IAAI,CAACtD,MAAL,GAAc,KAAK0C,SAAnB;AACD;;AAED,QAAI,KAAKa,WAAT,EAAsB;AACpBD,MAAAA,IAAI,CAACrC,IAAL,GAAY,KAAKsC,WAAjB;AACD;;AAED,QAAI,KAAKpC,SAAL,KAAmBqC,qBAAUC,QAAjC,EAA2C;AACzCH,MAAAA,IAAI,CAACI,QAAL,GAAgB,KAAK5C,KAAL,CAAW4C,QAAX,CAAoB7C,GAApC;AACAyC,MAAAA,IAAI,CAACK,SAAL,GAAiB,KAAK7C,KAAL,CAAW6C,SAAX,CAAqB9C,GAAtC;AACD,KAHD,MAGO;AACLyC,MAAAA,IAAI,CAACnC,SAAL,GAAiB,KAAKA,SAAL,CAAeN,GAAhC;AACD;;AAEDyC,IAAAA,IAAI,CAAC9B,UAAL,GAAkB,6BAAe,KAAKA,UAAL,CAAgBd,MAAhB,EAAf,CAAlB;AAEA;;;;;;;;;;;;;;;AAmBA,WAAO4C,IAAP;AACD,GAlQuB,CAoQxB;;AAEA;;;;;;;AAKAM,EAAAA,WAAW,CAAC;AAAEC,IAAAA;AAAF,GAAD,EAAgB;AACzB,UAAMC,IAAI,GAAG,IAAI/C,IAAJ,CAAS;AACpBE,MAAAA,IAAI,EAAE,KAAKI,MADS;AAEpBH,MAAAA,MAAM,EAAE,IAFY;AAGpBC,MAAAA,SAAS,EAAE,KAAKA;AAHI,KAAT,CAAb;AAMA5B,IAAAA,MAAM,CAACwE,cAAP,CAAsBD,IAAtB,EAA4B,KAAK9C,WAAL,CAAiBgD,SAA7C;AAEAF,IAAAA,IAAI,CAAC1C,QAAL,GAAiB,GAAE,KAAKA,QAAS,GAAEyC,SAAU,EAA7C;AAEAC,IAAAA,IAAI,CAACtC,UAAL,GAAkB,KAAKA,UAAvB;AACAsC,IAAAA,IAAI,CAACnC,uBAAL,GAA+B,IAA/B;AAEA,WAAOmC,IAAP;AACD,GA1RuB,CA4RxB;;AAEA;;;;;;AAIA,MAAIJ,QAAJ,GAAe;AACb,WAAO,KAAK5C,KAAL,CAAW4C,QAAlB;AACD;AAED;;;;;;AAIA,MAAIC,SAAJ,GAAgB;AACd,WAAO,KAAK7C,KAAL,CAAW6C,SAAlB;AACD;AAED;;;;;;AAIA,MAAIM,UAAJ,GAAiB;AACf,WAAO,KAAK9C,SAAL,KAAmBqC,qBAAUC,QAApC;AACD,GApTuB,CAsTxB;;AAEA;;;;;;AAIA,MAAIS,SAAJ,GAAgB;AACd,WAAO,KAAKjB,iBAAL,CAAuB,8BAAvB,CAAP;AACD;AAED;;;;;;AAIA,MAAIkB,QAAJ,GAAe;AACb,WAAO,KAAKlB,iBAAL,CAAuB,iCAAvB,CAAP;AACD;AAED;;;;;;AAIA,MAAImB,cAAJ,GAAqB;AACnB,WAAO,KAAKnB,iBAAL,CAAuB,mCAAvB,CAAP;AACD;;AA9UuB;AAkV1B;;;;;;;AAGO,MAAMoB,UAAN,SAAyBtD,IAAzB,CAA8B;AAEnC;;;;AAIA,MAAIE,IAAJ,GAAW;AACT,WAAO,KAAKG,QAAZ;AACD;AAED;;;;;;AAIAkD,EAAAA,QAAQ,CAACrD,IAAD,EAAO;AACb,SAAKG,QAAL,GAAgBH,IAAhB;AACD;;AAhBkC;AAoBrC;;;;;;;AAGO,MAAMsD,UAAN,SAAyBxD,IAAzB,CAA8B;AAEnC;;;;AAIA,MAAIE,IAAJ,GAAW;AACT,WAAO,KAAKI,MAAZ;AACD;AAED;;;;;;AAIAiD,EAAAA,QAAQ,CAACrD,IAAD,EAAO;AACb,SAAKI,MAAL,GAAcJ,IAAd;AACD;;AAhBkC","sourcesContent":["import { ReferenceTypeIds as RealReferenceTypeIds } from 'node-opcua/lib/opcua_node_ids';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport { reverse } from '../helpers/Object';\nimport { sortReferences } from '../helpers/mapping';\n\n/**\n * References type ids.\n * @type {Map<string, number>}\n */\nexport const ReferenceTypeIds = Object.assign({\n  toParent: -1,\n}, RealReferenceTypeIds);\n\n/**\n * Names for references.\n * @type {Map<number, string>}\n */\nexport const ReferenceTypeNames = reverse(ReferenceTypeIds);\n\n/**\n * A map specialized for holding references.\n */\nclass ReferenceMap extends Map {\n\n  /**\n   * Adds a new reference.\n   * @param {number} type The reference id.\n   * @param {string} nodeId The reference target node's id.\n   */\n  addReference(type, nodeId) {\n    const set = this.get(type);\n    if (set) {\n      set.add(nodeId);\n    } else {\n      this.set(type, new Set([nodeId]));\n    }\n  }\n\n  /**\n   * Removes the given reference.\n   * @param {number} type The reference id.\n   * @param {string} nodeId The reference target node's id.\n   */\n  deleteReference(type, nodeId) {\n    const set = this.get(type);\n    if (set) {\n      const ref = set.delete(nodeId);\n\n      if (ref) {\n        if (set.size === 0) {\n          this.delete(type);\n        }\n        return ref;\n      }\n    }\n\n    throw new Error(`No ${ReferenceTypeNames[type] || type} reference to ${nodeId}`);\n  }\n\n  /**\n   * Returns a plain object of refernces.\n   * @type {Object}\n   */\n  toJSON() {\n    return [...this]\n      .reduce((result, [key, value]) => Object.assign(result, {\n        [ReferenceTypeNames[key] || key]: [...value],\n      }), {});\n  }\n\n}\n\n/**\n * The main model class.\n */\nexport default class Node {\n\n  /**\n   * Creates a new node.\n   * @param {Object} options The options to use.\n   * @param {string} options.name The node's name.\n   * @param {Node} options.parent The node's parent node.\n   * @param {node-opcua~NodeClass} options.nodeClass The node's class.\n   */\n  constructor({ name, parent, nodeClass/* , referenceToParent */ }) {\n    /** The node's name when stored to a file. {@type string} */\n    this.fileName = name;\n    /** The node's name when written to the server. {@type string} */\n    this.idName = name;\n    /** The node's parent node. {@type Node} */\n    this.parent = parent;\n    /** The node's class. {@type node-opcua~NodeClass} */\n    this.nodeClass = nodeClass;\n\n    /**\n     * A set of unresolved properties.\n     * @type {Set<string>}\n     */\n    this._unresolved = new Set([\n      'nodeClass',\n      // Only for variables\n      'dataType',\n      'arrayType',\n    ]);\n    /**\n     * A set of resolved properties.\n     * @type {Set<string>}\n     */\n    this._resolved = new Set();\n\n    /**\n     * The node's refernces.\n     * @type {ReferenceMap}\n     */\n    this.references = new ReferenceMap();\n    /**\n     * The node's unresolved refernces.\n     * @type {ReferenceMap}\n     */\n    this._resolvedReferences = new ReferenceMap();\n    /**\n     * The node's resolved refernces.\n     * @type {ReferenceMap}\n     */\n    this._unresolvedReferences = new ReferenceMap();\n\n    /**\n     * If the parent node resolves metadata.\n     * @type {boolean}\n     */\n    this._parentResolvesMetadata = false;\n  }\n\n  /**\n   * If the parent resolves metadata (for example: split transformer source files).\n   * @type {boolean}\n   */\n  get parentResolvesMetadata() {\n    return this._parentResolvesMetadata;\n  }\n\n  markAsResolved(key) {\n    const value = this._unresolved.delete(key);\n\n    // FIXME: Only test if debug / test\n    if (value === false) {\n      throw new Error(`'${key}' is already resolved`);\n    }\n\n    this._resolved.add(key);\n  }\n\n  isResolved(key) {\n    return this._resolved.has(key);\n  }\n\n  /**\n   * Adds a new reference.\n   * @param {number} type The reference type's id.\n   * @param {string} id The reference target node's id.\n   */\n  addReference(type, id) {\n    this.references.addReference(type, id);\n    this._unresolvedReferences.addReference(type, id);\n  }\n\n  setReferences(type, ids) {\n    this.references.set(type, new Set(ids));\n    this._unresolvedReferences.set(type, new Set(ids));\n  }\n\n  markReferenceAsResolved(name, value) {\n    const type = ReferenceTypeIds[name];\n    const ref = this._unresolvedReferences.deleteReference(type, value);\n    this._resolvedReferences.addReference(type, ref);\n  }\n\n  markAllReferencesAsResolved(name) {\n    const type = ReferenceTypeIds[name];\n    this._unresolvedReferences.delete(type);\n  }\n\n  hasUnresolvedReference(name) {\n    const type = ReferenceTypeIds[name];\n    return this._unresolvedReferences.has(type);\n  }\n\n  /**\n   * The node's file path, used to compute {@link Node#filePath}.\n   */\n  get _filePath() {\n    if (!this.parent) { return [this.fileName]; }\n    return this.parent._filePath.concat(this.fileName);\n  }\n\n  /**\n   * The node's file path.\n   * @type {string[]}\n   */\n  get filePath() {\n    if (!this.parent) { return []; }\n    return this.parent._filePath;\n  }\n\n  /**\n   * The node's id, used to compute {@link Node#nodeId}.\n   * @type {string}\n   */\n  get _nodeId() {\n    if (this.specialId) {\n      return {\n        id: this.specialId,\n        separator: this.specialId.match(/\\.RESOURCES\\/?/) ? '/' : '.',\n      };\n    }\n\n    if (!this.parent) {\n      return {\n        id: this.idName,\n        separator: '.',\n      };\n    }\n\n    const { separator, id } = this.parent._nodeId;\n\n    if (this._parentResolvesMetadata) {\n      return { separator, id };\n    }\n\n    return {\n      separator: this.idName === 'RESOURCES' ? '/' : separator,\n      id: `${id}${separator}${this.idName}`,\n    };\n  }\n\n  /**\n   * The node's id.\n   * @type {string}\n   */\n  get nodeId() {\n    return this._nodeId.id;\n  }\n\n  /**\n   * The node's type definition if given.\n   * @type {?number}\n   */\n  get typeDefinition() {\n    const refs = this.references.get(ReferenceTypeIds.HasTypeDefinition);\n    return refs ? [...refs][0] : undefined;\n  }\n\n  /**\n   * Returns `true` if the node has the given type definition.\n   * @param {string} typeDefName The type definition to check.\n   * @return {boolean} If the node has the given type definition.\n   */\n  hasTypeDefinition(typeDefName) {\n    const def = this.typeDefinition;\n\n    return def ? def === typeDefName : false;\n  }\n\n  /**\n   * `true` at the moment.\n   * @type {boolean}\n   */\n  get hasUnresolvedMetadata() {\n    return true;\n    /* FIXME: Once plugin mapping is implemented\n    const value = !this._parentResolvesMetadata && (Boolean(this._unresolved.size) ||\n      Boolean(this._unresolvedReferences.size) || this.specialId);\n\n    // FIXME: If debug / test\n    if (!value && Object.keys(this.metadata).length > 0) {\n      throw new Error(`#hasUnresolvedMetadata did return invalid result ${\n        value\n      } for ${\n        JSON.stringify(Object.assign(this, {parent: undefined, value: undefined }), null, '  ')\n      }`);\n    } else if (value && Object.keys(this.metadata).length === 0) {\n      throw new Error('#metadata did return invalid result');\n    }\n\n    return value; */\n  }\n\n  /**\n   * The metadata to store in the node's definition file.\n   * @type {Object}\n   */\n  get metadata() {\n    if (this._parentResolvesMetadata) { return {}; }\n\n    const meta = {};\n\n    if (this.specialId) {\n      meta.nodeId = this.specialId;\n    }\n\n    if (this.specialName) {\n      meta.name = this.specialName;\n    }\n\n    if (this.nodeClass === NodeClass.Variable) {\n      meta.dataType = this.value.dataType.key;\n      meta.arrayType = this.value.arrayType.key;\n    } else {\n      meta.nodeClass = this.nodeClass.key;\n    }\n\n    meta.references = sortReferences(this.references.toJSON());\n\n    /* FIXME: Once plugin mapping is implemented\n    for (const unresolved of this._unresolved) {\n      let value = this[unresolved];\n\n      if (unresolved === 'dataType') {\n        value = this.value.dataType ? this.value.dataType.key : 'UNKNOWN';\n      } else if (unresolved === 'arrayType') {\n        value = this.value.arrayType ? this.value.arrayType.key : 'UNKNOWN';\n      }\n\n      meta[unresolved] = value;\n    }\n\n\n    if (this._unresolvedReferences.size) {\n      meta.references = sortReferences(this._unresolvedReferences.toJSON());\n    }\n    */\n\n    return meta;\n  }\n\n  // Manipulation\n\n  /**\n   * Creates a new child node.\n   * @param {Object} options The options to use.\n   * @param {string} options.extension The extension to append to the node's name.\n   */\n  createChild({ extension }) {\n    const node = new Node({\n      name: this.idName,\n      parent: this,\n      nodeClass: this.nodeClass,\n    });\n\n    Object.setPrototypeOf(node, this.constructor.prototype);\n\n    node.fileName = `${this.fileName}${extension}`;\n\n    node.references = this.references;\n    node._parentResolvesMetadata = true;\n\n    return node;\n  }\n\n  // Convenience getters\n\n  /**\n   * The node's data type.\n   * @type {node-opcua~DataType}\n   */\n  get dataType() {\n    return this.value.dataType;\n  }\n\n  /**\n   * The node's array type.\n   * @type {node-opcua~VariantArrayType}\n   */\n  get arrayType() {\n    return this.value.arrayType;\n  }\n\n  /**\n   * If the node is a variable.\n   * @type {boolean}\n   */\n  get isVariable() {\n    return this.nodeClass === NodeClass.Variable;\n  }\n\n  // FIXME: Move to display / script transformers\n\n  /**\n   * If the node is an object display.\n   * @type {boolean}\n   */\n  get isDisplay() {\n    return this.hasTypeDefinition('VariableTypes.ATVISE.Display');\n  }\n\n  /**\n   * If the node is a serverside script.\n   * @type {boolean}\n   */\n  get isScript() {\n    return this.hasTypeDefinition('VariableTypes.ATVISE.ScriptCode');\n  }\n\n  /**\n   * If the node is a quickdynamic.\n   * @type {boolean}\n   */\n  get isQuickDynamic() {\n    return this.hasTypeDefinition('VariableTypes.ATVISE.QuickDynamic');\n  }\n\n}\n\n/**\n * A node during a *pull*.\n */\nexport class ServerNode extends Node {\n\n  /**\n   * The node's name.\n   * @type {string}\n   */\n  get name() {\n    return this.fileName;\n  }\n\n  /**\n   * Renames a node.\n   * @param {string} name The name to set.\n   */\n  renameTo(name) {\n    this.fileName = name;\n  }\n\n}\n\n/**\n * A node during a *push*.\n */\nexport class SourceNode extends Node {\n\n  /**\n   * The node's name.\n   * @type {string}\n   */\n  get name() {\n    return this.idName;\n  }\n\n  /**\n   * Renames a node.\n   * @param {string} name The name to set.\n   */\n  renameTo(name) {\n    this.idName = name;\n  }\n\n}\n"],"file":"Node.js"}