{"version":3,"sources":["../../../src/lib/model/Node.js"],"names":["ReferenceTypeIds","Object","assign","toParent","ReferenceTypeNames","ReferenceMap","Map","addReference","type","nodeId","set","get","add","Set","deleteReference","ref","delete","size","Error","toJSON","reduce","result","key","value","Node","constructor","name","parent","nodeClass","fileName","idName","_unresolved","_resolved","references","_resolvedReferences","_unresolvedReferences","_parentResolvesMetadata","parentResolvesMetadata","markAsResolved","isResolved","has","id","setReferences","ids","markReferenceAsResolved","markAllReferencesAsResolved","hasUnresolvedReference","_filePath","concat","filePath","_nodeId","specialId","separator","match","typeDefinition","refs","HasTypeDefinition","undefined","hasTypeDefinition","typeDefName","def","hasUnresolvedMetadata","metadata","meta","specialName","Variable","dataType","arrayType","createChild","extension","node","setPrototypeOf","prototype","isVariable","isDisplay","isScript","isQuickDynamic","ServerNode","renameTo","SourceNode"],"mappings":"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","file":"Node.js","sourcesContent":["import { ReferenceTypeIds as RealReferenceTypeIds } from 'node-opcua/lib/opcua_node_ids';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport { reverse } from '../helpers/Object';\nimport { sortReferences } from '../helpers/mapping';\n\n/**\n * References type ids.\n * @type {Map<string, number>}\n */\nexport const ReferenceTypeIds = Object.assign({\n  toParent: -1,\n}, RealReferenceTypeIds);\n\n/**\n * Names for references.\n * @type {Map<number, string>}\n */\nexport const ReferenceTypeNames = reverse(ReferenceTypeIds);\n\n/**\n * A map specialized for holding references.\n */\nclass ReferenceMap extends Map {\n\n  /**\n   * Adds a new reference.\n   * @param {number} type The reference id.\n   * @param {string} nodeId The reference target node's id.\n   */\n  addReference(type, nodeId) {\n    const set = this.get(type);\n    if (set) {\n      set.add(nodeId);\n    } else {\n      this.set(type, new Set([nodeId]));\n    }\n  }\n\n  /**\n   * Removes the given reference.\n   * @param {number} type The reference id.\n   * @param {string} nodeId The reference target node's id.\n   */\n  deleteReference(type, nodeId) {\n    const set = this.get(type);\n    if (set) {\n      const ref = set.delete(nodeId);\n\n      if (ref) {\n        if (set.size === 0) {\n          this.delete(type);\n        }\n        return ref;\n      }\n    }\n\n    throw new Error(`No ${ReferenceTypeNames[type] || type} reference to ${nodeId}`);\n  }\n\n  /**\n   * Returns a plain object of refernces.\n   * @type {Object}\n   */\n  toJSON() {\n    return [...this]\n      .reduce((result, [key, value]) => Object.assign(result, {\n        [ReferenceTypeNames[key] || key]: [...value],\n      }), {});\n  }\n\n}\n\n/**\n * The main model class.\n */\nexport default class Node {\n\n  /**\n   * Creates a new node.\n   * @param {Object} options The options to use.\n   * @param {string} options.name The node's name.\n   * @param {Node} options.parent The node's parent node.\n   * @param {node-opcua~NodeClass} options.nodeClass The node's class.\n   */\n  constructor({ name, parent, nodeClass/* , referenceToParent */ }) {\n    /** The node's name when stored to a file. {@type string} */\n    this.fileName = name;\n    /** The node's name when written to the server. {@type string} */\n    this.idName = name;\n    /** The node's parent node. {@type Node} */\n    this.parent = parent;\n    /** The node's class. {@type node-opcua~NodeClass} */\n    this.nodeClass = nodeClass;\n\n    /**\n     * A set of unresolved properties.\n     * @type {Set<string>}\n     */\n    this._unresolved = new Set([\n      'nodeClass',\n      // Only for variables\n      'dataType',\n      'arrayType',\n    ]);\n    /**\n     * A set of resolved properties.\n     * @type {Set<string>}\n     */\n    this._resolved = new Set();\n\n    /**\n     * The node's refernces.\n     * @type {ReferenceMap}\n     */\n    this.references = new ReferenceMap();\n    /**\n     * The node's unresolved refernces.\n     * @type {ReferenceMap}\n     */\n    this._resolvedReferences = new ReferenceMap();\n    /**\n     * The node's resolved refernces.\n     * @type {ReferenceMap}\n     */\n    this._unresolvedReferences = new ReferenceMap();\n\n    /**\n     * If the parent node resolves metadata.\n     * @type {boolean}\n     */\n    this._parentResolvesMetadata = false;\n  }\n\n  /**\n   * If the parent resolves metadata (for example: split transformer source files).\n   * @type {boolean}\n   */\n  get parentResolvesMetadata() {\n    return this._parentResolvesMetadata;\n  }\n\n  markAsResolved(key) {\n    const value = this._unresolved.delete(key);\n\n    // FIXME: Only test if debug / test\n    if (value === false) {\n      throw new Error(`'${key}' is already resolved`);\n    }\n\n    this._resolved.add(key);\n  }\n\n  isResolved(key) {\n    return this._resolved.has(key);\n  }\n\n  /**\n   * Adds a new reference.\n   * @param {number} type The reference type's id.\n   * @param {string} id The reference target node's id.\n   */\n  addReference(type, id) {\n    this.references.addReference(type, id);\n    this._unresolvedReferences.addReference(type, id);\n  }\n\n  setReferences(type, ids) {\n    this.references.set(type, new Set(ids));\n    this._unresolvedReferences.set(type, new Set(ids));\n  }\n\n  markReferenceAsResolved(name, value) {\n    const type = ReferenceTypeIds[name];\n    const ref = this._unresolvedReferences.deleteReference(type, value);\n    this._resolvedReferences.addReference(type, ref);\n  }\n\n  markAllReferencesAsResolved(name) {\n    const type = ReferenceTypeIds[name];\n    this._unresolvedReferences.delete(type);\n  }\n\n  hasUnresolvedReference(name) {\n    const type = ReferenceTypeIds[name];\n    return this._unresolvedReferences.has(type);\n  }\n\n  /**\n   * The node's file path, used to compute {@link Node#filePath}.\n   */\n  get _filePath() {\n    if (!this.parent) { return [this.fileName]; }\n    return this.parent._filePath.concat(this.fileName);\n  }\n\n  /**\n   * The node's file path.\n   * @type {string[]}\n   */\n  get filePath() {\n    if (!this.parent) { return []; }\n    return this.parent._filePath;\n  }\n\n  /**\n   * The node's id, used to compute {@link Node#nodeId}.\n   * @type {string}\n   */\n  get _nodeId() {\n    if (this.specialId) {\n      return {\n        id: this.specialId,\n        separator: this.specialId.match(/\\.RESOURCES\\/?/) ? '/' : '.',\n      };\n    }\n\n    if (!this.parent) {\n      return {\n        id: this.idName,\n        separator: '.',\n      };\n    }\n\n    const { separator, id } = this.parent._nodeId;\n\n    if (this._parentResolvesMetadata) {\n      return { separator, id };\n    }\n\n    return {\n      separator: this.idName === 'RESOURCES' ? '/' : separator,\n      id: `${id}${separator}${this.idName}`,\n    };\n  }\n\n  /**\n   * The node's id.\n   * @type {string}\n   */\n  get nodeId() {\n    return this._nodeId.id;\n  }\n\n  /**\n   * The node's type definition if given.\n   * @type {?number}\n   */\n  get typeDefinition() {\n    const refs = this.references.get(ReferenceTypeIds.HasTypeDefinition);\n    return refs ? [...refs][0] : undefined;\n  }\n\n  /**\n   * Returns `true` if the node has the given type definition.\n   * @param {string} typeDefName The type definition to check.\n   * @return {boolean} If the node has the given type definition.\n   */\n  hasTypeDefinition(typeDefName) {\n    const def = this.typeDefinition;\n\n    return def ? def === typeDefName : false;\n  }\n\n  /**\n   * `true` at the moment.\n   * @type {boolean}\n   */\n  get hasUnresolvedMetadata() {\n    return true;\n    /* FIXME: Once plugin mapping is implemented\n    const value = !this._parentResolvesMetadata && (Boolean(this._unresolved.size) ||\n      Boolean(this._unresolvedReferences.size) || this.specialId);\n\n    // FIXME: If debug / test\n    if (!value && Object.keys(this.metadata).length > 0) {\n      throw new Error(`#hasUnresolvedMetadata did return invalid result ${\n        value\n      } for ${\n        JSON.stringify(Object.assign(this, {parent: undefined, value: undefined }), null, '  ')\n      }`);\n    } else if (value && Object.keys(this.metadata).length === 0) {\n      throw new Error('#metadata did return invalid result');\n    }\n\n    return value; */\n  }\n\n  /**\n   * The metadata to store in the node's definition file.\n   * @type {Object}\n   */\n  get metadata() {\n    if (this._parentResolvesMetadata) { return {}; }\n\n    const meta = {};\n\n    if (this.specialId) {\n      meta.nodeId = this.specialId;\n    }\n\n    if (this.specialName) {\n      meta.name = this.specialName;\n    }\n\n    if (this.nodeClass === NodeClass.Variable) {\n      meta.dataType = this.value.dataType.key;\n      meta.arrayType = this.value.arrayType.key;\n    } else {\n      meta.nodeClass = this.nodeClass.key;\n    }\n\n    meta.references = sortReferences(this.references.toJSON());\n\n    /* FIXME: Once plugin mapping is implemented\n    for (const unresolved of this._unresolved) {\n      let value = this[unresolved];\n\n      if (unresolved === 'dataType') {\n        value = this.value.dataType ? this.value.dataType.key : 'UNKNOWN';\n      } else if (unresolved === 'arrayType') {\n        value = this.value.arrayType ? this.value.arrayType.key : 'UNKNOWN';\n      }\n\n      meta[unresolved] = value;\n    }\n\n\n    if (this._unresolvedReferences.size) {\n      meta.references = sortReferences(this._unresolvedReferences.toJSON());\n    }\n    */\n\n    return meta;\n  }\n\n  // Manipulation\n\n  /**\n   * Creates a new child node.\n   * @param {Object} options The options to use.\n   * @param {string} options.extension The extension to append to the node's name.\n   */\n  createChild({ extension }) {\n    const node = new Node({\n      name: this.idName,\n      parent: this,\n      nodeClass: this.nodeClass,\n    });\n\n    Object.setPrototypeOf(node, this.constructor.prototype);\n\n    node.fileName = `${this.fileName}${extension}`;\n\n    node.references = this.references;\n    node._parentResolvesMetadata = true;\n\n    return node;\n  }\n\n  // Convenience getters\n\n  /**\n   * The node's data type.\n   * @type {node-opcua~DataType}\n   */\n  get dataType() {\n    return this.value.dataType;\n  }\n\n  /**\n   * The node's array type.\n   * @type {node-opcua~VariantArrayType}\n   */\n  get arrayType() {\n    return this.value.arrayType;\n  }\n\n  /**\n   * If the node is a variable.\n   * @type {boolean}\n   */\n  get isVariable() {\n    return this.nodeClass === NodeClass.Variable;\n  }\n\n  // FIXME: Move to display / script transformers\n\n  /**\n   * If the node is an object display.\n   * @type {boolean}\n   */\n  get isDisplay() {\n    return this.hasTypeDefinition('VariableTypes.ATVISE.Display');\n  }\n\n  /**\n   * If the node is a serverside script.\n   * @type {boolean}\n   */\n  get isScript() {\n    return this.hasTypeDefinition('VariableTypes.ATVISE.ScriptCode');\n  }\n\n  /**\n   * If the node is a quickdynamic.\n   * @type {boolean}\n   */\n  get isQuickDynamic() {\n    return this.hasTypeDefinition('VariableTypes.ATVISE.QuickDynamic');\n  }\n\n}\n\n/**\n * A node during a *pull*.\n */\nexport class ServerNode extends Node {\n\n  /**\n   * The node's name.\n   * @type {string}\n   */\n  get name() {\n    return this.fileName;\n  }\n\n  /**\n   * Renames a node.\n   * @param {string} name The name to set.\n   */\n  renameTo(name) {\n    this.fileName = name;\n  }\n\n}\n\n/**\n * A node during a *push*.\n */\nexport class SourceNode extends Node {\n\n  /**\n   * The node's name.\n   * @type {string}\n   */\n  get name() {\n    return this.idName;\n  }\n\n  /**\n   * Renames a node.\n   * @param {string} name The name to set.\n   */\n  renameTo(name) {\n    this.idName = name;\n  }\n\n}\n"]}