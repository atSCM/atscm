{"version":3,"sources":["../../../src/lib/gulp/dest.js"],"names":["renameConfigPath","renameDefaultName","hashaOptions","algorithm","useChecksums","ProjectConfig","vcs","escapePathComponent","a","replace","WriteStream","Writable","constructor","options","path","Error","Object","assign","objectMode","highWaterMark","_isDestroyed","_processed","_written","_base","base","_renameConfig","_loadRenameConfig","then","config","catch","Logger","debug","_idMap","Map","_performWrites","_conflictingIds","Set","_discoveredIdConflicts","info","isDestroyed","_parentHasIdConflict","node","current","parent","has","nodeId","toLowerCase","_outputFile","content","oldSum","hasha","fromFile","Promise","resolve","_writeNode","dirPath","filePath","map","writeOps","rename","id","value","renameTo","_renamed","specialId","name","match","before","pathKey","concat","fileName","join","error","get","existingRename","add","set","hasUnresolvedMetadata","nodeClass","NodeClass","Variable","key","push","JSON","stringify","metadata","noWrite","all","length","_write","enc","callback","err","writeAsync","reject","_writev","nodes","chunk","_destroy","writeRenamefile","dest"],"mappings":"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","sourcesContent":["import { Writable } from 'stream';\nimport { join } from 'path';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport { outputFile, readJson } from 'fs-extra';\nimport hasha from 'hasha';\nimport Logger from 'gulplog';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport { encodeVariant } from '../coding';\n\n/**\n * Relative path to the rename file.\n * @type {string}\n */\nexport const renameConfigPath = './atscm/rename.json';\n\n/**\n * The default name inserted into the rename file.\n * @type {string}\n */\nconst renameDefaultName = 'insert node name';\n\n/**\n * Options to pass to *hasha*.\n * @type {Object}\n */\nconst hashaOptions = { algorithm: 'md5' };\n\n/**\n * If checksums should be used to decide if writes are needed.\n * @type {boolean}\n */\nconst useChecksums = ProjectConfig.vcs === 'svn';\n\nconst escapePathComponent = a => a.replace(/\\//g, '%2F');\n\n/**\n * A stream that writes {@link Node}s to the file system.\n */\nexport class WriteStream extends Writable {\n\n  /**\n   * Creates a new WriteStream.\n   * @param {Object} options The options to use.\n   * @param {string} options.path The path to write to **(required)**.\n   * @param {string} options.base The base path to write to (defaults to *path*).\n   */\n  constructor(options) {\n    if (!options.path) {\n      throw new Error('Missing `path` option');\n    }\n\n    super(Object.assign({}, options, { objectMode: true, highWaterMark: 10000 }));\n\n    /**\n     * If the stream is destroyed.\n     * @type {boolean}\n     */\n    this._isDestroyed = false;\n\n    /**\n     * The number of processed nodes.\n     * @type {number}\n     */\n    this._processed = 0;\n\n    /**\n     * The number of written nodes.\n     * @type {number}\n     */\n    this._written = 0;\n\n    /**\n     * The base to output to.\n     * @type {string}\n     */\n    this._base = options.base || options.path;\n\n    /**\n     * The object stored in the *rename file* (usually at './atscm/rename.json')\n     */\n    this._renameConfig = {};\n\n    /**\n     * A promise that resolves once the *rename file* is loaded.\n     * @type Promise<Object>\n     */\n    this._loadRenameConfig = readJson(renameConfigPath)\n      .then(config => (this._renameConfig = config))\n      .catch(() => Logger.debug('No rename config file loaded'));\n\n    /**\n     * A map of ids used for renaming.\n     */\n    this._idMap = new Map();\n\n    /**\n     * If writes should actually be performed. Set to `false` once id conflicts were discovered.\n     */\n    this._performWrites = true;\n\n    /**\n     * The IDs that are affected by node id conflicts, lowercased.\n     * @type {Set<string>}\n     */\n    this._conflictingIds = new Set();\n\n    /**\n     * The number of id conflicts discovered.\n     * @type {number}\n     */\n    this._discoveredIdConflicts = 0;\n\n    if (useChecksums) {\n      Logger.info('Optimizing for SVN diffs');\n    }\n  }\n\n  /**\n   * If the stream is destroyed.\n   * @type {boolean}\n   */\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n\n  /**\n   * Transverses the node tree to see if any parent node has an id conflict.\n   * @param {ServerNode} node The processed node.\n   * @return {boolean} `true` if a parent node has an id conflict.\n   */\n  _parentHasIdConflict(node) {\n    let current = node.parent;\n\n    while (current) {\n      if (this._conflictingIds.has(current.nodeId.toLowerCase())) { return true; }\n      current = current.parent;\n    }\n\n    return false;\n  }\n\n  async _outputFile(path, content) {\n    if (useChecksums) {\n      const oldSum = await hasha.fromFile(path, hashaOptions)\n        .catch(() => null);\n\n      if (oldSum) {\n        if (oldSum === hasha(content, hashaOptions)) {\n          Logger.debug(`Content did not change at ${path}`);\n          return Promise.resolve();\n        }\n\n        Logger.debug(`Content changed at ${path}`);\n      } else {\n        Logger.debug(`No checksums for ${path}`);\n      }\n    }\n\n    return outputFile(path, content);\n  }\n\n  /**\n   * Writes a single node to disk.\n   * @param {ServerNode} node The processed node.\n   * @return {Promise<boolean>} Resolves once the node has been written, `true` indicates the node\n   * has actually been written.\n   */\n  async _writeNode(node) {\n    // TODO: Throw if node.name ends with '.inner'\n    const dirPath = node.filePath.map(escapePathComponent);\n\n    const writeOps = [];\n\n    // Rename nodes specified in the rename config\n    const rename = this._renameConfig[node.id.value];\n    if (rename && rename !== renameDefaultName) {\n      node.renameTo(rename);\n      Logger.debug(`'${node.nodeId}' was renamed to '${rename}'`);\n\n      Object.assign(node, { _renamed: true });\n    }\n\n    // Resolve invalid ids\n    if (!node._renamed && node.nodeId !== node.id.value) {\n      Logger.debug(`Resolved ID conflict: '${\n        node.id.value}' should be renamed to '${node.nodeId}'`);\n    }\n\n    Object.assign(node, { specialId: node.id.value });\n\n    if (node.name.match(/:/)) {\n      const before = node.name;\n      node.renameTo(node.name.replace(/:/g, '_'));\n      Logger.debug(`Resolved ID conflict: '${before}' was renamed to safe name '${node.name}'`);\n    }\n\n    // Detect \"duplicate\" ids (as file names are case insensitive)\n    const pathKey = dirPath.concat(node.fileName).join('/').toLowerCase();\n    if (this._idMap.has(pathKey)) {\n      if (this._parentHasIdConflict(node)) {\n        Logger.debug(`ID conflict: Skipping '${node.nodeId}'`);\n      } else {\n        Logger.error(`ID conflict: '${node.nodeId}' conflicts with '${\n          this._idMap.get(pathKey)\n        }'`);\n\n        this._discoveredIdConflicts++;\n\n        const existingRename = this._renameConfig[node.nodeId];\n        if (existingRename) {\n          if (existingRename === renameDefaultName) {\n            // eslint-disable-next-line max-len\n            Logger.error(` - '${node.nodeId}' is present inside the rename file at './atscm/rename.json', but no name has been inserted yet.`);\n          } else {\n            // eslint-disable-next-line max-len\n            Logger.error(` - The name for '${node.nodeId}' inside './atscm/rename.json' is not unique.`);\n          }\n\n          Logger.info(\" - Edit the node's name and run 'atscm pull' again\");\n        } else {\n          this._renameConfig[node.nodeId] = renameDefaultName;\n          Logger.info(` - '${node.nodeId}' was added to the rename file at './atscm/rename.json'`);\n          Logger.info(\"Edit it's name and run 'atscm pull' again.\");\n        }\n      }\n\n      this._conflictingIds.add(node.nodeId.toLowerCase());\n      this._performWrites = false;\n    } else {\n      this._idMap.set(pathKey, node.nodeId);\n    }\n\n    // Write definition file (if needed)\n    if (node.hasUnresolvedMetadata) {\n      const name = node.nodeClass === NodeClass.Variable ?\n        `./.${escapePathComponent(node.fileName)}.json` :\n        `./${escapePathComponent(node.fileName)}/.${node.nodeClass.key}.json`;\n\n      if (this._performWrites) {\n        writeOps.push(\n          this._outputFile(join(this._base, dirPath.join('/'), name),\n            JSON.stringify(node.metadata, null, '  '))\n        );\n      }\n    }\n\n    // Write value\n    if (node.nodeClass === NodeClass.Variable) {\n      if (node.value) {\n        if (!node.value.noWrite) {\n          if (this._performWrites) {\n            writeOps.push(\n              this._outputFile(\n                join(this._base, dirPath.join('/'), escapePathComponent(node.fileName)),\n                encodeVariant(node.value))\n            );\n          }\n\n          // Store child nodes as file.inner/...\n          node.renameTo(`${node.name}.inner`);\n        }\n      } else {\n        throw new Error('Missing value');\n      }\n    }\n\n    return Promise.all(writeOps)\n      .then(() => {\n        this._processed++;\n        this._written += writeOps.length;\n      })\n      .then(() => writeOps.length > 0);\n  }\n\n  /**\n   * Writes a single node to the file system.\n   * @param {Node} node The node to write.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error): void} callback Called once finished.\n   */\n  _write(node, enc, callback) {\n    this._loadRenameConfig\n      .then(() => this._writeNode(node))\n      .then(() => callback())\n      .catch(err => callback(err));\n  }\n\n  writeAsync(node) {\n    return new Promise((resolve, reject) => {\n      this._write(node, null, err => (err ? reject(err) : resolve()));\n    });\n  }\n\n  /**\n   * Writes multiple nodes in parallel.\n   * @param {Node[]} nodes The nodes to write.\n   * @param {function(error: ?Error): void} callback Called once all nodes have been written.\n   */\n  _writev(nodes, callback) {\n    if (this.isDestroyed) { return; }\n\n    this._loadRenameConfig\n      .then(() => Promise.all(nodes\n        .map(({ chunk }) => this._writeNode(chunk)))\n      )\n      .then(() => callback())\n      .catch(err => callback(err));\n  }\n\n  /**\n   * Destroys the stream.\n   * @param {?Error} err The error that caused the destroy.\n   * @param {function(err: ?Error): void} callback Called once finished.\n   */\n  _destroy(err, callback) {\n    this._isDestroyed = true;\n    super._destroy(err, callback);\n  }\n\n  /**\n   * Writes the updated rename config to disk.\n   */\n  writeRenamefile() {\n    if (this._discoveredIdConflicts) {\n      Logger.error(\n        `Discovered ${this._discoveredIdConflicts} node id conflicts, results are incomplete.\n - Resolve all conflicts inside '${renameConfigPath}' and run 'atscm pull' again`);\n      // FIXME: Insert link to node ide conflict manual here once 1.0.0 is released.\n    }\n\n    return outputFile(renameConfigPath, JSON.stringify(this._renameConfig, null, '  '));\n  }\n\n}\n\n/**\n * Creates a new {@link WriteStream} to write to *path*.\n * @param {string} path The path to write to.\n */\nexport default function dest(path) {\n  return new WriteStream({ path });\n}\n"],"file":"dest.js"}