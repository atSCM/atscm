{"version":3,"sources":["../../../src/lib/gulp/dest.js"],"names":["renameConfigPath","renameDefaultName","WriteStream","Writable","constructor","options","path","Error","Object","assign","objectMode","highWaterMark","_isDestroyed","_processed","_written","_base","base","_renameConfig","_loadRenameConfig","then","config","catch","Logger","debug","_idMap","Map","_performWrites","_discoveredIdConflicts","isDestroyed","_parentHasIdConflict","node","current","parent","_hasIdConflict","_writeNode","dirPath","filePath","writeOps","rename","id","value","renameTo","nodeId","_renamed","specialId","name","match","before","replace","pathKey","concat","fileName","join","toLowerCase","has","error","get","existingRename","info","set","hasUnresolvedMetadata","nodeClass","NodeClass","Variable","key","push","JSON","stringify","metadata","noWrite","Promise","all","length","_write","enc","callback","err","_writev","nodes","map","chunk","_destroy","_final","dest"],"mappings":"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","sourcesContent":["import { Writable } from 'stream';\nimport { join } from 'path';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport { outputFile, readJson } from 'fs-extra';\nimport Logger from 'gulplog';\nimport { encodeVariant } from '../coding';\n\n/**\n * Relative path to the rename file.\n * @type {string}\n */\nconst renameConfigPath = './atscm/rename.json';\n\n/**\n * The default name inserted into the rename file.\n * @type {string}\n */\nconst renameDefaultName = 'insert node name';\n\n/**\n * A stream that writes {@link Node}s to the file system.\n */\nexport class WriteStream extends Writable {\n\n  /**\n   * Creates a new WriteStream.\n   * @param {Object} options The options to use.\n   * @param {string} options.path The path to write to **(required)**.\n   * @param {string} options.base The base path to write to (defaults to *path*).\n   */\n  constructor(options) {\n    if (!options.path) {\n      throw new Error('Missing `path` option');\n    }\n\n    super(Object.assign({}, options, { objectMode: true, highWaterMark: 10000 }));\n\n    /**\n     * If the stream is destroyed.\n     * @type {boolean}\n     */\n    this._isDestroyed = false;\n\n    /**\n     * The number of processed nodes.\n     * @type {number}\n     */\n    this._processed = 0;\n\n    /**\n     * The number of written nodes.\n     * @type {number}\n     */\n    this._written = 0;\n\n    /**\n     * The base to output to.\n     * @type {string}\n     */\n    this._base = options.base || options.path;\n\n    /**\n     * The object stored in the *rename file* (usually at './atscm/rename.json')\n     */\n    this._renameConfig = {};\n\n    /**\n     * A promise that resolves once the *rename file* is loaded.\n     * @type Promise<Object>\n     */\n    this._loadRenameConfig = readJson(renameConfigPath)\n      .then(config => (this._renameConfig = config))\n      .catch(() => Logger.debug('No rename config file loaded'));\n\n    /**\n     * A map of ids used for renaming.\n     */\n    this._idMap = new Map();\n\n    /**\n     * If writes should actually be performed. Set to `false` once id conflicts were discovered.\n     */\n    this._performWrites = true;\n\n    this._discoveredIdConflicts = 0;\n  }\n\n  /**\n   * If the stream is destroyed.\n   * @type {boolean}\n   */\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n\n  /**\n   * Transverses the node tree to see if any parent node has an id conflict.\n   * @param {ServerNode} node The processed node.\n   * @return {boolean} `true` if a parent node has an id conflict.\n   */\n  _parentHasIdConflict(node) {\n    let current = node.parent;\n\n    while (current) {\n      if (current._hasIdConflict) { return true; }\n      current = current.parent;\n    }\n\n    return false;\n  }\n\n  /**\n   * Writes a single node to disk.\n   * @param {ServerNode} node The processed node.\n   * @return {Promise<boolean>} Resolves once the node has been written, `true` indicates the node\n   * has actually been written.\n   */\n  async _writeNode(node) {\n    // TODO: Throw if node.name ends with '.inner'\n    const dirPath = node.filePath;\n\n    const writeOps = [];\n\n    // Rename nodes specified in the rename config\n    const rename = this._renameConfig[node.id.value];\n    if (rename && rename !== renameDefaultName) {\n      node.renameTo(rename);\n      Logger.debug(`'${node.nodeId}' was renamed to '${rename}'`);\n\n      Object.assign(node, { _renamed: true });\n    }\n\n    // Resolve invalid ids\n    if (!node._renamed && node.nodeId !== node.id.value) {\n      Logger.debug(`Resolved ID conflict: '${\n        node.id.value}' should be renamed to '${node.nodeId}'`);\n    }\n\n    Object.assign(node, { specialId: node.id.value });\n\n    if (node.name.match(/:/)) {\n      const before = node.name;\n      node.renameTo(node.name.replace(/:/g, '_'));\n      Logger.debug(`Resolved ID conflict: '${before}' was renamed to safe name '${node.name}'`);\n    }\n\n    // Detect \"duplicate\" ids (as file names are case insensitive)\n    const pathKey = dirPath.concat(node.fileName).join('/').toLowerCase();\n    if (this._idMap.has(pathKey)) {\n      if (this._parentHasIdConflict(node)) {\n        Logger.debug(`ID conflict: Skipping '${node.nodeId}'`);\n      } else {\n        Logger.error(`ID conflict: '${node.nodeId}' conflicts with '${\n          this._idMap.get(pathKey)\n        }'`);\n\n        this._discoveredIdConflicts++;\n\n        const existingRename = this._renameConfig[node.nodeId];\n        if (existingRename) {\n          if (existingRename === renameDefaultName) {\n            // eslint-disable-next-line max-len\n            Logger.error(` - '${node.nodeId}' is present inside the rename file at './atscm/rename.json', but no name has been inserted yet.`);\n          } else {\n            // eslint-disable-next-line max-len\n            Logger.error(` - The name for '${node.nodeId}' inside './atscm/rename.json' is not unique.`);\n          }\n\n          Logger.info(\" - Edit the node's name and run 'atscm pull' again\");\n        } else {\n          this._renameConfig[node.nodeId] = renameDefaultName;\n          Logger.info(` - '${node.nodeId}' was added to the rename file at './atscm/rename.json'`);\n          Logger.info(\"Edit it's name and run 'atscm pull' again.\");\n        }\n      }\n\n      Object.assign(node, { _hasIdConflict: true });\n      this._performWrites = false;\n    } else {\n      this._idMap.set(pathKey, node.nodeId);\n    }\n\n    // Write definition file (if needed)\n    if (node.hasUnresolvedMetadata) {\n      const name = node.nodeClass === NodeClass.Variable ?\n        `./.${node.fileName}.json` :\n        `./${node.fileName}/.${node.nodeClass.key}.json`;\n\n      if (this._performWrites) {\n        writeOps.push(\n          outputFile(join(this._base, dirPath.join('/'), name),\n            JSON.stringify(node.metadata, null, '  '))\n        );\n      }\n    }\n\n    // Write value\n    if (node.nodeClass === NodeClass.Variable) {\n      if (node.value) {\n        if (!node.value.noWrite) {\n          if (this._performWrites) {\n            writeOps.push(\n              outputFile(\n                join(this._base, dirPath.join('/'), node.fileName),\n                encodeVariant(node.value))\n            );\n          }\n\n          // Store child nodes as file.inner/...\n          node.renameTo(`${node.name}.inner`);\n        }\n      } else {\n        throw new Error('Missing value');\n      }\n    }\n\n    return Promise.all(writeOps)\n      .then(() => {\n        this._processed++;\n        this._written += writeOps.length;\n      })\n      .then(() => writeOps.length > 0);\n  }\n\n  /**\n   * Writes a single node to the file system.\n   * @param {Node} node The node to write.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error): void} callback Called once finished.\n   */\n  _write(node, enc, callback) {\n    this._loadRenameConfig\n      .then(() => this._writeNode(node))\n      .then(() => callback())\n      .catch(err => callback(err));\n  }\n\n  /**\n   * Writes multiple nodes in parallel.\n   * @param {Node[]} nodes The nodes to write.\n   * @param {function(error: ?Error): void} callback Called once all nodes have been written.\n   */\n  _writev(nodes, callback) {\n    if (this.isDestroyed) { return; }\n\n    this._loadRenameConfig\n      .then(() => Promise.all(nodes\n        .map(({ chunk }) => this._writeNode(chunk)))\n      )\n      .then(() => callback())\n      .catch(err => callback(err));\n  }\n\n  /**\n   * Destroys the stream.\n   * @param {?Error} err The error that caused the destroy.\n   * @param {function(err: ?Error): void} callback Called once finished.\n   */\n  _destroy(err, callback) {\n    this._isDestroyed = true;\n    super._destroy(err, callback);\n  }\n\n  /**\n   * Writes the updated rename config to disk.\n   * @param {function(err: ?Error): void} callback Called once the rename file has been written.\n   */\n  _final(callback) {\n    if (this._discoveredIdConflicts) {\n      Logger.error(\n        `Discovered ${this._discoveredIdConflicts} node id conflicts, results are incomplete.\n - Resolve all conflicts inside '${renameConfigPath}' and run 'atscm pull' again`);\n      // FIXME: Insert link to node ide conflict manual here once 1.0.0 is released.\n    }\n\n    outputFile(renameConfigPath, JSON.stringify(this._renameConfig, null, '  '))\n      .then(callback)\n      .catch(callback);\n  }\n\n}\n\n/**\n * Creates a new {@link WriteStream} to write to *path*.\n * @param {string} path The path to write to.\n */\nexport default function dest(path) {\n  return new WriteStream({ path });\n}\n"],"file":"dest.js"}