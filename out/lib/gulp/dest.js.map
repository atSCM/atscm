{"version":3,"sources":["../../../src/lib/gulp/dest.js"],"names":["dest","WriteStream","constructor","options","path","Error","Object","assign","objectMode","highWaterMark","_destroyed","_processed","_written","_base","base","isDestroyed","_isDestroyed","_write","node","enc","callback","dirPath","filePath","writeOps","nodeId","id","value","info","specialId","hasUnresolvedMetadata","name","nodeClass","Variable","fileName","key","push","join","JSON","stringify","metadata","noWrite","renameTo","Promise","all","then","catch","err","length","_writev","nodes","map","chunk","encoding","resolve","reject","_destroy"],"mappings":"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","file":"dest.js","sourcesContent":["import { Writable } from 'stream';\nimport { join } from 'path';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport { outputFile } from 'fs-extra';\nimport Logger from 'gulplog';\nimport { encodeVariant } from '../coding';\n\n/**\n * A stream that writes {@link Node}s to the file system.\n */\nexport class WriteStream extends Writable {\n\n  /**\n   * Creates a new WriteStream.\n   * @param {Object} options The options to use.\n   * @param {string} options.path The path to write to **(required)**.\n   * @param {string} options.base The base path to write to (defaults to *path*).\n   */\n  constructor(options) {\n    if (!options.path) {\n      throw new Error('Missing `path` option');\n    }\n\n    super(Object.assign({}, options, { objectMode: true, highWaterMark: 10000 }));\n\n    /**\n     * If the stream is destroyed.\n     * @type {boolean}\n     */\n    this._destroyed = false;\n\n    /**\n     * The number of processed nodes.\n     * @type {number}\n     */\n    this._processed = 0;\n\n    /**\n     * The number of written nodes.\n     * @type {number}\n     */\n    this._written = 0;\n\n    /**\n     * If the stream is destroyed.\n     * @type {boolean}\n     */\n    this._destroyed = false;\n\n    /**\n     * The base to output to.\n     * @type {string}\n     */\n    this._base = options.base || options.path;\n  }\n\n  /**\n   * If the stream is destroyed.\n   * @type {boolean}\n   */\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n\n  /**\n   * Writes a single node to the file system.\n   * @param {Node} node The node to write.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error): void} callback Called once finished.\n   */\n  _write(node, enc, callback) {\n    // TODO: Throw if node.name ends with '.inner'\n    const dirPath = node.filePath;\n\n    const writeOps = [];\n\n    if (node.nodeId !== node.id.value) {\n      Logger.info(`Resolved ID conflict: '${node.id.value}' should be renamed to '${node.nodeId}'`);\n\n      Object.assign(node, { specialId: node.id.value });\n    }\n\n    // Write definition file (if needed)\n    if (node.hasUnresolvedMetadata) {\n      const name = node.nodeClass === NodeClass.Variable ?\n        `./.${node.fileName}.json` :\n        `./${node.fileName}/.${node.nodeClass.key}.json`;\n\n      writeOps.push(\n        outputFile(join(this._base, dirPath.join('/'), name),\n          JSON.stringify(node.metadata, null, '  '))\n      );\n    }\n\n    // Write value\n    if (node.nodeClass === NodeClass.Variable) {\n      if (node.value) {\n        if (!node.value.noWrite) {\n          writeOps.push(\n            outputFile(\n              join(this._base, dirPath.join('/'), node.fileName),\n              encodeVariant(node.value))\n          );\n\n          // Store child nodes as file.inner/...\n          node.renameTo(`${node.name}.inner`);\n        }\n      } else {\n        throw new Error('Missing value');\n      }\n    }\n\n    Promise.all(writeOps)\n      .then(() => callback())\n      .catch(err => callback(err))\n      .then(() => {\n        this._processed++;\n        this._written += writeOps.length;\n      });\n  }\n\n  /**\n   * Writes multiple nodes in parallel.\n   * @param {Node[]} nodes The nodes to write.\n   * @param {function(error: ?Error): void} callback Called once all nodes have been written.\n   */\n  _writev(nodes, callback) {\n    if (this.isDestroyed) { return; }\n\n    Promise.all(nodes.map(({ chunk, encoding }) => new Promise((resolve, reject) => {\n      this._write(chunk, encoding, err => {\n        if (err) { return reject(err); }\n        return resolve();\n      });\n    })))\n      .then(() => callback())\n      .catch(err => callback(err));\n  }\n\n  /**\n   * Destroys the stream.\n   * @param {?Error} err The error that caused the destroy.\n   * @param {function(err: ?Error): void} callback Called once finished.\n   */\n  _destroy(err, callback) {\n    this._isDestroyed = true;\n    super._destroy(err, callback);\n  }\n\n}\n\n/**\n * Creates a new {@link WriteStream} to write to *path*.\n * @param {string} path The path to write to.\n */\nexport default function dest(path) {\n  return new WriteStream({ path });\n}\n"]}