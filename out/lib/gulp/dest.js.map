{"version":3,"sources":["../../../src/lib/gulp/dest.js"],"names":["renameConfigPath","renameDefaultName","hashaOptions","algorithm","useChecksums","ProjectConfig","vcs","escapePathComponent","a","replace","WriteStream","Writable","constructor","options","path","Error","Object","assign","objectMode","highWaterMark","_isDestroyed","_processed","_written","_base","base","_renameConfig","_loadRenameConfig","then","config","catch","Logger","debug","_idMap","Map","_performWrites","_discoveredIdConflicts","info","isDestroyed","_parentHasIdConflict","node","current","parent","_hasIdConflict","_outputFile","content","oldSum","hasha","fromFile","Promise","resolve","_writeNode","dirPath","filePath","map","writeOps","rename","id","value","renameTo","nodeId","_renamed","specialId","name","match","before","pathKey","concat","fileName","join","toLowerCase","has","error","get","existingRename","set","hasUnresolvedMetadata","nodeClass","NodeClass","Variable","key","push","JSON","stringify","metadata","noWrite","all","length","_write","enc","callback","err","writeAsync","reject","_writev","nodes","chunk","_destroy","writeRenamefile","dest"],"mappings":"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","sourcesContent":["import { Writable } from 'stream';\nimport { join } from 'path';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport { outputFile, readJson } from 'fs-extra';\nimport hasha from 'hasha';\nimport Logger from 'gulplog';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport { encodeVariant } from '../coding';\n\n/**\n * Relative path to the rename file.\n * @type {string}\n */\nconst renameConfigPath = './atscm/rename.json';\n\n/**\n * The default name inserted into the rename file.\n * @type {string}\n */\nconst renameDefaultName = 'insert node name';\n\n/**\n * Options to pass to *hasha*.\n * @type {Object}\n */\nconst hashaOptions = { algorithm: 'md5' };\n\n/**\n * If checksums should be used to decide if writes are needed.\n * @type {boolean}\n */\nconst useChecksums = ProjectConfig.vcs === 'svn';\n\nconst escapePathComponent = a => a.replace(/\\//g, '%2F');\n\n/**\n * A stream that writes {@link Node}s to the file system.\n */\nexport class WriteStream extends Writable {\n\n  /**\n   * Creates a new WriteStream.\n   * @param {Object} options The options to use.\n   * @param {string} options.path The path to write to **(required)**.\n   * @param {string} options.base The base path to write to (defaults to *path*).\n   */\n  constructor(options) {\n    if (!options.path) {\n      throw new Error('Missing `path` option');\n    }\n\n    super(Object.assign({}, options, { objectMode: true, highWaterMark: 10000 }));\n\n    /**\n     * If the stream is destroyed.\n     * @type {boolean}\n     */\n    this._isDestroyed = false;\n\n    /**\n     * The number of processed nodes.\n     * @type {number}\n     */\n    this._processed = 0;\n\n    /**\n     * The number of written nodes.\n     * @type {number}\n     */\n    this._written = 0;\n\n    /**\n     * The base to output to.\n     * @type {string}\n     */\n    this._base = options.base || options.path;\n\n    /**\n     * The object stored in the *rename file* (usually at './atscm/rename.json')\n     */\n    this._renameConfig = {};\n\n    /**\n     * A promise that resolves once the *rename file* is loaded.\n     * @type Promise<Object>\n     */\n    this._loadRenameConfig = readJson(renameConfigPath)\n      .then(config => (this._renameConfig = config))\n      .catch(() => Logger.debug('No rename config file loaded'));\n\n    /**\n     * A map of ids used for renaming.\n     */\n    this._idMap = new Map();\n\n    /**\n     * If writes should actually be performed. Set to `false` once id conflicts were discovered.\n     */\n    this._performWrites = true;\n\n    this._discoveredIdConflicts = 0;\n\n    if (useChecksums) {\n      Logger.info('Optimizing for SVN diffs');\n    }\n  }\n\n  /**\n   * If the stream is destroyed.\n   * @type {boolean}\n   */\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n\n  /**\n   * Transverses the node tree to see if any parent node has an id conflict.\n   * @param {ServerNode} node The processed node.\n   * @return {boolean} `true` if a parent node has an id conflict.\n   */\n  _parentHasIdConflict(node) {\n    let current = node.parent;\n\n    while (current) {\n      if (current._hasIdConflict) { return true; }\n      current = current.parent;\n    }\n\n    return false;\n  }\n\n  async _outputFile(path, content) {\n    if (useChecksums) {\n      const oldSum = await hasha.fromFile(path, hashaOptions)\n        .catch(() => null);\n\n      if (oldSum) {\n        if (oldSum === hasha(content, hashaOptions)) {\n          Logger.debug(`Content did not change at ${path}`);\n          return Promise.resolve();\n        }\n\n        Logger.debug(`Content changed at ${path}`);\n      } else {\n        Logger.debug(`No checksums for ${path}`);\n      }\n    }\n\n    return outputFile(path, content);\n  }\n\n  /**\n   * Writes a single node to disk.\n   * @param {ServerNode} node The processed node.\n   * @return {Promise<boolean>} Resolves once the node has been written, `true` indicates the node\n   * has actually been written.\n   */\n  async _writeNode(node) {\n    // TODO: Throw if node.name ends with '.inner'\n    const dirPath = node.filePath.map(escapePathComponent);\n\n    const writeOps = [];\n\n    // Rename nodes specified in the rename config\n    const rename = this._renameConfig[node.id.value];\n    if (rename && rename !== renameDefaultName) {\n      node.renameTo(rename);\n      Logger.debug(`'${node.nodeId}' was renamed to '${rename}'`);\n\n      Object.assign(node, { _renamed: true });\n    }\n\n    // Resolve invalid ids\n    if (!node._renamed && node.nodeId !== node.id.value) {\n      Logger.debug(`Resolved ID conflict: '${\n        node.id.value}' should be renamed to '${node.nodeId}'`);\n    }\n\n    Object.assign(node, { specialId: node.id.value });\n\n    if (node.name.match(/:/)) {\n      const before = node.name;\n      node.renameTo(node.name.replace(/:/g, '_'));\n      Logger.debug(`Resolved ID conflict: '${before}' was renamed to safe name '${node.name}'`);\n    }\n\n    // Detect \"duplicate\" ids (as file names are case insensitive)\n    const pathKey = dirPath.concat(node.fileName).join('/').toLowerCase();\n    if (this._idMap.has(pathKey)) {\n      if (this._parentHasIdConflict(node)) {\n        Logger.debug(`ID conflict: Skipping '${node.nodeId}'`);\n      } else {\n        Logger.error(`ID conflict: '${node.nodeId}' conflicts with '${\n          this._idMap.get(pathKey)\n        }'`);\n\n        this._discoveredIdConflicts++;\n\n        const existingRename = this._renameConfig[node.nodeId];\n        if (existingRename) {\n          if (existingRename === renameDefaultName) {\n            // eslint-disable-next-line max-len\n            Logger.error(` - '${node.nodeId}' is present inside the rename file at './atscm/rename.json', but no name has been inserted yet.`);\n          } else {\n            // eslint-disable-next-line max-len\n            Logger.error(` - The name for '${node.nodeId}' inside './atscm/rename.json' is not unique.`);\n          }\n\n          Logger.info(\" - Edit the node's name and run 'atscm pull' again\");\n        } else {\n          this._renameConfig[node.nodeId] = renameDefaultName;\n          Logger.info(` - '${node.nodeId}' was added to the rename file at './atscm/rename.json'`);\n          Logger.info(\"Edit it's name and run 'atscm pull' again.\");\n        }\n      }\n\n      Object.assign(node, { _hasIdConflict: true });\n      this._performWrites = false;\n    } else {\n      this._idMap.set(pathKey, node.nodeId);\n    }\n\n    // Write definition file (if needed)\n    if (node.hasUnresolvedMetadata) {\n      const name = node.nodeClass === NodeClass.Variable ?\n        `./.${escapePathComponent(node.fileName)}.json` :\n        `./${escapePathComponent(node.fileName)}/.${node.nodeClass.key}.json`;\n\n      if (this._performWrites) {\n        writeOps.push(\n          this._outputFile(join(this._base, dirPath.join('/'), name),\n            JSON.stringify(node.metadata, null, '  '))\n        );\n      }\n    }\n\n    // Write value\n    if (node.nodeClass === NodeClass.Variable) {\n      if (node.value) {\n        if (!node.value.noWrite) {\n          if (this._performWrites) {\n            writeOps.push(\n              this._outputFile(\n                join(this._base, dirPath.join('/'), escapePathComponent(node.fileName)),\n                encodeVariant(node.value))\n            );\n          }\n\n          // Store child nodes as file.inner/...\n          node.renameTo(`${node.name}.inner`);\n        }\n      } else {\n        throw new Error('Missing value');\n      }\n    }\n\n    return Promise.all(writeOps)\n      .then(() => {\n        this._processed++;\n        this._written += writeOps.length;\n      })\n      .then(() => writeOps.length > 0);\n  }\n\n  /**\n   * Writes a single node to the file system.\n   * @param {Node} node The node to write.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error): void} callback Called once finished.\n   */\n  _write(node, enc, callback) {\n    this._loadRenameConfig\n      .then(() => this._writeNode(node))\n      .then(() => callback())\n      .catch(err => callback(err));\n  }\n\n  writeAsync(node) {\n    return new Promise((resolve, reject) => {\n      this._write(node, null, err => (err ? reject(err) : resolve()));\n    });\n  }\n\n  /**\n   * Writes multiple nodes in parallel.\n   * @param {Node[]} nodes The nodes to write.\n   * @param {function(error: ?Error): void} callback Called once all nodes have been written.\n   */\n  _writev(nodes, callback) {\n    if (this.isDestroyed) { return; }\n\n    this._loadRenameConfig\n      .then(() => Promise.all(nodes\n        .map(({ chunk }) => this._writeNode(chunk)))\n      )\n      .then(() => callback())\n      .catch(err => callback(err));\n  }\n\n  /**\n   * Destroys the stream.\n   * @param {?Error} err The error that caused the destroy.\n   * @param {function(err: ?Error): void} callback Called once finished.\n   */\n  _destroy(err, callback) {\n    this._isDestroyed = true;\n    super._destroy(err, callback);\n  }\n\n  /**\n   * Writes the updated rename config to disk.\n   */\n  writeRenamefile() {\n    if (this._discoveredIdConflicts) {\n      Logger.error(\n        `Discovered ${this._discoveredIdConflicts} node id conflicts, results are incomplete.\n - Resolve all conflicts inside '${renameConfigPath}' and run 'atscm pull' again`);\n      // FIXME: Insert link to node ide conflict manual here once 1.0.0 is released.\n    }\n\n    return outputFile(renameConfigPath, JSON.stringify(this._renameConfig, null, '  '));\n  }\n\n}\n\n/**\n * Creates a new {@link WriteStream} to write to *path*.\n * @param {string} path The path to write to.\n */\nexport default function dest(path) {\n  return new WriteStream({ path });\n}\n"],"file":"dest.js"}