{"version":3,"sources":["../../../src/lib/gulp/dest.js"],"names":["dest","renameConfigPath","renameDefaultName","WriteStream","constructor","options","path","Error","Object","assign","objectMode","highWaterMark","_isDestroyed","_processed","_written","_base","base","_renameConfig","_loadRenameConfig","then","config","catch","debug","_idMap","Map","_performWrites","_discoveredIdConflicts","isDestroyed","_parentHasIdConflict","node","current","parent","_hasIdConflict","_writeNode","dirPath","filePath","writeOps","rename","id","value","renameTo","nodeId","_renamed","specialId","name","match","before","replace","pathKey","concat","fileName","join","toLowerCase","has","error","get","existingRename","info","set","hasUnresolvedMetadata","nodeClass","Variable","key","push","JSON","stringify","metadata","noWrite","Promise","all","length","_write","enc","callback","err","_writev","nodes","map","chunk","_destroy","_final"],"mappings":"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","file":"dest.js","sourcesContent":["import { Writable } from 'stream';\nimport { join } from 'path';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport { outputFile, readJson } from 'fs-extra';\nimport Logger from 'gulplog';\nimport { encodeVariant } from '../coding';\n\n/**\n * Relative path to the rename file.\n * @type {string}\n */\nconst renameConfigPath = './atscm/rename.json';\n\n/**\n * The default name inserted into the rename file.\n * @type {string}\n */\nconst renameDefaultName = 'insert node name';\n\n/**\n * A stream that writes {@link Node}s to the file system.\n */\nexport class WriteStream extends Writable {\n\n  /**\n   * Creates a new WriteStream.\n   * @param {Object} options The options to use.\n   * @param {string} options.path The path to write to **(required)**.\n   * @param {string} options.base The base path to write to (defaults to *path*).\n   */\n  constructor(options) {\n    if (!options.path) {\n      throw new Error('Missing `path` option');\n    }\n\n    super(Object.assign({}, options, { objectMode: true, highWaterMark: 10000 }));\n\n    /**\n     * If the stream is destroyed.\n     * @type {boolean}\n     */\n    this._isDestroyed = false;\n\n    /**\n     * The number of processed nodes.\n     * @type {number}\n     */\n    this._processed = 0;\n\n    /**\n     * The number of written nodes.\n     * @type {number}\n     */\n    this._written = 0;\n\n    /**\n     * The base to output to.\n     * @type {string}\n     */\n    this._base = options.base || options.path;\n\n    /**\n     * The object stored in the *rename file* (usually at './atscm/rename.json')\n     */\n    this._renameConfig = {};\n\n    /**\n     * A promise that resolves once the *rename file* is loaded.\n     * @type Promise<Object>\n     */\n    this._loadRenameConfig = readJson(renameConfigPath)\n      .then(config => (this._renameConfig = config))\n      .catch(() => Logger.debug('No rename config file loaded'));\n\n    /**\n     * A map of ids used for renaming.\n     */\n    this._idMap = new Map();\n\n    /**\n     * If writes should actually be performed. Set to `false` once id conflicts were discovered.\n     */\n    this._performWrites = true;\n\n    this._discoveredIdConflicts = 0;\n  }\n\n  /**\n   * If the stream is destroyed.\n   * @type {boolean}\n   */\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n\n  /**\n   * Transverses the node tree to see if any parent node has an id conflict.\n   * @param {ServerNode} node The processed node.\n   * @return {boolean} `true` if a parent node has an id conflict.\n   */\n  _parentHasIdConflict(node) {\n    let current = node.parent;\n\n    while (current) {\n      if (current._hasIdConflict) { return true; }\n      current = current.parent;\n    }\n\n    return false;\n  }\n\n  /**\n   * Writes a single node to disk.\n   * @param {ServerNode} node The processed node.\n   * @return {Promise<boolean>} Resolves once the node has been written, `true` indicates the node\n   * has actually been written.\n   */\n  async _writeNode(node) {\n    // TODO: Throw if node.name ends with '.inner'\n    const dirPath = node.filePath;\n\n    const writeOps = [];\n\n    // Rename nodes specified in the rename config\n    const rename = this._renameConfig[node.id.value];\n    if (rename && rename !== renameDefaultName) {\n      node.renameTo(rename);\n      Logger.debug(`'${node.nodeId}' was renamed to '${rename}'`);\n\n      Object.assign(node, { _renamed: true });\n    }\n\n    // Resolve invalid ids\n    if (!node._renamed && node.nodeId !== node.id.value) {\n      Logger.debug(`Resolved ID conflict: '${\n        node.id.value}' should be renamed to '${node.nodeId}'`);\n    }\n\n    Object.assign(node, { specialId: node.id.value });\n\n    if (node.name.match(/:/)) {\n      const before = node.name;\n      node.renameTo(node.name.replace(/:/g, '_'));\n      Logger.debug(`Resolved ID conflict: '${before}' was renamed to safe name '${node.name}'`);\n    }\n\n    // Detect \"duplicate\" ids (as file names are case insensitive)\n    const pathKey = dirPath.concat(node.fileName).join('/').toLowerCase();\n    if (this._idMap.has(pathKey)) {\n      if (this._parentHasIdConflict(node)) {\n        Logger.debug(`ID conflict: Skipping '${node.nodeId}'`);\n      } else {\n        Logger.error(`ID conflict: '${node.nodeId}' conflicts with '${\n          this._idMap.get(pathKey)\n        }'`);\n\n        this._discoveredIdConflicts++;\n\n        const existingRename = this._renameConfig[node.nodeId];\n        if (existingRename) {\n          if (existingRename === renameDefaultName) {\n            // eslint-disable-next-line max-len\n            Logger.error(` - '${node.nodeId}' is present inside the rename file at './atscm/rename.json', but no name has been inserted yet.`);\n          } else {\n            // eslint-disable-next-line max-len\n            Logger.error(` - The name for '${node.nodeId}' inside './atscm/rename.json' is not unique.`);\n          }\n\n          Logger.info(\" - Edit the node's name and run 'atscm pull' again\");\n        } else {\n          this._renameConfig[node.nodeId] = renameDefaultName;\n          Logger.info(` - '${node.nodeId}' was added to the rename file at './atscm/rename.json'`);\n          Logger.info(\"Edit it's name and run 'atscm pull' again.\");\n        }\n      }\n\n      Object.assign(node, { _hasIdConflict: true });\n      this._performWrites = false;\n    } else {\n      this._idMap.set(pathKey, node.nodeId);\n    }\n\n    // Write definition file (if needed)\n    if (node.hasUnresolvedMetadata) {\n      const name = node.nodeClass === NodeClass.Variable ?\n        `./.${node.fileName}.json` :\n        `./${node.fileName}/.${node.nodeClass.key}.json`;\n\n      if (this._performWrites) {\n        writeOps.push(\n          outputFile(join(this._base, dirPath.join('/'), name),\n            JSON.stringify(node.metadata, null, '  '))\n        );\n      }\n    }\n\n    // Write value\n    if (node.nodeClass === NodeClass.Variable) {\n      if (node.value) {\n        if (!node.value.noWrite) {\n          if (this._performWrites) {\n            writeOps.push(\n              outputFile(\n                join(this._base, dirPath.join('/'), node.fileName),\n                encodeVariant(node.value))\n            );\n          }\n\n          // Store child nodes as file.inner/...\n          node.renameTo(`${node.name}.inner`);\n        }\n      } else {\n        throw new Error('Missing value');\n      }\n    }\n\n    return Promise.all(writeOps)\n      .then(() => {\n        this._processed++;\n        this._written += writeOps.length;\n      })\n      .then(() => writeOps.length > 0);\n  }\n\n  /**\n   * Writes a single node to the file system.\n   * @param {Node} node The node to write.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error): void} callback Called once finished.\n   */\n  _write(node, enc, callback) {\n    this._loadRenameConfig\n      .then(() => this._writeNode(node))\n      .then(() => callback())\n      .catch(err => callback(err));\n  }\n\n  /**\n   * Writes multiple nodes in parallel.\n   * @param {Node[]} nodes The nodes to write.\n   * @param {function(error: ?Error): void} callback Called once all nodes have been written.\n   */\n  _writev(nodes, callback) {\n    if (this.isDestroyed) { return; }\n\n    this._loadRenameConfig\n      .then(() => Promise.all(nodes\n        .map(({ chunk }) => this._writeNode(chunk)))\n      )\n      .then(() => callback())\n      .catch(err => callback(err));\n  }\n\n  /**\n   * Destroys the stream.\n   * @param {?Error} err The error that caused the destroy.\n   * @param {function(err: ?Error): void} callback Called once finished.\n   */\n  _destroy(err, callback) {\n    this._isDestroyed = true;\n    super._destroy(err, callback);\n  }\n\n  /**\n   * Writes the updated rename config to disk.\n   * @param {function(err: ?Error): void} callback Called once the rename file has been written.\n   */\n  _final(callback) {\n    if (this._discoveredIdConflicts) {\n      Logger.error(\n        `Discovered ${this._discoveredIdConflicts} node id conflicts, results are incomplete.\n - Resolve all conflicts inside '${renameConfigPath}' and run 'atscm pull' again`);\n      // FIXME: Insert link to node ide conflict manual here once 1.0.0 is released.\n    }\n\n    outputFile(renameConfigPath, JSON.stringify(this._renameConfig, null, '  '))\n      .then(callback)\n      .catch(callback);\n  }\n\n}\n\n/**\n * Creates a new {@link WriteStream} to write to *path*.\n * @param {string} path The path to write to.\n */\nexport default function dest(path) {\n  return new WriteStream({ path });\n}\n"]}