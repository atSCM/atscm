{"version":3,"sources":["../../../src/lib/gulp/PullStream.js"],"names":["PullStream","constructor","options","nodesToPull","fileTransformer","nodesToTransform","useInputStream","inputStream","readStream","printProgress","setInterval","info","processed","opsPerSecond","toFixed","listenerCount","cursorTo","process","stdout","moveCursor","stream","pipe","RelativeSourceDirectoryPath","on","clearLine","clearInterval"],"mappings":";;;;;;AAAA;;;;AACA;;AACA;;;;AACA;;;;AACA;;;;;;AAEA;;;AAGe,MAAMA,UAAN,CAAiB;;AAE9B;;;;;;;;AAQAC,cAAYC,UAAU,EAAtB,EAA0B;AACxB;;;;AAIA,UAAMC,cAAcD,QAAQC,WAAR,IAAuB,EAA3C;;AAEA,UAAMC,kBAAkB,4CAAkC;AACxDC,wBAAkBF,WADsC;AAExDG,sBAAgBJ,QAAQI,cAFgC;AAGxDC,mBAAaL,QAAQK;AAHmC,KAAlC,CAAxB;;AAMA,UAAMC,aAAaJ,gBAAgBI,UAAnC;;AAEA,UAAMC,gBAAgBC,YAAY,MAAM;AACtC,wBAAOC,IAAP,CAAa,WAAUH,WAAWI,SAAU,KAAIJ,WAAWK,YAAX,CAAwBC,OAAxB,CAAgC,CAAhC,CAAmC,SAAnF;;AAEA,UAAI,kBAAOC,aAAP,CAAqB,MAArB,IAA+B,CAAnC,EAAsC;AACpC,2BAASC,QAAT,CAAkBC,QAAQC,MAA1B,EAAkC,CAAlC;AACA,2BAASC,UAAT,CAAoBF,QAAQC,MAA5B,EAAoC,CAApC,EAAuC,CAAC,CAAxC;AACD;AACF,KAPqB,EAOnB,IAPmB,CAAtB;;AASA,WAAOd,gBAAgBgB,MAAhB,CACJC,IADI,CACC,gBAAK,wBAAcC,2BAAnB,CADD,EAEJC,EAFI,CAED,QAFC,EAES,MAAM;AAClB,UAAI,kBAAOR,aAAP,CAAqB,MAArB,IAA+B,CAAnC,EAAsC;AACpC,2BAASS,SAAT,CAAmBP,QAAQC,MAA3B,EAAmC,CAAnC;AACA,2BAASF,QAAT,CAAkBC,QAAQC,MAA1B,EAAkC,CAAlC;AACD;;AAEDO,oBAAchB,aAAd;AACD,KATI,CAAP;AAUD;AA5C6B;kBAAXT,U","file":"PullStream.js","sourcesContent":["import readline from 'readline';\nimport { dest } from 'gulp';\nimport Logger from 'gulplog';\nimport UaNodeToAtviseFileTransformer from '../../transform/UaNodeToAtviseFileTransformer';\nimport ProjectConfig from '../../config/ProjectConfig';\n\n/**\n * A stream that transforms read {@link ReadStream.ReadResult}s and stores the on the filesystem.\n */\nexport default class PullStream {\n\n  /**\n   * Creates a new PullStream based on the given options.\n   * @param {Object} options The stream configuration options.\n   * @param {NodeId[]} [options.nodesToPull] The nodes to push.\n   * @param {Boolean} [options.useInputStream] Defines if the given input\n   * stream should be used for mapping.\n   * @param {Stream} [options.inputStream] The input stream to use.\n   */\n  constructor(options = {}) {\n    /**\n     * The nodes to pull\n     * @type {NodeId[]}\n     */\n    const nodesToPull = options.nodesToPull || [];\n\n    const fileTransformer = new UaNodeToAtviseFileTransformer({\n      nodesToTransform: nodesToPull,\n      useInputStream: options.useInputStream,\n      inputStream: options.inputStream,\n    });\n\n    const readStream = fileTransformer.readStream;\n\n    const printProgress = setInterval(() => {\n      Logger.info(`Pulled: ${readStream.processed} (${readStream.opsPerSecond.toFixed(1)} ops/s)`);\n\n      if (Logger.listenerCount('info') > 0) {\n        readline.cursorTo(process.stdout, 0);\n        readline.moveCursor(process.stdout, 0, -1);\n      }\n    }, 1000);\n\n    return fileTransformer.stream\n      .pipe(dest(ProjectConfig.RelativeSourceDirectoryPath))\n      .on('finish', () => {\n        if (Logger.listenerCount('info') > 0) {\n          readline.clearLine(process.stdout, 0);\n          readline.cursorTo(process.stdout, 0);\n        }\n\n        clearInterval(printProgress);\n      });\n  }\n}\n"]}