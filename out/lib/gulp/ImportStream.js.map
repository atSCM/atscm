{"version":3,"sources":["../../../src/lib/gulp/ImportStream.js"],"names":["methodId","methodBaseId","parent","scopeId","NodeIdType","NUMERIC","baseCallObject","objectId","toString","inputArguments","dataType","NodeId","value","ImportStream","createCallObject","file","Object","assign","concat","XmlElement","contents","processErrorMessage","process","cwd","path","processChunk","handleErrors","callObj","session","call","err","result","statusCode","Good","done","importSuccessFull","outputArguments","debug","Error","e"],"mappings":";;;;;;AAAA;;AACA;;AACA;;;;AACA;;;;AACA;;;;;;AAEA;;;;AAIA,MAAMA,WAAW,qBAAW,wCAAX,CAAjB;;AAEA;;;;AAIA,MAAMC,eAAeD,SAASE,MAA9B;;AAEA;;;;AAIA,MAAMC,UAAU,qBAAW,iBAAOC,UAAP,CAAkBC,OAA7B,EAAsC,CAAtC,EAAyC,CAAzC,CAAhB;;AAEA;;;;AAIA,MAAMC,iBAAiB;AACrBC,YAAUN,aAAaO,QAAb,EADW;AAErBR,YAAUA,SAASQ,QAAT,EAFW;AAGrBC,kBAAgB,CACd;AACEC,cAAU,oBAASC,MADrB;AAEEC,WAAOT;AAFT,GADc;AAHK,CAAvB;;AAWA;;;AAGe,MAAMU,YAAN,+BAAuC;;AAEpD;;;;;AAKAC,mBAAiBC,IAAjB,EAAuB;AACrB,WAAOC,OAAOC,MAAP,CAAc,EAAd,EAAkBX,cAAlB,EAAkC;AACvCG,sBAAgBH,eAAeG,cAAf,CACbS,MADa,CACN;AACNR,kBAAU,oBAASS,UADb;AAENP,eAAOG,KAAKK;AAFN,OADM;AADuB,KAAlC,CAAP;AAOD;;AAED;;;;;AAKAC,sBAAoBN,IAApB,EAA0B;AACxB,WAAQ,yBAAwB,oBAASO,QAAQC,GAAR,EAAT,EAAwBR,KAAKS,IAA7B,CAAmC,EAAnE;AACD;;AAED;;;;;;AAMAC,eAAaV,IAAb,EAAmBW,YAAnB,EAAiC;AAC/B,UAAMC,UAAU,KAAKb,gBAAL,CAAsBC,IAAtB,CAAhB;;AAEA,QAAI;AACF,WAAKa,OAAL,CAAaC,IAAb,CAAkB,CAACF,OAAD,CAAlB,EAA6B,CAACG,GAAD,EAAM,CAACC,MAAD,IAAW,EAAjB,KAAwB;AACnD,YAAID,GAAJ,EAAS;AACPJ,uBAAaI,GAAb;AACD,SAFD,MAEO,IAAIC,OAAOC,UAAP,CAAkBpB,KAAlB,KAA4B,uBAAYqB,IAAZ,CAAiBrB,KAAjD,EAAwD;AAC7Dc,uBAAaI,GAAb,EAAkBC,OAAOC,UAAzB,EAAqCE,QAAQA,MAA7C;AACD,SAFM,MAEA;AACL,gBAAMC,oBAAoBJ,OAAOK,eAAP,CAAuB,CAAvB,EAA0BxB,KAApD;;AAEA,cAAIuB,iBAAJ,EAAuB;AACrB,8BAAOE,KAAP,CAAc,+BAA8BtB,KAAKS,IAAK,EAAtD;;AAEAE,yBAAa,IAAb,EAAmB,uBAAYO,IAA/B,EAAqCC,QAAQA,MAA7C;AACD,WAJD,MAIO;AACLR,yBAAa,IAAIY,KAAJ,CAAU,YAAV,CAAb,EAAsC,uBAAYL,IAAlD,EAAwDC,QAAQA,MAAhE;AACD;AACF;AACF,OAhBD;AAiBD,KAlBD,CAkBE,OAAOK,CAAP,EAAU;AACVb,mBAAaa,CAAb;AACD;AACF;;AAxDmD;kBAAjC1B,Y","file":"ImportStream.js","sourcesContent":["import { relative } from 'path';\nimport { DataType, StatusCodes } from 'node-opcua';\nimport Logger from 'gulplog';\nimport QueueStream from '../server/QueueStream';\nimport NodeId from '../server/NodeId';\n\n/**\n * Call script node id\n * @type {NodeId}\n */\nconst methodId = new NodeId('ns=1;s=AGENT.OPCUA.METHODS.importNodes');\n\n/**\n * Base node id for callscript node\n * @type {NodeId}\n */\nconst methodBaseId = methodId.parent;\n\n/**\n * The import operation's scope, which is set to be *absolute*.\n * @type {NodeId}\n */\nconst scopeId = new NodeId(NodeId.NodeIdType.NUMERIC, 0, 0);\n\n/**\n * The call object that is used for all calls.\n * @type {Object}\n */\nconst baseCallObject = {\n  objectId: methodBaseId.toString(),\n  methodId: methodId.toString(),\n  inputArguments: [\n    {\n      dataType: DataType.NodeId,\n      value: scopeId,\n    },\n  ],\n};\n\n/**\n * A stream that imports xml files in parallel.\n */\nexport default class ImportStream extends QueueStream {\n\n  /**\n   * @param {vinyl~file} file The file to create the call object for.\n   * Creates the call object for the given file.\n   * @return {Object} The resulting call script object.\n   */\n  createCallObject(file) {\n    return Object.assign({}, baseCallObject, {\n      inputArguments: baseCallObject.inputArguments\n        .concat({\n          dataType: DataType.XmlElement,\n          value: file.contents,\n        }),\n    });\n  }\n\n  /**\n   * Returns an error message specifically for the given file.\n   * @param {vinyl~file} file The file to generate the error message for.\n   * @return {string} The specific error message.\n   */\n  processErrorMessage(file) {\n    return `Error importing file: ${relative(process.cwd(), file.path)}`;\n  }\n\n  /**\n   * Performs opcua method calls for the given call object configuration.\n   * @param {vinyl~file} file The file being processed.\n   * @param {function(err: Error, status: node-opcua~StatusCodes, success: function)} handleErrors\n   * The error handler to call. See {@link QueueStream#processChunk} for details.\n   */\n  processChunk(file, handleErrors) {\n    const callObj = this.createCallObject(file);\n\n    try {\n      this.session.call([callObj], (err, [result] = []) => {\n        if (err) {\n          handleErrors(err);\n        } else if (result.statusCode.value !== StatusCodes.Good.value) {\n          handleErrors(err, result.statusCode, done => done());\n        } else {\n          const importSuccessFull = result.outputArguments[0].value;\n\n          if (importSuccessFull) {\n            Logger.debug(`Successfully imported file: ${file.path}`);\n\n            handleErrors(null, StatusCodes.Good, done => done());\n          } else {\n            handleErrors(new Error('No success'), StatusCodes.Good, done => done());\n          }\n        }\n      });\n    } catch (e) {\n      handleErrors(e);\n    }\n  }\n\n}\n"]}