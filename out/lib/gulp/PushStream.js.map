{"version":3,"sources":["../../../src/lib/gulp/PushStream.js"],"names":["PushStream","constructor","options","createNodesOnPush","createNodes","nodesToPush","fileTransformer","nodesToTransform","atvReferenceFilter","file","isAtviseReferenceConfig","restore","nodeFileStream","createNodeStream","writeStream","printProgress","setInterval","info","_processed","opsPerSecond","toFixed","listenerCount","cursorTo","process","stdout","moveCursor","pushStream","pipe","once","debug","_readableState","buffer","length","addReferenceStream","on","endStream","clearLine","clearInterval"],"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA;;;AAGe,MAAMA,UAAN,CAAiB;;AAE9B;;;;;;AAMAC,cAAYC,UAAU,EAAtB,EAA0B;AACxB;;;;AAIA,UAAMC,oBAAoBD,QAAQE,WAAR,IAAuB,KAAjD;;AAEA;;;;AAIA,UAAMC,cAAcH,QAAQG,WAAR,IAAuB,EAA3C;;AAEA,UAAMC,kBAAkB,0CAAgC,EAAEC,kBAAkBF,WAApB,EAAhC,CAAxB;AACA,UAAMG,qBAAqB,0BAAOC,QAAQ,CAACA,KAAKC,uBAArB,EAA8C,EAAEC,SAAS,IAAX,EAA9C,CAA3B;AACA,UAAMC,iBAAiB,6BAAmB,EAAER,aAAaD,iBAAf,EAAnB,CAAvB;AACA,UAAMU,mBAAmB,gCAAzB;AACA,UAAMC,cAAc,0BAAgB,EAAEV,aAAaD,iBAAf,EAAhB,CAApB;;AAEA,SAAKY,aAAL,GAAqBC,YAAY,MAAM;AACrC,wBAAOC,IAAP,CACC,WAAUH,YAAYI,UAAW,KAAIJ,YAAYK,YAAZ,CAAyBC,OAAzB,CAAiC,CAAjC,CAAoC,SAD1E;;AAIA,UAAI,kBAAOC,aAAP,CAAqB,MAArB,IAA+B,CAAnC,EAAsC;AACpC,2BAASC,QAAT,CAAkBC,QAAQC,MAA1B,EAAkC,CAAlC;AACA,2BAASC,UAAT,CAAoBF,QAAQC,MAA5B,EAAoC,CAApC,EAAuC,CAAC,CAAxC;AACD;AACF,KAToB,EASlB,IATkB,CAArB;;AAWA,SAAKE,UAAL,GAAkBpB,gBACfqB,IADe,CACVnB,kBADU,EAEfmB,IAFe,CAEVf,cAFU,EAGfe,IAHe,CAGVb,WAHU,CAAlB;;AAKA,QAAIX,iBAAJ,EAAuB;AACrB,WAAKuB,UAAL,CAAgBC,IAAhB,CAAqBd,gBAArB;AACD;;AAED,SAAKa,UAAL,CAAgBE,IAAhB,CAAqB,QAArB,EAA+B,MAAM;AACnC,wBAAOC,KAAP,CAAa,2DAAb;;AAEA,UAAI1B,qBAAqBK,mBAAmBG,OAAnB,CAA2BmB,cAA3B,CAA0CC,MAA1C,CAAiDC,MAAjD,GAA0D,CAAnF,EAAsF;AACpF,cAAMC,qBAAqB,kCAA3B;;AAEA,aAAKP,UAAL,CAAgBC,IAAhB,CAAqBnB,mBAAmBG,OAAxC,EACGgB,IADH,CACQM,kBADR,EAEGC,EAFH,CAEM,QAFN,EAEgB,MAAM,KAAKC,SAAL,EAFtB;AAGD,OAND,MAMO;AACL,aAAKA,SAAL;AACD;AACF,KAZD;;AAcA,WAAO,KAAKT,UAAZ;AACD;;AAED;;;AAGAS,cAAY;AACV,QAAI,kBAAOd,aAAP,CAAqB,MAArB,IAA+B,CAAnC,EAAsC;AACpC,yBAASC,QAAT,CAAkBC,QAAQC,MAA1B,EAAkC,CAAlC;AACA,yBAASY,SAAT,CAAmBb,QAAQC,MAA3B;AACD;;AAEDa,kBAAc,KAAKtB,aAAnB;AACD;AA1E6B;kBAAXf,U","file":"PushStream.js","sourcesContent":["import readline from 'readline';\nimport Logger from 'gulplog';\nimport filter from 'gulp-filter';\nimport FileToAtviseFileTransformer from '../../transform/FileToAtviseFileTransformer';\nimport NodeFileStream from '../push/NodeFileStream';\nimport WriteStream from '../push/WriteStream';\nimport CreateNodeStream from '../push/CreateNodeStream';\nimport AddReferenceStream from '../push/AddReferenceStream';\n\n/**\n * A stream that transforms read {@link vinyl~File}s and pushes them to atvise server.\n */\nexport default class PushStream {\n\n  /**\n   * Creates a new PushSteam based on the given options.\n   * @param {Object} options The stream configuration options.\n   * @param {NodeId[]} [options.nodesToPush] The nodes to push.\n   * @param {Boolean} [options.createNodes] Defines if nodes shall be created or not.\n   */\n  constructor(options = {}) {\n    /**\n     * Defines shall be created or not.\n     * @type {Boolean}\n     */\n    const createNodesOnPush = options.createNodes || false;\n\n    /**\n     * The nodes to push\n     * @type {NodeId[]}\n     */\n    const nodesToPush = options.nodesToPush || [];\n\n    const fileTransformer = new FileToAtviseFileTransformer({ nodesToTransform: nodesToPush });\n    const atvReferenceFilter = filter(file => !file.isAtviseReferenceConfig, { restore: true });\n    const nodeFileStream = new NodeFileStream({ createNodes: createNodesOnPush });\n    const createNodeStream = new CreateNodeStream();\n    const writeStream = new WriteStream({ createNodes: createNodesOnPush });\n\n    this.printProgress = setInterval(() => {\n      Logger.info(\n      `Pushed: ${writeStream._processed} (${writeStream.opsPerSecond.toFixed(1)} ops/s)`\n      );\n\n      if (Logger.listenerCount('info') > 0) {\n        readline.cursorTo(process.stdout, 0);\n        readline.moveCursor(process.stdout, 0, -1);\n      }\n    }, 1000);\n\n    this.pushStream = fileTransformer\n      .pipe(atvReferenceFilter)\n      .pipe(nodeFileStream)\n      .pipe(writeStream);\n\n    if (createNodesOnPush) {\n      this.pushStream.pipe(createNodeStream);\n    }\n\n    this.pushStream.once('finish', () => {\n      Logger.debug('Writing and creating nodes finished. Adding references...');\n\n      if (createNodesOnPush && atvReferenceFilter.restore._readableState.buffer.length > 0) {\n        const addReferenceStream = new AddReferenceStream();\n\n        this.pushStream.pipe(atvReferenceFilter.restore)\n          .pipe(addReferenceStream)\n          .on('finish', () => this.endStream());\n      } else {\n        this.endStream();\n      }\n    });\n\n    return this.pushStream;\n  }\n\n  /**\n   * Stops the print progress when push stream has finished and stops the push task process\n   */\n  endStream() {\n    if (Logger.listenerCount('info') > 0) {\n      readline.cursorTo(process.stdout, 0);\n      readline.clearLine(process.stdout);\n    }\n\n    clearInterval(this.printProgress);\n  }\n}\n"]}