{"version":3,"sources":["../../../src/lib/gulp/src.js"],"names":["readdir","_readdir","stat","_stat","readFile","_readFile","FileNode","SourceNode","constructor","name","parent","nodeClass","nodeId","references","dataType","arrayType","value","NodeClass","Variable","specialId","Object","entries","forEach","ref","ids","type","ReferenceTypeIds","id","addReference","_resolvedReferences","DataType","VariantArrayType","stringValue","_rawValue","toString","variantValue","SourceBrowser","path","base","ignoreNodes","recursive","_sourceNodesRegExp","RegExp","ProjectConfig","nodes","map","replace","join","_rootNodePaths","Set","n","split","_ignoreNodesRegExp","_isStopped","_isDestroyed","_ended","_readNodes","_isDir","_path","_base","_recursive","_nextToBrowse","_nextToStat","_nextToRead","_waitingForParent","_discoveredNodes","Map","_pushedNodes","_dependingNodes","_dependencies","then","_processQueues","catch","err","onError","_nextInQueue","queue","count","Math","min","length","splice","_processQueue","handler","input","Promise","resolve","_browse","dirs","all","dir","files","file","push","_isDefinitionFile","match","_isNonVarFile","t","slice","Boolean","_parentNodePath","_isRootNodePath","parentPath","has","test","paths","s","isDirectory","add","isFile","concat","_read","contents","_discoveredNode","definitions","JSON","parse","node","get","Error","_pushNode","bind","keys","onEnd","rel","assign","relative","set","dependencyCount","toParent","reference","_readNodeValue","onNode","waiting","p","dependents","dep","destroy","stop","start","shift","SourceStream","Readable","options","objectMode","highWaterMark","_browser","isDestroyed","emit","_destroy","callback","destroyErr","src","getAbsolute","process","cwd","undefined"],"mappings":"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","sourcesContent":["import { Readable } from 'stream';\nimport { readdir as _readdir, stat as _stat, readFile as _readFile } from 'fs';\nimport { promisify } from 'util';\nimport { join, basename, dirname, relative, isAbsolute } from 'path';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport { DataType, VariantArrayType } from 'node-opcua';\nimport { SourceNode, ReferenceTypeIds } from '../model/Node';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport { decodeVariant } from '../coding';\n\n/** Browses the given directory @type {function(path: string): Promise<string[]>} */\nconst readdir = promisify(_readdir);\n\n/** Stats the given file @type {function(file: string): Promise<fs~Stat>} */\nconst stat = promisify(_stat);\n\n/** Reads the given file @type {function(file: string): Promise<Buffer>} */\nconst readFile = promisify(_readFile);\n\n/**\n * A node returned by the {@link SourceStream}.\n */\nexport class FileNode extends SourceNode {\n\n  /**\n   * Creates a new node.\n   * @param {Object} options The options to use.\n   */\n  constructor({ name, parent, nodeClass, nodeId, references, dataType, arrayType }) {\n    super({ name, parent, nodeClass });\n\n    /**\n     * A node's value (may be incomplete, use {@link FileNode#variantValue} to ensure).\n     * @type {node-opcua~Variant}\n     */\n    this.value = {};\n\n    if (nodeClass) {\n      /**\n       * The node's class.\n       * @type {node-opcua~NodeClass}\n       * */\n      this.nodeClass = NodeClass[nodeClass];\n    } else {\n      this.nodeClass = NodeClass.Variable;\n    }\n\n    if (nodeId) {\n      /**\n       * The id stored in the definition file\n       * @type {NodeId}\n      */\n      this.specialId = nodeId;\n    }\n\n    if (references) {\n      Object.entries(references).forEach(([ref, ids]) => {\n        const type = ReferenceTypeIds[ref];\n\n        ids.forEach(id => {\n          this.references.addReference(type, id);\n          this._resolvedReferences.addReference(type, id);\n        });\n      });\n    }\n\n    if (dataType) {\n      this.value.dataType = DataType[dataType];\n    }\n\n    if (arrayType) {\n      this.value.arrayType = VariantArrayType[arrayType];\n    }\n  }\n\n  /**\n   * A node's raw value, decoded into a string.\n   * @type {string}\n   */\n  get stringValue() {\n    return this._rawValue.toString();\n  }\n\n  /**\n   * A node's {@link node-opcua~Variant} value.\n   * @type {node-opcua~Variant}\n   */\n  get variantValue() {\n    const value = this.value;\n\n    if (!value.value) {\n      value.value = decodeVariant(this._rawValue, value);\n    }\n\n    return value;\n  }\n\n}\n\n/**\n * A stream that browses the file system and returns {@link Node}s from the read files.\n */\nexport class SourceBrowser {\n\n  /**\n   * Creates a new browser.\n   * @param {Object} options The options to use.\n   * @param {string} options.path The path to browse for.\n   * @param {string} [options.base] The base directory to use (defaults to './src').\n   * @param {NodeId[]} [options.ignoreNodes] The nodes to ignore (defaults to the ones in the\n   * project config.\n   * @param {boolean} [options.recursive=true] If the browser shoud recurse directories.\n   */\n  constructor({ path, base, ignoreNodes, recursive }) {\n    /**\n     * A regular expression matching all nodes specified in {@link ProjectConfig.nodes}.\n     */\n    this._sourceNodesRegExp = new RegExp(`^(${ProjectConfig.nodes\n      .map(({ value }) => `${value.replace(/\\./g, '\\\\.')}`)\n      .join('|')})`);\n\n    /**\n     * A set of the paths specified in {@link ProjectConfig.nodes}.\n     */\n    this._rootNodePaths = new Set(ProjectConfig.nodes\n      .map(n => join(...n.value.split('.'), '.Object.json')));\n\n    /**\n     * A regular expression matching all nodes specified in {@link ProjectConfig.nodes}.\n     */\n    this._ignoreNodesRegExp = new RegExp(`^(${ignoreNodes || ProjectConfig.ignoreNodes\n      .map(n => n.value)\n      .join('|')})`);\n\n    /** If the browser is stopped. @type {boolean} */\n    this._isStopped = true;\n    /** If the browser is destoyed. @type {boolean} */\n    this._isDestroyed = false;\n    /** If the browser has ended. @type {boolean} */\n    this._ended = false;\n    /** Nodes discovered and read but not yet pushed. @type {FileNode[]} */\n    this._readNodes = [];\n\n    /** The directories discovered. @type {Set<string>} */\n    this._isDir = new Set();\n    /** The source path. @type {string} */\n    this._path = path;\n    /** The base path. @type {string} */\n    this._base = base;\n    /** If the browser should recurse directores. @type {boolean} */\n    this._recursive = recursive;\n    /** The browse queue. @type {string[]} */\n    this._nextToBrowse = [];\n    /** The stat queue. @type {string[]} */\n    this._nextToStat = [];\n    /** The read queue. @type {string[]} */\n    this._nextToRead = [];\n\n    /** Nodes waiting for it's parent to be pushed. @type {Map<string, string[]>} */\n    this._waitingForParent = {};\n    /** Nodes discovered but not read yet. @type {Map<string, FileNode>} */\n    this._discoveredNodes = new Map();\n    /** Paths of nodes already pushed. @type {Set<string>} */\n    this._pushedNodes = new Set();\n    /** Nodes that depend on others to be pushed. @type {Map<string, Set<FileNode>>} */\n    this._dependingNodes = {};\n    /** Numbers of dependencies for nodes at path. @type {Map<string, number>} */\n    this._dependencies = {};\n\n    this._stat([this._base])\n      .then(() => this._processQueues())\n      .catch(err => this.onError(err));\n  }\n\n  /**\n   * Picks the next items from a queue.\n   * @param {any[]} queue The queue to pick from.\n   */\n  _nextInQueue(queue) {\n    const count = Math.min(queue.length, 50);\n    return queue.splice(0, count);\n  }\n\n  /**\n   * Processes the next items in a queue.\n   * @param {any[]} queue The queue to process.\n   * @param {function(input: any[]): Promise<any>} handler The handler to use.\n   */\n  _processQueue(queue, handler) {\n    const input = this._nextInQueue(queue);\n\n    if (!input.length) {\n      return Promise.resolve();\n    }\n\n    return handler(input)\n      .then(() => this._processQueue(queue, handler));\n  }\n\n  /**\n   * Browses the specified directories.\n   * @param {string[]} dirs The directories to browse.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  _browse(dirs) {\n    return Promise.all(dirs\n      .map(dir => readdir(dir)\n        .then(files => files.forEach(file => {\n          this._nextToStat.push(join(dir, file));\n        }))\n      )\n    );\n  }\n\n  /**\n   * Returns `true` for all definition file paths.\n   * @param {string} path The path to check.\n   * @return {boolean} If the item at the given path is a definition file.\n   */\n  _isDefinitionFile(path) {\n    return basename(path).match(/^\\..*\\.json$/);\n  }\n\n  /**\n   * Returns `true` for all non-variable definition file paths.\n   * @param {string} path The pach to check.\n   * @return {boolean} If the item at the given path is a definition file.\n   */\n  _isNonVarFile(path) {\n    const t = basename(path).slice(1).replace(/\\.json$/, '');\n\n    if (t.length < 4) { return false; }\n\n    return Boolean(NodeClass[t]);\n  }\n\n  /**\n   * Returns the path to the parent node.\n   * @param {string} path The path to use.\n   * @return {string} The parent node's path.\n   */\n  _parentNodePath(path) {\n    let dir = dirname(path);\n\n    if (this._isNonVarFile(path)) {\n      dir = dirname(dir);\n    }\n\n    return dir.replace(/.inner$/, '');\n  }\n\n  /**\n   * Returns `true` for all root node paths.\n   * @param {string} path The path to check.\n   * @param {string} parentPath The parent path to check.\n   * @return {boolean} If the node at *path* is a root node.\n   */\n  _isRootNodePath(path, parentPath) {\n    if (parentPath === this._base) { return true; }\n\n    const name = relative(this._base, path);\n\n    if (this._rootNodePaths.has(name)) { return true; }\n\n    // MARK: Only works with compact mapping applied, update once configurable.\n    // FIXME: Needs a more general solution.\n    // eslint-disable-next-line max-len\n    return /^(AGENT|SYSTEM|ObjectTypes.PROJECT|VariableTypes.PROJECT).\\.(Object|ObjectType|VariableType)?.json$/.test(name);\n  }\n\n  /**\n   * Stats the given paths.\n   * @param {string[]} paths The paths to stat.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  _stat(paths) {\n    return Promise.all(paths\n      .map(path => stat(path)\n        .then(s => {\n          if (s.isDirectory()) {\n            this._isDir.add(path);\n\n            if (\n              this._path.split(path).length > 1 || // browse up to source node\n              (this._recursive && path.split(this._path).length > 1) // browse children if recursive\n            ) {\n              this._nextToBrowse.push(path);\n            }\n          } else if (s.isFile()) {\n            if (this._isDefinitionFile(path)) {\n              const parentPath = this._parentNodePath(path);\n              if (this._isRootNodePath(path, parentPath) || this._pushedNodes.has(parentPath)) {\n                this._nextToRead.push(path);\n              } else {\n                this._waitingForParent[parentPath] = (this._waitingForParent[parentPath] || [])\n                  .concat(path);\n              }\n            } // Got a regular / variable value file\n          }\n        })\n      )\n    );\n  }\n\n  /**\n   * Reads the given files.\n   * @param {string[]} paths Reads the files at the given paths.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  _read(paths) {\n    return Promise.all(paths\n      .map(path => readFile(path)\n        .then(contents => {\n          if (this._isDefinitionFile(path)) {\n            this._discoveredNode({ path, definitions: JSON.parse(contents.toString()) });\n          } else {\n            const node = this._discoveredNodes.get(path);\n\n            if (!node) {\n              throw new Error(`Unknown node at ${path}`);\n            }\n\n            node._rawValue = contents;\n            this._pushNode(node);\n          }\n        })\n      )\n    );\n  }\n\n  /**\n   * Processes the next itmems in all queues.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  async _processQueues() {\n    if (this._isDestroyed) { return true; }\n\n    await Promise.all([\n      this._processQueue(this._nextToBrowse, this._browse.bind(this)),\n      this._processQueue(this._nextToStat, this._stat.bind(this)),\n      this._processQueue(this._nextToRead, this._read.bind(this)),\n    ]);\n\n    if (this._nextToBrowse.length || this._nextToStat.length || this._nextToRead.length) {\n      return this._processQueues();\n    }\n\n    if (this._isStopped) {\n      this._ended = true;\n      return true;\n    }\n\n    if (Object.keys(this._dependingNodes).length) {\n      throw new Error('Unmapped nodes');\n    }\n\n    if (Object.keys(this._waitingForParent).length) {\n      throw new Error('Unmapped nodes');\n    }\n\n    if (Object.keys(this._dependencies).length) {\n      throw new Error('Unmapped nodes');\n    }\n\n    return this.onEnd();\n  }\n\n  // Dependency management\n\n  /**\n   * Invoced once a new node has been discovered. Queues it behind it's parents if needed, otherwise\n   * marks it for reading.\n   * @param {Object} options The discovered node.\n   * @param {string} options.path The node's path.\n   * @param {Object} options.definitions The node's definitions.\n   */\n  _discoveredNode({ path: _path, definitions }) {\n    let path = _path;\n    let name = basename(path).slice(1).replace(/\\.json$/, '');\n\n    if (name.length >= 4 && NodeClass[name]) {\n      path = dirname(path);\n      name = basename(path);\n    }\n\n    const dir = dirname(path);\n    const parentPath = this._parentNodePath(path);\n    const rel = join(dir, name);\n    const node = new FileNode(Object.assign({\n      name,\n      parent: this._discoveredNodes.get(parentPath),\n    }, definitions));\n    node.relative = rel;\n    this._discoveredNodes.set(rel, node);\n\n    let dependencyCount = 0;\n\n    if (!this._pushedNodes.has(parentPath) && !this._isRootNodePath(_path, parentPath)) {\n      throw new Error(`'${path}' was pushed before parent node`);\n    }\n\n    for (const [type, references] of node.references.entries()) {\n      if (type !== ReferenceTypeIds.toParent) {\n        for (const reference of references) {\n          if (\n            type !== ReferenceTypeIds.toParent && // parents are handled via _waitingForParent\n            !this._pushedNodes.has(reference) && // hasn't been processed yet\n            this._sourceNodesRegExp.test(reference) && // is included in project config\n            !this._ignoreNodesRegExp.test(reference) // is not ignored in project config\n          ) {\n            this._dependingNodes[reference] = this._dependingNodes[reference] || [];\n            this._dependingNodes[reference].push(node);\n            dependencyCount += 1;\n          }\n        }\n      }\n    }\n\n    if (dependencyCount) { // has deps\n      this._dependencies[node.nodeId] = dependencyCount;\n    } else {\n      this._readNodeValue(node);\n    }\n  }\n\n  /**\n   * Marks a variable node for reading or pushes it if non-var.\n   * @param {FileNode} node The node to read the value of.\n   */\n  _readNodeValue(node) {\n    if (node.nodeClass === NodeClass.Variable && !this._isDir.has(node.relative)) {\n      this._nextToRead.push(node.relative);\n    } else {\n      this._pushNode(node);\n    }\n  }\n\n  /**\n   * Pushes a node and queues it's dependents.\n   * @param {FileNode} node The node to push.\n   */\n  _pushNode(node) {\n    this._pushedNodes.add(node.relative);\n    this._pushedNodes.add(node.nodeId);\n    this.onNode(node);\n\n    // FIXME: Only while debugging\n    /*\n    if (!node.parent && ![\n      'AGENT',\n      'SYSTEM',\n      'VariableTypes.PROJECT',\n      'ObjectTypes.PROJECT',\n    ].includes(node.nodeId)) {\n      throw new Error(`Node '${node.nodeId}' has no parent node`);\n    }\n    */\n\n    const waiting = this._waitingForParent[node.relative];\n    if (waiting) {\n      waiting.forEach(p => {\n        this._nextToRead.push(p);\n      });\n\n      delete this._waitingForParent[node.relative];\n    }\n\n    const dependents = this._dependingNodes[node.nodeId];\n\n    if (dependents) {\n      dependents.forEach(dep => {\n        this._dependencies[dep.nodeId]--;\n\n        if (this._dependencies[dep.nodeId] === 0) {\n          this._readNodeValue(dep);\n          delete this._dependencies[dep.nodeId];\n        } // else: dependent has other dependencies as well\n      });\n\n      delete this._dependingNodes[node.nodeId];\n    }\n  }\n\n  /**\n   * Destroys the browser.\n   */\n  async destroy() {\n    this.stop();\n    this._isDestroyed = true;\n  }\n\n  /**\n   * Invoced to start the browser pushing nodes.\n   */\n  start() {\n    this._isStopped = false;\n\n    while (this._readNodes.length) {\n      this.onNode(this._readNodes.shift());\n      if (this._isStopped) { break; }\n    }\n\n    if (!this._readNodes.length && this._ended) {\n      this.onEnd();\n    }\n  }\n\n  /**\n   * Prevents the browser to push nodes.\n   */\n  stop() {\n    this._isStopped = true;\n  }\n\n}\n\n/**\n * A stream writing {@link FileNode}s.\n */\nexport class SourceStream extends Readable {\n\n  /**\n   * Creates a new steam.\n   * @param {Object} options The options to use.\n   * @see {SourceBrowser#constructor}\n   */\n  constructor(options) {\n    super(Object.assign(options, { objectMode: true, highWaterMark: 10000 }));\n\n    /**\n     * If the stream is destoryed.\n     * @type {boolean}\n     */\n    this._isDestroyed = false;\n\n    /**\n     * The stream's file system browser.\n     * @type {SourceBrowser}\n     */\n    this._browser = new SourceBrowser(options);\n\n    this._browser.onNode = node => {\n      if (!this.push(node)) { this._browser.stop(); }\n    };\n\n    this._browser.onEnd = () => {\n      this.push(null);\n      this.destroy();\n    };\n\n    this._browser.onError = err => {\n      if (this.isDestroyed) { return; }\n      this.emit('error', err);\n      this.destroy();\n    };\n  }\n\n  /**\n   * If the stream is destroyed.\n   * @type {boolean}\n   */\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n\n  /**\n   * Starts the browser.\n   */\n  _read() {\n    this._browser.start();\n  }\n\n  /**\n   * Destoys the stream and it's browser.\n   * @param {?Error} err The error that caused the destroy.\n   * @param {function(err: ?Error)} callback Called once finished.\n   */\n  _destroy(err, callback) {\n    this._isDestroyed = true;\n\n    super.destroy(err, () => {\n      this._browser.destroy()\n        .then(() => callback(err))\n        .catch(destroyErr => callback(err || destroyErr));\n    });\n  }\n\n}\n\n/**\n * Returns a {@link SourceStream} for the given path.\n * @param {string} path The path to read from.\n * @param {Object} options Options passed to the {@link SourceStream}.\n * @return {SourceStream} The source stream.\n */\nexport default function src(path, options = {}) {\n  const getAbsolute = rel => (isAbsolute(rel) ? rel : join(process.cwd(), rel));\n\n  return new SourceStream(Object.assign(options, {\n    path: getAbsolute(path),\n    base: getAbsolute(options.base || './src'), // FIXME: Take from config file\n    recursive: options.recursive === undefined ? true : options.recursive,\n  }));\n}\n"],"file":"src.js"}