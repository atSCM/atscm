{"version":3,"sources":["../../../src/lib/gulp/src.js"],"names":["readdir","_readdir","stat","_stat","readFile","_readFile","FileNode","SourceNode","constructor","name","parent","nodeClass","nodeId","references","dataType","arrayType","value","NodeClass","Variable","specialId","Object","entries","forEach","ref","ids","type","ReferenceTypeIds","id","addReference","_resolvedReferences","DataType","VariantArrayType","stringValue","_rawValue","toString","variantValue","SourceBrowser","path","base","ignoreNodes","recursive","_sourceNodesRegExp","RegExp","ProjectConfig","nodes","map","replace","join","_ignoreNodesRegExp","n","_isStopped","_isDestroyed","_ended","_readNodes","_isDir","Set","_path","_base","_recursive","_nextToBrowse","_nextToStat","_nextToRead","_waitingForParent","_discoveredNodes","Map","_pushedNodes","_dependingNodes","_dependencies","then","_processQueues","catch","err","onError","_nextInQueue","queue","count","Math","min","length","splice","_processQueue","handler","input","Promise","resolve","_browse","dirs","all","dir","files","file","push","_isDefinitionFile","match","_isNonVarFile","t","slice","Boolean","_parentNodePath","_isRootNodePath","test","paths","s","isDirectory","add","split","isFile","parentPath","has","concat","_read","contents","_discoveredNode","definitions","JSON","parse","node","get","Error","_pushNode","bind","keys","onEnd","rel","assign","relative","set","dependencyCount","toParent","reference","_readNodeValue","onNode","waiting","p","dependents","dep","destroy","stop","start","shift","SourceStream","Readable","options","objectMode","highWaterMark","_browser","isDestroyed","emit","_destroy","callback","destroyErr","src","getAbsolute","process","cwd","undefined"],"mappings":"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","sourcesContent":["import { Readable } from 'stream';\nimport { readdir as _readdir, stat as _stat, readFile as _readFile } from 'fs';\nimport { promisify } from 'util';\nimport { join, basename, dirname, relative, isAbsolute } from 'path';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport { DataType, VariantArrayType } from 'node-opcua';\nimport { SourceNode, ReferenceTypeIds } from '../model/Node';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport { decodeVariant } from '../coding';\n\n/** Browses the given directory @type {function(path: string): Promise<string[]>} */\nconst readdir = promisify(_readdir);\n\n/** Stats the given file @type {function(file: string): Promise<fs~Stat>} */\nconst stat = promisify(_stat);\n\n/** Reads the given file @type {function(file: string): Promise<Buffer>} */\nconst readFile = promisify(_readFile);\n\n/**\n * A node returned by the {@link SourceStream}.\n */\nexport class FileNode extends SourceNode {\n\n  /**\n   * Creates a new node.\n   * @param {Object} options The options to use.\n   */\n  constructor({ name, parent, nodeClass, nodeId, references, dataType, arrayType }) {\n    super({ name, parent, nodeClass });\n\n    /**\n     * A node's value (may be incomplete, use {@link FileNode#variantValue} to ensure).\n     * @type {node-opcua~Variant}\n     */\n    this.value = {};\n\n    if (nodeClass) {\n      /**\n       * The node's class.\n       * @type {node-opcua~NodeClass}\n       * */\n      this.nodeClass = NodeClass[nodeClass];\n    } else {\n      this.nodeClass = NodeClass.Variable;\n    }\n\n    if (nodeId) {\n      /**\n       * The id stored in the definition file\n       * @type {NodeId}\n      */\n      this.specialId = nodeId;\n    }\n\n    if (references) {\n      Object.entries(references).forEach(([ref, ids]) => {\n        const type = ReferenceTypeIds[ref];\n\n        ids.forEach(id => {\n          this.references.addReference(type, id);\n          this._resolvedReferences.addReference(type, id);\n        });\n      });\n    }\n\n    if (dataType) {\n      this.value.dataType = DataType[dataType];\n    }\n\n    if (arrayType) {\n      this.value.arrayType = VariantArrayType[arrayType];\n    }\n  }\n\n  /**\n   * A node's raw value, decoded into a string.\n   * @type {string}\n   */\n  get stringValue() {\n    return this._rawValue.toString();\n  }\n\n  /**\n   * A node's {@link node-opcua~Variant} value.\n   * @type {node-opcua~Variant}\n   */\n  get variantValue() {\n    const value = this.value;\n\n    if (!value.value) {\n      value.value = decodeVariant(this._rawValue, value);\n    }\n\n    return value;\n  }\n\n}\n\n/**\n * A stream that browses the file system and returns {@link Node}s from the read files.\n */\nexport class SourceBrowser {\n\n  /**\n   * Creates a new browser.\n   * @param {Object} options The options to use.\n   * @param {string} options.path The path to browse for.\n   * @param {string} [options.base] The base directory to use (defaults to './src').\n   * @param {NodeId[]} [options.ignoreNodes] The nodes to ignore (defaults to the ones in the\n   * project config.\n   * @param {boolean} [options.recursive=true] If the browser shoud recurse directories.\n   */\n  constructor({ path, base, ignoreNodes, recursive }) {\n    /**\n     * A regular expression matching all nodes specified in {@link ProjectConfig.nodes}.\n     */\n    this._sourceNodesRegExp = new RegExp(`^(${ProjectConfig.nodes\n      .map(({ value }) => `${value.replace(/\\./g, '\\\\.')}`)\n      .join('|')})`);\n\n    /**\n     * A regular expression matching all nodes specified in {@link ProjectConfig.nodes}.\n     */\n    this._ignoreNodesRegExp = new RegExp(`^(${ignoreNodes || ProjectConfig.ignoreNodes\n      .map(n => n.value)\n      .join('|')})`);\n\n    /** If the browser is stopped. @type {boolean} */\n    this._isStopped = true;\n    /** If the browser is destoyed. @type {boolean} */\n    this._isDestroyed = false;\n    /** If the browser has ended. @type {boolean} */\n    this._ended = false;\n    /** Nodes discovered and read but not yet pushed. @type {FileNode[]} */\n    this._readNodes = [];\n\n    /** The directories discovered. @type {Set<string>} */\n    this._isDir = new Set();\n    /** The source path. @type {string} */\n    this._path = path;\n    /** The base path. @type {string} */\n    this._base = base;\n    /** If the browser should recurse directores. @type {boolean} */\n    this._recursive = recursive;\n    /** The browse queue. @type {string[]} */\n    this._nextToBrowse = [];\n    /** The stat queue. @type {string[]} */\n    this._nextToStat = [];\n    /** The read queue. @type {string[]} */\n    this._nextToRead = [];\n\n    /** Nodes waiting for it's parent to be pushed. @type {Map<string, string[]>} */\n    this._waitingForParent = {};\n    /** Nodes discovered but not read yet. @type {Map<string, FileNode>} */\n    this._discoveredNodes = new Map();\n    /** Paths of nodes already pushed. @type {Set<string>} */\n    this._pushedNodes = new Set();\n    /** Nodes that depend on others to be pushed. @type {Map<string, Set<FileNode>>} */\n    this._dependingNodes = {};\n    /** Numbers of dependencies for nodes at path. @type {Map<string, number>} */\n    this._dependencies = {};\n\n    this._stat([this._base])\n      .then(() => this._processQueues())\n      .catch(err => this.onError(err));\n  }\n\n  /**\n   * Picks the next items from a queue.\n   * @param {any[]} queue The queue to pick from.\n   */\n  _nextInQueue(queue) {\n    const count = Math.min(queue.length, 50);\n    return queue.splice(0, count);\n  }\n\n  /**\n   * Processes the next items in a queue.\n   * @param {any[]} queue The queue to process.\n   * @param {function(input: any[]): Promise<any>} handler The handler to use.\n   */\n  _processQueue(queue, handler) {\n    const input = this._nextInQueue(queue);\n\n    if (!input.length) {\n      return Promise.resolve();\n    }\n\n    return handler(input)\n      .then(() => this._processQueue(queue, handler));\n  }\n\n  /**\n   * Browses the specified directories.\n   * @param {string[]} dirs The directories to browse.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  _browse(dirs) {\n    return Promise.all(dirs\n      .map(dir => readdir(dir)\n        .then(files => files.forEach(file => {\n          this._nextToStat.push(join(dir, file));\n        }))\n      )\n    );\n  }\n\n  /**\n   * Returns `true` for all definition file paths.\n   * @param {string} path The path to check.\n   * @return {boolean} If the item at the given path is a definition file.\n   */\n  _isDefinitionFile(path) {\n    return basename(path).match(/^\\..*\\.json$/);\n  }\n\n  /**\n   * Returns `true` for all non-variable definition file paths.\n   * @param {string} path The pach to check.\n   * @return {boolean} If the item at the given path is a definition file.\n   */\n  _isNonVarFile(path) {\n    const t = basename(path).slice(1).replace(/\\.json$/, '');\n\n    if (t.length < 4) { return false; }\n\n    return Boolean(NodeClass[t]);\n  }\n\n  /**\n   * Returns the path to the parent node.\n   * @param {string} path The path to use.\n   * @return {string} The parent node's path.\n   */\n  _parentNodePath(path) {\n    let dir = dirname(path);\n\n    if (this._isNonVarFile(path)) {\n      dir = dirname(dir);\n    }\n\n    return dir.replace(/.inner$/, '');\n  }\n\n  /**\n   * Returns `true` for all root node paths.\n   * @param {string} path The path to check.\n   * @return {boolean} If the node at *path* is a root node.\n   */\n  _isRootNodePath(path) {\n    const name = relative(this._base, path);\n\n    // MARK: Only works with compact mapping applied, update once configurable.\n    // FIXME: Needs a more general solution.\n    // eslint-disable-next-line max-len\n    return /^(AGENT|SYSTEM|ObjectTypes.PROJECT|VariableTypes.PROJECT).\\.(Object|ObjectType|VariableType)?.json$/.test(name);\n  }\n\n  /**\n   * Stats the given paths.\n   * @param {string[]} paths The paths to stat.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  _stat(paths) {\n    return Promise.all(paths\n      .map(path => stat(path)\n        .then(s => {\n          if (s.isDirectory()) {\n            this._isDir.add(path);\n\n            if (\n              this._path.split(path).length > 1 || // browse up to source node\n              (this._recursive && path.split(this._path).length > 1) // browse children if recursive\n            ) {\n              this._nextToBrowse.push(path);\n            }\n          } else if (s.isFile()) {\n            if (this._isDefinitionFile(path)) {\n              const parentPath = this._parentNodePath(path);\n              if (this._isRootNodePath(path) || this._pushedNodes.has(parentPath)) {\n                this._nextToRead.push(path);\n              } else {\n                this._waitingForParent[parentPath] = (this._waitingForParent[parentPath] || [])\n                  .concat(path);\n              }\n            } // Got a regular / variable value file\n          }\n        })\n      )\n    );\n  }\n\n  /**\n   * Reads the given files.\n   * @param {string[]} paths Reads the files at the given paths.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  _read(paths) {\n    return Promise.all(paths\n      .map(path => readFile(path)\n        .then(contents => {\n          if (this._isDefinitionFile(path)) {\n            this._discoveredNode({ path, definitions: JSON.parse(contents.toString()) });\n          } else {\n            const node = this._discoveredNodes.get(path);\n\n            if (!node) {\n              throw new Error(`Unknown node at ${path}`);\n            }\n\n            node._rawValue = contents;\n            this._pushNode(node);\n          }\n        })\n      )\n    );\n  }\n\n  /**\n   * Processes the next itmems in all queues.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  async _processQueues() {\n    if (this._isDestroyed) { return true; }\n\n    await Promise.all([\n      this._processQueue(this._nextToBrowse, this._browse.bind(this)),\n      this._processQueue(this._nextToStat, this._stat.bind(this)),\n      this._processQueue(this._nextToRead, this._read.bind(this)),\n    ]);\n\n    if (this._nextToBrowse.length || this._nextToStat.length || this._nextToRead.length) {\n      return this._processQueues();\n    }\n\n    if (this._isStopped) {\n      this._ended = true;\n      return true;\n    }\n\n    if (Object.keys(this._dependingNodes).length) {\n      throw new Error('Unmapped nodes');\n    }\n\n    if (Object.keys(this._waitingForParent).length) {\n      throw new Error('Unmapped nodes');\n    }\n\n    if (Object.keys(this._dependencies).length) {\n      throw new Error('Unmapped nodes');\n    }\n\n    return this.onEnd();\n  }\n\n  // Dependency management\n\n  /**\n   * Invoced once a new node has been discovered. Queues it behind it's parents if needed, otherwise\n   * marks it for reading.\n   * @param {Object} options The discovered node.\n   * @param {string} options.path The node's path.\n   * @param {Object} options.definitions The node's definitions.\n   */\n  _discoveredNode({ path: _path, definitions }) {\n    let path = _path;\n    let name = basename(path).slice(1).replace(/\\.json$/, '');\n\n    if (name.length >= 4 && NodeClass[name]) {\n      path = dirname(path);\n      name = basename(path);\n    }\n\n    const dir = dirname(path);\n    const parentPath = this._parentNodePath(path);\n    const rel = join(dir, name);\n    const node = new FileNode(Object.assign({\n      name,\n      parent: this._discoveredNodes.get(parentPath),\n    }, definitions));\n    node.relative = rel;\n    this._discoveredNodes.set(rel, node);\n\n    let dependencyCount = 0;\n\n    if (!this._pushedNodes.has(parentPath) && !this._isRootNodePath(_path)) {\n      throw new Error(`'${path}' was pushed before parent node`);\n    }\n\n    for (const [type, references] of node.references.entries()) {\n      if (type !== ReferenceTypeIds.toParent) {\n        for (const reference of references) {\n          if (\n            type !== ReferenceTypeIds.toParent && // parents are handled via _waitingForParent\n            !this._pushedNodes.has(reference) && // hasn't been processed yet\n            this._sourceNodesRegExp.test(reference) && // is included in project config\n            !this._ignoreNodesRegExp.test(reference) // is not ignored in project config\n          ) {\n            this._dependingNodes[reference] = this._dependingNodes[reference] || [];\n            this._dependingNodes[reference].push(node);\n            dependencyCount += 1;\n          }\n        }\n      }\n    }\n\n    if (dependencyCount) { // has deps\n      this._dependencies[node.nodeId] = dependencyCount;\n    } else {\n      this._readNodeValue(node);\n    }\n  }\n\n  /**\n   * Marks a variable node for reading or pushes it if non-var.\n   * @param {FileNode} node The node to read the value of.\n   */\n  _readNodeValue(node) {\n    if (node.nodeClass === NodeClass.Variable && !this._isDir.has(node.relative)) {\n      this._nextToRead.push(node.relative);\n    } else {\n      this._pushNode(node);\n    }\n  }\n\n  /**\n   * Pushes a node and queues it's dependents.\n   * @param {FileNode} node The node to push.\n   */\n  _pushNode(node) {\n    this._pushedNodes.add(node.relative);\n    this._pushedNodes.add(node.nodeId);\n    this.onNode(node);\n\n    // FIXME: Only while debugging\n    /*\n    if (!node.parent && ![\n      'AGENT',\n      'SYSTEM',\n      'VariableTypes.PROJECT',\n      'ObjectTypes.PROJECT',\n    ].includes(node.nodeId)) {\n      throw new Error(`Node '${node.nodeId}' has no parent node`);\n    }\n    */\n\n    const waiting = this._waitingForParent[node.relative];\n    if (waiting) {\n      waiting.forEach(p => {\n        this._nextToRead.push(p);\n      });\n\n      delete this._waitingForParent[node.relative];\n    }\n\n    const dependents = this._dependingNodes[node.nodeId];\n\n    if (dependents) {\n      dependents.forEach(dep => {\n        this._dependencies[dep.nodeId]--;\n\n        if (this._dependencies[dep.nodeId] === 0) {\n          this._readNodeValue(dep);\n          delete this._dependencies[dep.nodeId];\n        } // else: dependent has other dependencies as well\n      });\n\n      delete this._dependingNodes[node.nodeId];\n    }\n  }\n\n  /**\n   * Destroys the browser.\n   */\n  async destroy() {\n    this.stop();\n    this._isDestroyed = true;\n  }\n\n  /**\n   * Invoced to start the browser pushing nodes.\n   */\n  start() {\n    this._isStopped = false;\n\n    while (this._readNodes.length) {\n      this.onNode(this._readNodes.shift());\n      if (this._isStopped) { break; }\n    }\n\n    if (!this._readNodes.length && this._ended) {\n      this.onEnd();\n    }\n  }\n\n  /**\n   * Prevents the browser to push nodes.\n   */\n  stop() {\n    this._isStopped = true;\n  }\n\n}\n\n/**\n * A stream writing {@link FileNode}s.\n */\nexport class SourceStream extends Readable {\n\n  /**\n   * Creates a new steam.\n   * @param {Object} options The options to use.\n   * @see {SourceBrowser#constructor}\n   */\n  constructor(options) {\n    super(Object.assign(options, { objectMode: true, highWaterMark: 10000 }));\n\n    /**\n     * If the stream is destoryed.\n     * @type {boolean}\n     */\n    this._isDestroyed = false;\n\n    /**\n     * The stream's file system browser.\n     * @type {SourceBrowser}\n     */\n    this._browser = new SourceBrowser(options);\n\n    this._browser.onNode = node => {\n      if (!this.push(node)) { this._browser.stop(); }\n    };\n\n    this._browser.onEnd = () => {\n      this.push(null);\n      this.destroy();\n    };\n\n    this._browser.onError = err => {\n      if (this.isDestroyed) { return; }\n      this.emit('error', err);\n      this.destroy();\n    };\n  }\n\n  /**\n   * If the stream is destroyed.\n   * @type {boolean}\n   */\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n\n  /**\n   * Starts the browser.\n   */\n  _read() {\n    this._browser.start();\n  }\n\n  /**\n   * Destoys the stream and it's browser.\n   * @param {?Error} err The error that caused the destroy.\n   * @param {function(err: ?Error)} callback Called once finished.\n   */\n  _destroy(err, callback) {\n    this._isDestroyed = true;\n\n    super.destroy(err, () => {\n      this._browser.destroy()\n        .then(() => callback(err))\n        .catch(destroyErr => callback(err || destroyErr));\n    });\n  }\n\n}\n\n/**\n * Returns a {@link SourceStream} for the given path.\n * @param {string} path The path to read from.\n * @param {Object} options Options passed to the {@link SourceStream}.\n * @return {SourceStream} The source stream.\n */\nexport default function src(path, options = {}) {\n  const getAbsolute = rel => (isAbsolute(rel) ? rel : join(process.cwd(), rel));\n\n  return new SourceStream(Object.assign(options, {\n    path: getAbsolute(path),\n    base: getAbsolute(options.base || './src'), // FIXME: Take from config file\n    recursive: options.recursive === undefined ? true : options.recursive,\n  }));\n}\n"],"file":"src.js"}