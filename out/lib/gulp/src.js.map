{"version":3,"sources":["../../../src/lib/gulp/src.js"],"names":["src","readdir","stat","readFile","FileNode","constructor","name","parent","nodeClass","nodeId","references","dataType","arrayType","value","Variable","specialId","Object","entries","forEach","ref","ids","type","id","addReference","_resolvedReferences","stringValue","_rawValue","toString","variantValue","SourceBrowser","path","base","ignoreNodes","recursive","_sourceNodesRegExp","RegExp","nodes","map","replace","join","_ignoreNodesRegExp","n","_isStopped","_isDestroyed","_ended","_readNodes","_isDir","Set","_path","_base","_recursive","_nextToBrowse","_nextToStat","_nextToRead","_waitingForParent","_discoveredNodes","Map","_pushedNodes","_dependingNodes","_dependencies","_stat","then","_processQueues","catch","err","onError","_nextInQueue","queue","count","Math","min","length","splice","_processQueue","handler","input","Promise","resolve","_browse","dirs","all","dir","files","file","push","_isDefinitionFile","match","_isNonVarFile","t","slice","Boolean","_parentNodePath","_isRootNodePath","test","paths","s","isDirectory","add","split","isFile","parentPath","has","concat","_read","contents","_discoveredNode","definitions","JSON","parse","node","get","Error","_pushNode","bind","keys","onEnd","rel","assign","relative","set","dependencyCount","toParent","reference","_readNodeValue","onNode","waiting","p","dependents","dep","destroy","stop","start","shift","SourceStream","options","objectMode","highWaterMark","_browser","isDestroyed","emit","_destroy","callback","destroyErr","getAbsolute","process","cwd","undefined"],"mappings":"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","file":"src.js","sourcesContent":["import { Readable } from 'stream';\nimport { readdir as _readdir, stat as _stat, readFile as _readFile } from 'fs';\nimport { promisify } from 'util';\nimport { join, basename, dirname, relative, isAbsolute } from 'path';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport { DataType, VariantArrayType } from 'node-opcua';\nimport { SourceNode, ReferenceTypeIds } from '../model/Node';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport { decodeVariant } from '../coding';\n\n/** Browses the given directory @type {function(path: string): Promise<string[]>} */\nconst readdir = promisify(_readdir);\n\n/** Stats the given file @type {function(file: string): Promise<fs~Stat>} */\nconst stat = promisify(_stat);\n\n/** Reads the given file @type {function(file: string): Promise<Buffer>} */\nconst readFile = promisify(_readFile);\n\n/**\n * A node returned by the {@link SourceStream}.\n */\nexport class FileNode extends SourceNode {\n\n  /**\n   * Creates a new node.\n   * @param {Object} options The options to use.\n   */\n  constructor({ name, parent, nodeClass, nodeId, references, dataType, arrayType }) {\n    super({ name, parent, nodeClass });\n\n    /**\n     * A node's value (may be incomplete, use {@link FileNode#variantValue} to ensure).\n     * @type {node-opcua~Variant}\n     */\n    this.value = {};\n\n    if (nodeClass) {\n      /**\n       * The node's class.\n       * @type {node-opcua~NodeClass}\n       * */\n      this.nodeClass = NodeClass[nodeClass];\n    } else {\n      this.nodeClass = NodeClass.Variable;\n    }\n\n    if (nodeId) {\n      /**\n       * The id stored in the definition file\n       * @type {NodeId}\n      */\n      this.specialId = nodeId;\n    }\n\n    if (references) {\n      Object.entries(references).forEach(([ref, ids]) => {\n        const type = ReferenceTypeIds[ref];\n\n        ids.forEach(id => {\n          this.references.addReference(type, id);\n          this._resolvedReferences.addReference(type, id);\n        });\n      });\n    }\n\n    if (dataType) {\n      this.value.dataType = DataType[dataType];\n    }\n\n    if (arrayType) {\n      this.value.arrayType = VariantArrayType[arrayType];\n    }\n  }\n\n  /**\n   * A node's raw value, decoded into a string.\n   * @type {string}\n   */\n  get stringValue() {\n    return this._rawValue.toString();\n  }\n\n  /**\n   * A node's {@link node-opcua~Variant} value.\n   * @type {node-opcua~Variant}\n   */\n  get variantValue() {\n    const value = this.value;\n\n    if (!value.value) {\n      value.value = decodeVariant(this._rawValue, value);\n    }\n\n    return value;\n  }\n\n}\n\n/**\n * A stream that browses the file system and returns {@link Node}s from the read files.\n */\nexport class SourceBrowser {\n\n  /**\n   * Creates a new browser.\n   * @param {Object} options The options to use.\n   * @param {string} options.path The path to browse for.\n   * @param {string} [options.base] The base directory to use (defaults to './src').\n   * @param {NodeId[]} [options.ignoreNodes] The nodes to ignore (defaults to the ones in the\n   * project config.\n   * @param {boolean} [options.recursive=true] If the browser shoud recurse directories.\n   */\n  constructor({ path, base, ignoreNodes, recursive }) {\n    /**\n     * A regular expression matching all nodes specified in {@link ProjectConfig.nodes}.\n     */\n    this._sourceNodesRegExp = new RegExp(`^(${ProjectConfig.nodes\n      .map(({ value }) => `${value.replace(/\\./g, '\\\\.')}`)\n      .join('|')})`);\n\n    /**\n     * A regular expression matching all nodes specified in {@link ProjectConfig.nodes}.\n     */\n    this._ignoreNodesRegExp = new RegExp(`^(${ignoreNodes || ProjectConfig.ignoreNodes\n      .map(n => n.value)\n      .join('|')})`);\n\n    /** If the browser is stopped. @type {boolean} */\n    this._isStopped = true;\n    /** If the browser is destoyed. @type {boolean} */\n    this._isDestroyed = false;\n    /** If the browser has ended. @type {boolean} */\n    this._ended = false;\n    /** Nodes discovered and read but not yet pushed. @type {FileNode[]} */\n    this._readNodes = [];\n\n    /** The directories discovered. @type {Set<string>} */\n    this._isDir = new Set();\n    /** The source path. @type {string} */\n    this._path = path;\n    /** The base path. @type {string} */\n    this._base = base;\n    /** If the browser should recurse directores. @type {boolean} */\n    this._recursive = recursive;\n    /** The browse queue. @type {string[]} */\n    this._nextToBrowse = [];\n    /** The stat queue. @type {string[]} */\n    this._nextToStat = [];\n    /** The read queue. @type {string[]} */\n    this._nextToRead = [];\n\n    /** Nodes waiting for it's parent to be pushed. @type {Map<string, string[]>} */\n    this._waitingForParent = {};\n    /** Nodes discovered but not read yet. @type {Map<string, FileNode>} */\n    this._discoveredNodes = new Map();\n    /** Paths of nodes already pushed. @type {Set<string>} */\n    this._pushedNodes = new Set();\n    /** Nodes that depend on others to be pushed. @type {Map<string, Set<FileNode>>} */\n    this._dependingNodes = {};\n    /** Numbers of dependencies for nodes at path. @type {Map<string, number>} */\n    this._dependencies = {};\n\n    this._stat([this._base])\n      .then(() => this._processQueues())\n      .catch(err => this.onError(err));\n  }\n\n  /**\n   * Picks the next items from a queue.\n   * @param {any[]} queue The queue to pick from.\n   */\n  _nextInQueue(queue) {\n    const count = Math.min(queue.length, 50);\n    return queue.splice(0, count);\n  }\n\n  /**\n   * Processes the next items in a queue.\n   * @param {any[]} queue The queue to process.\n   * @param {function(input: any[]): Promise<any>} handler The handler to use.\n   */\n  _processQueue(queue, handler) {\n    const input = this._nextInQueue(queue);\n\n    if (!input.length) {\n      return Promise.resolve();\n    }\n\n    return handler(input)\n      .then(() => this._processQueue(queue, handler));\n  }\n\n  /**\n   * Browses the specified directories.\n   * @param {string[]} dirs The directories to browse.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  _browse(dirs) {\n    return Promise.all(dirs\n      .map(dir => readdir(dir)\n        .then(files => files.forEach(file => {\n          this._nextToStat.push(join(dir, file));\n        }))\n      )\n    );\n  }\n\n  /**\n   * Returns `true` for all definition file paths.\n   * @param {string} path The path to check.\n   * @return {boolean} If the item at the given path is a definition file.\n   */\n  _isDefinitionFile(path) {\n    return basename(path).match(/^\\..*\\.json$/);\n  }\n\n  /**\n   * Returns `true` for all non-variable definition file paths.\n   * @param {string} path The pach to check.\n   * @return {boolean} If the item at the given path is a definition file.\n   */\n  _isNonVarFile(path) {\n    const t = basename(path).slice(1).replace(/\\.json$/, '');\n\n    if (t.length < 4) { return false; }\n\n    return Boolean(NodeClass[t]);\n  }\n\n  /**\n   * Returns the path to the parent node.\n   * @param {string} path The path to use.\n   * @return {string} The parent node's path.\n   */\n  _parentNodePath(path) {\n    let dir = dirname(path);\n\n    if (this._isNonVarFile(path)) {\n      dir = dirname(dir);\n    }\n\n    return dir.replace(/.inner$/, '');\n  }\n\n  /**\n   * Returns `true` for all root node paths.\n   * @param {string} path The path to check.\n   * @return {boolean} If the node at *path* is a root node.\n   */\n  _isRootNodePath(path) {\n    const name = relative(this._base, path);\n\n    // MARK: Only works with compact mapping applied, update once configurable.\n    // FIXME: Needs a more general solution.\n    // eslint-disable-next-line max-len\n    return /^(AGENT|SYSTEM|ObjectTypes.PROJECT|VariableTypes.PROJECT).\\.(Object|ObjectType|VariableType)?.json$/.test(name);\n  }\n\n  /**\n   * Stats the given paths.\n   * @param {string[]} paths The paths to stat.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  _stat(paths) {\n    return Promise.all(paths\n      .map(path => stat(path)\n        .then(s => {\n          if (s.isDirectory()) {\n            this._isDir.add(path);\n\n            if (\n              this._path.split(path).length > 1 || // browse up to source node\n              (this._recursive && path.split(this._path).length > 1) // browse children if recursive\n            ) {\n              this._nextToBrowse.push(path);\n            }\n          } else if (s.isFile()) {\n            if (this._isDefinitionFile(path)) {\n              const parentPath = this._parentNodePath(path);\n              if (this._isRootNodePath(path) || this._pushedNodes.has(parentPath)) {\n                this._nextToRead.push(path);\n              } else {\n                this._waitingForParent[parentPath] = (this._waitingForParent[parentPath] || [])\n                  .concat(path);\n              }\n            } // Got a regular / variable value file\n          }\n        })\n      )\n    );\n  }\n\n  /**\n   * Reads the given files.\n   * @param {string[]} paths Reads the files at the given paths.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  _read(paths) {\n    return Promise.all(paths\n      .map(path => readFile(path)\n        .then(contents => {\n          if (this._isDefinitionFile(path)) {\n            this._discoveredNode({ path, definitions: JSON.parse(contents.toString()) });\n          } else {\n            const node = this._discoveredNodes.get(path);\n\n            if (!node) {\n              throw new Error(`Unknown node at ${path}`);\n            }\n\n            node._rawValue = contents;\n            this._pushNode(node);\n          }\n        })\n      )\n    );\n  }\n\n  /**\n   * Processes the next itmems in all queues.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  async _processQueues() {\n    if (this._isDestroyed) { return true; }\n\n    await Promise.all([\n      this._processQueue(this._nextToBrowse, this._browse.bind(this)),\n      this._processQueue(this._nextToStat, this._stat.bind(this)),\n      this._processQueue(this._nextToRead, this._read.bind(this)),\n    ]);\n\n    if (this._nextToBrowse.length || this._nextToStat.length || this._nextToRead.length) {\n      return this._processQueues();\n    }\n\n    if (this._isStopped) {\n      this._ended = true;\n      return true;\n    }\n\n    if (Object.keys(this._dependingNodes).length) {\n      throw new Error('Unmapped nodes');\n    }\n\n    if (Object.keys(this._waitingForParent).length) {\n      throw new Error('Unmapped nodes');\n    }\n\n    if (Object.keys(this._dependencies).length) {\n      throw new Error('Unmapped nodes');\n    }\n\n    return this.onEnd();\n  }\n\n  // Dependency management\n\n  /**\n   * Invoced once a new node has been discovered. Queues it behind it's parents if needed, otherwise\n   * marks it for reading.\n   * @param {Object} options The discovered node.\n   * @param {string} options.path The node's path.\n   * @param {Object} options.definitions The node's definitions.\n   */\n  _discoveredNode({ path: _path, definitions }) {\n    let path = _path;\n    let name = basename(path).slice(1).replace(/\\.json$/, '');\n\n    if (name.length >= 4 && NodeClass[name]) {\n      path = dirname(path);\n      name = basename(path);\n    }\n\n    const dir = dirname(path);\n    const parentPath = this._parentNodePath(path);\n    const rel = join(dir, name);\n    const node = new FileNode(Object.assign({\n      name,\n      parent: this._discoveredNodes.get(parentPath),\n    }, definitions));\n    node.relative = rel;\n    this._discoveredNodes.set(rel, node);\n\n    let dependencyCount = 0;\n\n    if (!this._pushedNodes.has(parentPath) && !this._isRootNodePath(_path)) {\n      throw new Error(`'${path}' was pushed before parent node`);\n    }\n\n    for (const [type, references] of node.references.entries()) {\n      if (type !== ReferenceTypeIds.toParent) {\n        for (const reference of references) {\n          if (\n            type !== ReferenceTypeIds.toParent && // parents are handled via _waitingForParent\n            !this._pushedNodes.has(reference) && // hasn't been processed yet\n            this._sourceNodesRegExp.test(reference) && // is included in project config\n            !this._ignoreNodesRegExp.test(reference) // is not ignored in project config\n          ) {\n            this._dependingNodes[reference] = this._dependingNodes[reference] || [];\n            this._dependingNodes[reference].push(node);\n            dependencyCount += 1;\n          }\n        }\n      }\n    }\n\n    if (dependencyCount) { // has deps\n      this._dependencies[node.nodeId] = dependencyCount;\n    } else {\n      this._readNodeValue(node);\n    }\n  }\n\n  /**\n   * Marks a variable node for reading or pushes it if non-var.\n   * @param {FileNode} node The node to read the value of.\n   */\n  _readNodeValue(node) {\n    if (node.nodeClass === NodeClass.Variable && !this._isDir.has(node.relative)) {\n      this._nextToRead.push(node.relative);\n    } else {\n      this._pushNode(node);\n    }\n  }\n\n  /**\n   * Pushes a node and queues it's dependents.\n   * @param {FileNode} node The node to push.\n   */\n  _pushNode(node) {\n    this._pushedNodes.add(node.relative);\n    this._pushedNodes.add(node.nodeId);\n    this.onNode(node);\n\n    // FIXME: Only while debugging\n    /*\n    if (!node.parent && ![\n      'AGENT',\n      'SYSTEM',\n      'VariableTypes.PROJECT',\n      'ObjectTypes.PROJECT',\n    ].includes(node.nodeId)) {\n      throw new Error(`Node '${node.nodeId}' has no parent node`);\n    }\n    */\n\n    const waiting = this._waitingForParent[node.relative];\n    if (waiting) {\n      waiting.forEach(p => {\n        this._nextToRead.push(p);\n      });\n\n      delete this._waitingForParent[node.relative];\n    }\n\n    const dependents = this._dependingNodes[node.nodeId];\n\n    if (dependents) {\n      dependents.forEach(dep => {\n        this._dependencies[dep.nodeId]--;\n\n        if (this._dependencies[dep.nodeId] === 0) {\n          this._readNodeValue(dep);\n          delete this._dependencies[dep.nodeId];\n        } // else: dependent has other dependencies as well\n      });\n\n      delete this._dependingNodes[node.nodeId];\n    }\n  }\n\n  /**\n   * Destroys the browser.\n   */\n  async destroy() {\n    this.stop();\n    this._isDestroyed = true;\n  }\n\n  /**\n   * Invoced to start the browser pushing nodes.\n   */\n  start() {\n    this._isStopped = false;\n\n    while (this._readNodes.length) {\n      this.onNode(this._readNodes.shift());\n      if (this._isStopped) { break; }\n    }\n\n    if (!this._readNodes.length && this._ended) {\n      this.onEnd();\n    }\n  }\n\n  /**\n   * Prevents the browser to push nodes.\n   */\n  stop() {\n    this._isStopped = true;\n  }\n\n}\n\n/**\n * A stream writing {@link FileNode}s.\n */\nexport class SourceStream extends Readable {\n\n  /**\n   * Creates a new steam.\n   * @param {Object} options The options to use.\n   * @see {SourceBrowser#constructor}\n   */\n  constructor(options) {\n    super(Object.assign(options, { objectMode: true, highWaterMark: 10000 }));\n\n    /**\n     * If the stream is destoryed.\n     * @type {boolean}\n     */\n    this._isDestroyed = false;\n\n    /**\n     * The stream's file system browser.\n     * @type {SourceBrowser}\n     */\n    this._browser = new SourceBrowser(options);\n\n    this._browser.onNode = node => {\n      if (!this.push(node)) { this._browser.stop(); }\n    };\n\n    this._browser.onEnd = () => {\n      this.push(null);\n      this.destroy();\n    };\n\n    this._browser.onError = err => {\n      if (this.isDestroyed) { return; }\n      this.emit('error', err);\n      this.destroy();\n    };\n  }\n\n  /**\n   * If the stream is destroyed.\n   * @type {boolean}\n   */\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n\n  /**\n   * Starts the browser.\n   */\n  _read() {\n    this._browser.start();\n  }\n\n  /**\n   * Destoys the stream and it's browser.\n   * @param {?Error} err The error that caused the destroy.\n   * @param {function(err: ?Error)} callback Called once finished.\n   */\n  _destroy(err, callback) {\n    this._isDestroyed = true;\n\n    super.destroy(err, () => {\n      this._browser.destroy()\n        .then(() => callback(err))\n        .catch(destroyErr => callback(err || destroyErr));\n    });\n  }\n\n}\n\n/**\n * Returns a {@link SourceStream} for the given path.\n * @param {string} path The path to read from.\n * @param {Object} options Options passed to the {@link SourceStream}.\n * @return {SourceStream} The source stream.\n */\nexport default function src(path, options = {}) {\n  const getAbsolute = rel => (isAbsolute(rel) ? rel : join(process.cwd(), rel));\n\n  return new SourceStream(Object.assign(options, {\n    path: getAbsolute(path),\n    base: getAbsolute(options.base || './src'), // FIXME: Take from config file\n    recursive: options.recursive === undefined ? true : options.recursive,\n  }));\n}\n"]}