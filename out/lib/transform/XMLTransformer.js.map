{"version":3,"sources":["../../../src/lib/transform/XMLTransformer.js"],"names":["XMLTransformer","constructor","options","build","object","buildOptions","declaration","Object","assign","attributes","version","encoding","standalone","attributeValueFn","val","replace","_fromDBBuilder","compact","spaces","_fromFilesystemBuilder","xml","builder","direction","FromDB","decodeContents","file","callback","contents","e","encodeContents","isElement","type","isElementWithName","name","tagName","findChildren","node","elements","filter","child","findChild","i","length","removeChildren","removed","push","removeChild","splice","textContent","contentNode"],"mappings":"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","file":"XMLTransformer.js","sourcesContent":["import { xml2js, js2xml } from 'xml-js';\nimport { TransformDirection } from './Transformer';\nimport SplittingTransformer from './SplittingTransformer';\n\n/**\n * A transformer used to transform XML documents.\n */\nexport default class XMLTransformer extends SplittingTransformer {\n\n  /**\n   * Creates a new XMLTransformer based on some options.\n   * @param {Object} options The options to use.\n   */\n  constructor(options) {\n    super(options);\n\n    function build(object, buildOptions) {\n      if (!object.declaration) {\n        Object.assign(object, {\n          declaration: {\n            attributes: { version: '1.0', encoding: 'UTF-8', standalone: 'no' },\n          },\n        });\n      }\n\n      return js2xml(object, Object.assign(buildOptions, {\n        attributeValueFn(val) {\n          return val\n            .replace(/&(?!amp;)/g, '&amp;')\n            .replace(/</g, '&lt;');\n        },\n      }));\n    }\n\n    // eslint-disable-next-line jsdoc/require-param\n    /**\n     * The builder to use with direction {@link TransformDirection.FromDB}.\n     * @type {function(object: Object): string}\n     */\n    this._fromDBBuilder = object => build(object, { compact: false, spaces: 2 });\n\n    // eslint-disable-next-line jsdoc/require-param\n    /**\n     * The builder to use with direction {@link TransformDirection.FromFilesystem}.\n     * @type {function(object: Object): string}\n     */\n    this._fromFilesystemBuilder = object => {\n      const xml = build(object, { compact: false, spaces: 1 });\n      return xml.replace(/\\r?\\n/g, '\\r\\n');\n    };\n  }\n\n  /**\n   * Returns the XML builder to use based on the current {@link Transformer#direction}.\n   * @type {function(object: Object): string}\n   */\n  get builder() {\n    return this.direction === TransformDirection.FromDB ?\n      this._fromDBBuilder :\n      this._fromFilesystemBuilder;\n  }\n\n  /**\n   * Parses XML in a file's contents.\n   * @param {AtviseFile} file The file to process.\n   * @param {function(err: ?Error, result: ?Object)} callback Called with the parsed document or the\n   * parse error that occurred.\n   */\n  decodeContents(file, callback) {\n    try {\n      callback(null, xml2js(file.contents, { compact: false }));\n    } catch (e) {\n      callback(e);\n    }\n  }\n\n  /**\n   * Builds an XML string from an object.\n   * @param {Object} object The object to encode.\n   * @param {function(err: ?Error, result: ?String)} callback Called with the resulting string or\n   * the error that occurred while building.\n   */\n  encodeContents(object, callback) {\n    try {\n      callback(null, this.builder(object));\n    } catch (e) {\n      callback(e);\n    }\n  }\n\n  /**\n   * Tells if the given parsed XML node is an element (not a text / cdata node).\n   * @param {Object} node The parsed node.\n   * @return {boolean} `true` if the node has type 'element'.\n   */\n  isElement({ type }) {\n    return type === 'element';\n  }\n\n  /** Tells if the given parsed XML node is an elment and has the given tag name.\n   * @param {Object} node The parsed node.\n   * @param {string} tagName The tag name to check for.\n   * @return {boolean} `true` if the node is an element with the given tag name.\n   */\n  isElementWithName({ type, name }, tagName) {\n    return this.isElement({ type }) && name === tagName;\n  }\n\n  /**\n   * Returns a node's child elements with the given tag name.\n   * @param {Object} node The node to check in.\n   * @param {string} tagName The tag name to search for.\n   * @return {Object[]} The matching child elements.\n   */\n  findChildren(node, tagName) {\n    if (!node || !node.elements) { return []; }\n\n    return node.elements.filter(child => this.isElementWithName(child, tagName));\n  }\n\n  /**\n   * Returns a node's first child element with the given tag name, or `null`.\n   * @param {Object} node The node to check in.\n   * @param {string} tagName The tag name to search for.\n   * @return {Object?} The matching child elements.\n   */\n  findChild(node, tagName) {\n    if (!node || !node.elements) { return null; }\n\n    for (let i = 0; i < node.elements.length; i++) {\n      if (this.isElementWithName(node.elements[i], tagName)) {\n        return node.elements[i];\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns and removes a node's child elements with the given tag name.\n   * @param {Object} node The node to check in.\n   * @param {string} tagName The tag name to search for.\n   * @return {Object[]} The matching child elements.\n   */\n  removeChildren(node, tagName) {\n    if (!node || !node.elements) { return []; }\n\n    const removed = [];\n\n    // eslint-disable-next-line no-param-reassign\n    node.elements = node.elements.filter(child => {\n      if (this.isElementWithName(child, tagName)) {\n        removed.push(child);\n        return false;\n      }\n      return true;\n    });\n\n    return removed;\n  }\n\n  /**\n   * Returns and removes a node's first child element with the given tag name, if no match is found\n   * `null` is returned.\n   * @param {Object} node The node to check in.\n   * @param {string} tagName The tag name to search for.\n   * @return {Object?} The matching child elements.\n   */\n  removeChild(node, tagName) {\n    if (!node || !node.elements) { return null; }\n\n    for (let i = 0; i < node.elements.length; i++) {\n      if (this.isElementWithName(node.elements[i], tagName)) {\n        return node.elements.splice(i, 1)[0];\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns a parsed node's text content. Works for 'text' and 'cdata' nodes.\n   * @param {Object} node The parsedNode.\n   * @return {string?} The nodes text content.\n   */\n  textContent(node) {\n    if (!node || !node.elements) { return null; }\n\n    const contentNode = node.elements[0];\n\n    // FIXME: Only works for { type: 'text', text: 'value' } and { type: 'cdata', cdata: 'data' }\n    return contentNode[contentNode.type];\n  }\n\n}\n"]}