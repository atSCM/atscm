{"version":3,"sources":["../../../src/lib/transform/Transformer.js"],"names":["TransformDirection","FromDB","FromFilesystem","isValidDirection","direction","includes","Transformer","objectMode","constructor","options","_options","Error","withDirection","_processError","err","chunk","callback","args","id","nodeId","relative","toString","message","name","process","env","CONTINUE_ON_FAILURE","error","_transform","enc","processError","transformFromDB","transformFromFilesystem","applyToStream","stream","pipe","applyTransformers","transformers","length","reverse","reduce","prev","curr","inspect","depth","newOptions","stylize","replace","repeat"],"mappings":"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","file":"Transformer.js","sourcesContent":["import { inspect } from 'util';\nimport { ctor as throughStreamClass } from 'through2';\nimport Logger from 'gulplog';\n\n/**\n * The directions a transformer can be run in.\n * @type {{FromDB: string, FromFilesystem: string}}\n */\nexport const TransformDirection = {\n  FromDB: 'FromDB',\n  FromFilesystem: 'FromFilesystem',\n};\n\n/**\n * Checks if the given string is a valid {@link TransformDirection}.\n * @param {string} direction The direction string to check.\n * @return {boolean} `true` if the direction is valid.\n */\nfunction isValidDirection(direction) {\n  return [\n    TransformDirection.FromDB,\n    TransformDirection.FromFilesystem,\n  ].includes(direction);\n}\n\n/**\n * A special kind of an object transform stream: It does apply different transformations based on\n * it's direction.\n * @abstract\n */\nexport default class Transformer extends throughStreamClass({ objectMode: true }) {\n\n  /**\n   * Creates a new Transformer with the specified options.\n   * @param {Object} [options] The options to use.\n   * @param {TransformDirection} [options.direction] The direction to use.\n   * @throws {Error} Throws an error if the given direction is invalid.\n   */\n  constructor(options = {}) {\n    super();\n\n    /**\n     * The options the transformer was created with. Used for printing description.\n     * @type {Object}\n     */\n    this._options = options;\n\n    if (options.direction) {\n      if (isValidDirection(options.direction)) {\n        /**\n         * The transformer's direction\n         * @type {TransformerDirection}\n         */\n        this.direction = options.direction;\n      } else {\n        throw new Error('Invalid direction');\n      }\n    }\n  }\n\n  /**\n   * Returns the Transformer with the given direction.\n   * @param {TransformDirection} direction The direction to use.\n   * @return {Transformer} Itself, to be chainable.\n   * @throws {Error} Throws an error if the given direction is invalid.\n   */\n  withDirection(direction) {\n    if (!isValidDirection(direction)) {\n      throw new Error('Invalid direction');\n    }\n\n    this.direction = direction;\n    return this;\n  }\n\n  _processError(err, chunk, callback, ...args) {\n    if (err) {\n      const id = (this.direction === TransformDirection.FromDB ?\n        chunk.nodeId :\n        chunk.relative) || chunk.toString();\n\n      // eslint-disable-next-line no-param-reassign\n      err.message = `[${this.constructor.name}] ${err.message} (in ${id})`;\n\n      if (process.env.CONTINUE_ON_FAILURE === 'true') {\n        Logger.error(err.message);\n        callback(null);\n      } else {\n        callback(err);\n      }\n    } else {\n      callback(err, ...args);\n    }\n  }\n\n  /**\n   * Calls {@link Transformer#transformFromDB} or {@link Transformer#transformFromFilesystem}\n   * based on the transformer's direction.\n   * @param {Object} chunk The chunk to transform.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error, obj: ?Object)} callback Called with the error that occured while\n   * transforming or (optionally) the transformed object.\n   * @throws {Error} Throws an error if the transformer has no valid direction.\n   */\n  _transform(chunk, enc, callback) {\n    const processError = (err, ...args) => this._processError(err, chunk, callback, ...args);\n\n    if (!this.direction) {\n      callback(new Error('Transformer has no direction'));\n    } else if (this.direction === TransformDirection.FromDB) {\n      this.transformFromDB(chunk, enc, processError);\n    } else {\n      this.transformFromFilesystem(chunk, enc, processError);\n    }\n  }\n\n  /**\n   * **Must be overridden by all subclasses:** Transforms the given chunk when using\n   * {@link TransformDirection.FromDB}.\n   * @param {Object} chunk The chunk to transform.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error, obj: ?Object)} callback Called with the error that occured while\n   * transforming or (optionally) the transformed object.\n   */\n  transformFromDB(chunk, enc, callback) {\n    callback(new Error('Transformer#transformFromDB must be overridden by all subclasses'));\n  }\n\n  /**\n   * **Must be overridden by all subclasses:** Transforms the given chunk when using\n   * {@link TransformDirection.FromFilesystem}.\n   * @param {Object} chunk The chunk to transform.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error, obj: ?Object)} callback Called with the error that occured while\n   * transforming or (optionally) the transformed object.\n   */\n  transformFromFilesystem(chunk, enc, callback) {\n    callback(new Error('Transformer#transformFromFilesystem must be overridden by all subclasses'));\n  }\n\n  /**\n   * Applies the transformer to the given stream. By default this just invokes\n   * {@link Transformer#transformFromDB} or {@link Transformer#transformFromFilesystem}. Override\n   * this method if you want to pipe streams directly.\n   * @param {Stream} stream The stream to apply the transformer to.\n   * @param {TransformDirection} direction The direction to use.\n   * @return {Stream} The resulting stream.\n   */\n  applyToStream(stream, direction) {\n    return stream.pipe(this.withDirection(direction));\n  }\n\n  /**\n   * Creates a stream with all transformers passed, with the given direction. Transformers are\n   * reversed if using {@link TransformDirection.FromFilesystem}.\n   * @param {Stream} stream The stream to apply the transformers to.\n   * @param {Transformer[]} transformers The transformers to apply.\n   * @param {TransformDirection} direction The direction to use.\n   * @return {Transformer} The last transformer passed, piped to the previous.\n   */\n  static applyTransformers(stream, transformers, direction) {\n    if (!isValidDirection(direction)) {\n      throw new Error('Direction is invalid');\n    }\n\n    if (transformers.length === 0) {\n      return stream;\n    }\n\n    return (direction === TransformDirection.FromDB ? transformers : transformers.reverse())\n      .reduce((prev, curr) => curr.applyToStream(prev, direction), stream);\n  }\n\n  /**\n   * Prints the transformer.\n   * @param {?Number} depth The depth to inspect.\n   * @param {Object} options See {@link util~inspect} for details.\n   * @return {string} A string representation of the transformer.\n   */\n  inspect(depth, options) {\n    const newOptions = options;\n    newOptions.depth = options.depth === null ? null : options.depth - 1;\n\n    if (depth < 0) {\n      return options.stylize(`[${this.constructor.name}]`, 'special');\n    }\n\n    return `${options.stylize(this.constructor.name, 'special')}${inspect(this._options, newOptions)\n      .replace(/^{/, '<').replace(/}$/, '>')\n      .replace(/\\n/, `\\n${' '.repeat(this.constructor.name.length)}`)\n    }`;\n  }\n\n}\n"]}