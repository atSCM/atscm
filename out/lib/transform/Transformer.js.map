{"version":3,"sources":["../../../src/lib/transform/Transformer.js"],"names":["TransformDirection","FromDB","FromFilesystem","isValidDirection","direction","includes","Transformer","combinedTransformer","transformers","directed","map","t","withDirection","reverse","node","context","transformer","compatTransform","undefined","constructor","Error","readNodeFile","transformFromDB","transformFromFilesystem","transform","bind","fnName","name","Promise","resolve","reject","promise","err","result","_warnedStreamAPI","Logger","debug","Object","assign","then","length"],"mappings":"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","sourcesContent":["import Logger from 'gulplog';\n\n/**\n * The directions a transformer can be run in.\n * @type {{FromDB: string, FromFilesystem: string}}\n */\nexport const TransformDirection = {\n  FromDB: 'FromDB',\n  FromFilesystem: 'FromFilesystem',\n};\n\n/**\n * Checks if the given string is a valid {@link TransformDirection}.\n * @param {string} direction The direction string to check.\n * @return {boolean} `true` if the direction is valid.\n */\nfunction isValidDirection(direction) {\n  return [\n    TransformDirection.FromDB,\n    TransformDirection.FromFilesystem,\n  ].includes(direction);\n}\n\n/**\n * The base transformer class.\n * @abstract\n */\nexport default class Transformer {\n\n  /**\n   * Returns a function that combines multiple transformer actions.\n   * @param {Transformer[]} transformers An array of transformers.\n   * @param {TransformDirection} direction The direction to use.\n   * @return {function(node: Node): Promise<any>} The combined transform function.\n   */\n  static combinedTransformer(transformers, direction) {\n    const directed = transformers.map(t => t.withDirection(direction));\n\n    if (direction === TransformDirection.FromFilesystem) { directed.reverse(); }\n\n    return async (node, context) => {\n      for (const transformer of directed) {\n        if (await transformer.compatTransform(direction, node, context) !== undefined) {\n          // break;\n        }\n      }\n    };\n  }\n\n  /**\n   * Creates a new Transformer with the specified options.\n   * @param {Object} [options] The options to use.\n   * @param {TransformDirection} [options.direction] The direction to use.\n   * @throws {Error} Throws an error if the given direction is invalid.\n   */\n  constructor({ direction } = {}) {\n    if (direction) {\n      if (!isValidDirection(direction)) { throw new Error('Invalid direction'); }\n      this.direction = direction;\n    }\n  }\n\n  /**\n   * Returns the Transformer with the given direction.\n   * @param {TransformDirection} direction The direction to use.\n   * @return {Transformer} Itself, to be chainable.\n   * @throws {Error} Throws an error if the given direction is invalid.\n   */\n  withDirection(direction) {\n    if (!isValidDirection(direction)) {\n      throw new Error('Invalid direction');\n    }\n\n    /**\n     * The transformer's direction\n     * @type {TransformerDirection}\n     */\n    this.direction = direction;\n    return this;\n  }\n\n  /**\n   * Determines if a node's value node should be read, e.G. The *Variable.Bool* file for a node\n   * defined in *.Variable.Bool.Json*.\n   * @param {FileNode} node The node to read or not.\n   * @return {boolean?} *true* if the node's value file should be read, undefined to let other\n   * transformers decide.\n   */\n  readNodeFile(node) { // eslint-disable-line no-unused-vars\n    return undefined;\n  }\n\n  /**\n   * **Must be overridden by all subclasses:** Transforms the given node when using\n   * {@link TransformDirection.FromDB}.\n   * @param {BrowsedNode} node The node to split.\n   * @param {Object} context The transform context.\n   */\n  async transformFromDB(node, context) { // eslint-disable-line no-unused-vars\n    throw new Error('Transformer#transformFromDB must be overridden by all subclasses');\n  }\n\n  /**\n   * **Must be overridden by all subclasses:** Transforms the given node when using\n   * {@link TransformDirection.FromFilesystem}.\n   * @param {BrowsedNode} node The node to transform.\n   * @param {Object} context The browser context.\n   */\n  async transformFromFilesystem(node, context) { // eslint-disable-line no-unused-vars\n    throw new Error('Transformer#transformFromFilesystem must be overridden by all subclasses');\n  }\n\n  /**\n   * A transform wrapper that works with both async/await (atscm >= 1) and callback-based\n   * (atscm < 1)transformers.\n   * @param {TransformDirection} direction The direction to use.\n   * @param {Node} node The node to transform.\n   * @param {Object} context The browser context.\n   */\n  compatTransform(direction, node, context) {\n    const transform = (direction === TransformDirection.FromDB ?\n      this.transformFromDB :\n      this.transformFromFilesystem).bind(this);\n\n    const fnName = `${this.constructor.name}#transform${\n      direction === TransformDirection.FromDB ? 'FromDB' : 'FromFilesystem'\n    }`;\n\n    return new Promise((resolve, reject) => {\n      const promise = transform(node, context, (err, result) => {\n        if (!this.constructor._warnedStreamAPI) {\n          this.constructor._warnedStreamAPI = true;\n          Logger.debug(`Deprecated: ${fnName} uses the Stream API instead of async/await.`);\n        }\n        if (err) { return reject(Object.assign(err, { node })); }\n\n        // Handle \"repush\"\n        if (result === node) { return resolve(); }\n\n        return resolve(result);\n      });\n\n      if (promise instanceof Promise) {\n        promise.then(resolve, err => reject(Object.assign(err, { node })));\n      } else if (this.transformFromDB.length < 3) {\n        reject(new Error(`${fnName} did not return a Promise.\n  - Did you forget \\`async\\`?`));\n      }\n    });\n  }\n\n}\n"],"file":"Transformer.js"}