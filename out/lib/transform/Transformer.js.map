{"version":3,"sources":["../../../src/lib/transform/Transformer.js"],"names":["TransformDirection","FromDB","FromFilesystem","isValidDirection","direction","includes","Transformer","objectMode","constructor","options","_options","Error","transformsReferenceConfigFiles","withDirection","_processError","err","chunk","callback","args","id","nodeId","relative","toString","message","name","process","env","CONTINUE_ON_FAILURE","Logger","error","_transform","enc","AtviseFile","isReferenceConfig","processError","transformFromDB","transformFromFilesystem","applyToStream","stream","pipe","applyTransformers","transformers","length","reverse","reduce","prev","curr","inspect","depth","newOptions","stylize","replace","repeat"],"mappings":"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","sourcesContent":["import { inspect } from 'util';\nimport { ctor as throughStreamClass } from 'through2';\nimport Logger from 'gulplog';\nimport AtviseFile from '../server/AtviseFile';\n\n/**\n * The directions a transformer can be run in.\n * @type {{FromDB: string, FromFilesystem: string}}\n */\nexport const TransformDirection = {\n  FromDB: 'FromDB',\n  FromFilesystem: 'FromFilesystem',\n};\n\n/**\n * Checks if the given string is a valid {@link TransformDirection}.\n * @param {string} direction The direction string to check.\n * @return {boolean} `true` if the direction is valid.\n */\nfunction isValidDirection(direction) {\n  return [\n    TransformDirection.FromDB,\n    TransformDirection.FromFilesystem,\n  ].includes(direction);\n}\n\n/**\n * A special kind of an object transform stream: It does apply different transformations based on\n * it's direction.\n * @abstract\n */\nexport default class Transformer extends throughStreamClass({ objectMode: true }) {\n\n  /**\n   * Creates a new Transformer with the specified options.\n   * @param {Object} [options] The options to use.\n   * @param {TransformDirection} [options.direction] The direction to use.\n   * @throws {Error} Throws an error if the given direction is invalid.\n   */\n  constructor(options = {}) {\n    super();\n\n    /**\n     * The options the transformer was created with. Used for printing description.\n     * @type {Object}\n     */\n    this._options = options;\n\n    if (options.direction) {\n      if (isValidDirection(options.direction)) {\n        /**\n         * The transformer's direction\n         * @type {TransformerDirection}\n         */\n        this.direction = options.direction;\n      } else {\n        throw new Error('Invalid direction');\n      }\n    }\n  }\n\n  // eslint-disable-next-line jsdoc/require-description-complete-sentence\n  /**\n   * If reference config files should be handled by the transformer. Override if you want to\n   * transform reference config files (for example `.index.htm.json`).\n   * @type {boolean}\n   */\n  get transformsReferenceConfigFiles() {\n    return false;\n  }\n\n  /**\n   * Returns the Transformer with the given direction.\n   * @param {TransformDirection} direction The direction to use.\n   * @return {Transformer} Itself, to be chainable.\n   * @throws {Error} Throws an error if the given direction is invalid.\n   */\n  withDirection(direction) {\n    if (!isValidDirection(direction)) {\n      throw new Error('Invalid direction');\n    }\n\n    this.direction = direction;\n    return this;\n  }\n\n  /**\n   * Decorates an error that occurred while running a transformer.\n   * @param {Error} err The error to decorate.\n   * @param {*} chunk The chunk (usually an {@link AtviseFile}) beeing processed.\n   * @param {function(err: ?Error)} callback The callback to call on completion.\n   * @param {Array<*>} args Any additional arguments.\n   */\n  _processError(err, chunk, callback, ...args) {\n    if (err) {\n      const id = (this.direction === TransformDirection.FromDB ?\n        chunk.nodeId :\n        chunk.relative) || chunk.toString();\n\n      // eslint-disable-next-line no-param-reassign\n      err.message = `[${this.constructor.name}] ${err.message} (in ${id})`;\n\n      if (process.env.CONTINUE_ON_FAILURE === 'true') {\n        Logger.error(err.message);\n        callback(null);\n      } else {\n        callback(err);\n      }\n    } else {\n      callback(err, ...args);\n    }\n  }\n\n  /**\n   * Calls {@link Transformer#transformFromDB} or {@link Transformer#transformFromFilesystem}\n   * based on the transformer's direction.\n   * @param {Object} chunk The chunk to transform.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error, obj: ?Object)} callback Called with the error that occured while\n   * transforming or (optionally) the transformed object.\n   * @throws {Error} Throws an error if the transformer has no valid direction.\n   */\n  _transform(chunk, enc, callback) {\n    if (!this.transformsReferenceConfigFiles && chunk instanceof AtviseFile &&\n      chunk.isReferenceConfig) {\n      callback(null, chunk);\n      return;\n    }\n    const processError = (err, ...args) => this._processError(err, chunk, callback, ...args);\n\n    if (!this.direction) {\n      callback(new Error('Transformer has no direction'));\n    } else if (this.direction === TransformDirection.FromDB) {\n      this.transformFromDB(chunk, enc, processError);\n    } else {\n      this.transformFromFilesystem(chunk, enc, processError);\n    }\n  }\n\n  /**\n   * **Must be overridden by all subclasses:** Transforms the given chunk when using\n   * {@link TransformDirection.FromDB}.\n   * @param {Object} chunk The chunk to transform.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error, obj: ?Object)} callback Called with the error that occured while\n   * transforming or (optionally) the transformed object.\n   */\n  transformFromDB(chunk, enc, callback) {\n    callback(new Error('Transformer#transformFromDB must be overridden by all subclasses'));\n  }\n\n  /**\n   * **Must be overridden by all subclasses:** Transforms the given chunk when using\n   * {@link TransformDirection.FromFilesystem}.\n   * @param {Object} chunk The chunk to transform.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error, obj: ?Object)} callback Called with the error that occured while\n   * transforming or (optionally) the transformed object.\n   */\n  transformFromFilesystem(chunk, enc, callback) {\n    callback(new Error('Transformer#transformFromFilesystem must be overridden by all subclasses'));\n  }\n\n  /**\n   * Applies the transformer to the given stream. By default this just invokes\n   * {@link Transformer#transformFromDB} or {@link Transformer#transformFromFilesystem}. Override\n   * this method if you want to pipe streams directly.\n   * @param {Stream} stream The stream to apply the transformer to.\n   * @param {TransformDirection} direction The direction to use.\n   * @return {Stream} The resulting stream.\n   */\n  applyToStream(stream, direction) {\n    return stream.pipe(this.withDirection(direction));\n  }\n\n  /**\n   * Creates a stream with all transformers passed, with the given direction. Transformers are\n   * reversed if using {@link TransformDirection.FromFilesystem}.\n   * @param {Stream} stream The stream to apply the transformers to.\n   * @param {Transformer[]} transformers The transformers to apply.\n   * @param {TransformDirection} direction The direction to use.\n   * @return {Transformer} The last transformer passed, piped to the previous.\n   */\n  static applyTransformers(stream, transformers, direction) {\n    if (!isValidDirection(direction)) {\n      throw new Error('Direction is invalid');\n    }\n\n    if (transformers.length === 0) {\n      return stream;\n    }\n\n    return (direction === TransformDirection.FromDB ? transformers : transformers.reverse())\n      .reduce((prev, curr) => curr.applyToStream(prev, direction), stream);\n  }\n\n  /**\n   * Prints the transformer.\n   * @param {?Number} depth The depth to inspect.\n   * @param {Object} options See {@link util~inspect} for details.\n   * @return {string} A string representation of the transformer.\n   */\n  inspect(depth, options) {\n    const newOptions = options;\n    newOptions.depth = options.depth === null ? null : options.depth - 1;\n\n    if (depth < 0) {\n      return options.stylize(`[${this.constructor.name}]`, 'special');\n    }\n\n    return `${options.stylize(this.constructor.name, 'special')}${inspect(this._options, newOptions)\n      .replace(/^{/, '<').replace(/}$/, '>')\n      .replace(/\\n/, `\\n${' '.repeat(this.constructor.name.length)}`)\n    }`;\n  }\n\n}\n"],"file":"Transformer.js"}