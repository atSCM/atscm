{"version":3,"sources":["../../../src/lib/transform/Transformer.js"],"names":["TransformDirection","FromDB","FromFilesystem","isValidDirection","direction","includes","Transformer","objectMode","constructor","options","_options","Error","withDirection","_transform","chunk","enc","callback","transformFromDB","transformFromFilesystem","applyToStream","stream","pipe","applyTransformers","transformers","length","reverse","reduce","prev","curr","inspect","depth","newOptions","stylize","name","replace","repeat"],"mappings":"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","file":"Transformer.js","sourcesContent":["import { inspect } from 'util';\nimport { ctor as throughStreamClass } from 'through2';\n\n/**\n * The directions a transformer can be run in.\n * @type {{FromDB: String, FromFilesystem: String}}\n */\nexport const TransformDirection = {\n  FromDB: 'FromDB',\n  FromFilesystem: 'FromFilesystem',\n};\n\nfunction isValidDirection(direction) {\n  return [\n    TransformDirection.FromDB,\n    TransformDirection.FromFilesystem,\n  ].includes(direction);\n}\n\n/**\n * A special kind of an object transform stream: It does apply different transformations based on\n * it's direction.\n * @abstract\n */\nexport default class Transformer extends throughStreamClass({ objectMode: true }) {\n\n  /**\n   * Creates a new Transformer with the specified options.\n   * @param {Object} [options] The options to use.\n   * @param {TransformDirection} [options.direction] The direction to use.\n   * @throws {Error} Throws an error if the given direction is invalid.\n   */\n  constructor(options = {}) {\n    super();\n\n    /**\n     * The options the transformer was created with. Used for printing description.\n     * @type {Object}\n     */\n    this._options = options;\n\n    if (options.direction) {\n      if (isValidDirection(options.direction)) {\n        /**\n         * The transformer's direction\n         * @type {TransformerDirection}\n         */\n        this.direction = options.direction;\n      } else {\n        throw new Error('Invalid direction');\n      }\n    }\n  }\n\n  /**\n   * Returns the Transformer with the given direction.\n   * @param {TransformDirection} direction The direction to use.\n   * @return {Transformer} Itself, to be chainable.\n   * @throws {Error} Throws an error if the given direction is invalid.\n   */\n  withDirection(direction) {\n    if (!isValidDirection(direction)) {\n      throw new Error('Invalid direction');\n    }\n\n    this.direction = direction;\n    return this;\n  }\n\n  /**\n   * Calls {@link Transformer#transformFromDB} or {@link Transformer#transformFromFilesystem}\n   * based on the transformer's direction.\n   * @param {Object} chunk The chunk to transform.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error, obj: ?Object)} callback Called with the error that occured while\n   * transforming or (optionally) the transformed object.\n   * @throws {Error} Throws an error if the transformer has no valid direction.\n   */\n  _transform(chunk, enc, callback) {\n    if (!this.direction) {\n      callback(new Error('Transformer has no direction'));\n    } else if (this.direction === TransformDirection.FromDB) {\n      this.transformFromDB(chunk, enc, callback);\n    } else {\n      this.transformFromFilesystem(chunk, enc, callback);\n    }\n  }\n\n  /**\n   * **Must be overridden by all subclasses:** Transforms the given chunk when using\n   * {@link TransformDirection.FromDB}.\n   * @param {Object} chunk The chunk to transform.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error, obj: ?Object)} callback Called with the error that occured while\n   * transforming or (optionally) the transformed object.\n   */\n  transformFromDB(chunk, enc, callback) {\n    callback(new Error('Transformer#transformFromDB must be overridden by all subclasses'));\n  }\n\n  /**\n   * **Must be overridden by all subclasses:** Transforms the given chunk when using\n   * {@link TransformDirection.FromFilesystem}.\n   * @param {Object} chunk The chunk to transform.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error, obj: ?Object)} callback Called with the error that occured while\n   * transforming or (optionally) the transformed object.\n   */\n  transformFromFilesystem(chunk, enc, callback) {\n    callback(new Error('Transformer#transformFromFilesystem must be overridden by all subclasses'));\n  }\n\n  /**\n   * Applies the transformer to the given stream. By default this just invokes\n   * {@link Transformer#transformFromDB} or {@link Transformer#transformFromFilesystem}. Override\n   * this method if you want to pipe streams directly.\n   * @param {Stream} stream The stream to apply the transformer to.\n   * @param {TransformDirection} direction The direction to use.\n   * @return {Stream} The resulting stream.\n   */\n  applyToStream(stream, direction) {\n    return stream.pipe(this.withDirection(direction));\n  }\n\n  /**\n   * Creates a stream with all transformers passed, with the given direction. Transformers are\n   * reversed if using {@link TransformDirection.FromFilesystem}.\n   * @param {Stream} stream The stream to apply the transformers to.\n   * @param {Transformer[]} transformers The transformers to apply.\n   * @param {TransformDirection} direction The direction to use.\n   * @return {Transformer} The last transformer passed, piped to the previous.\n   */\n  static applyTransformers(stream, transformers, direction) {\n    if (!isValidDirection(direction)) {\n      throw new Error('Direction is invalid');\n    }\n\n    if (transformers.length === 0) {\n      return stream;\n    }\n\n    return (direction === TransformDirection.FromDB ? transformers : transformers.reverse())\n      .reduce((prev, curr) => curr.applyToStream(prev, direction), stream);\n  }\n\n  /**\n   * Prints the transformer.\n   * @param {?Number} depth The depth to inspect.\n   * @param {Object} options See {@link util~inspect} for details.\n   * @return {string} A string representation of the transformer.\n   */\n  inspect(depth, options) {\n    const newOptions = options;\n    newOptions.depth = options.depth === null ? null : options.depth - 1;\n\n    if (depth < 0) {\n      return options.stylize(`[${this.constructor.name}]`, 'special');\n    }\n\n    return `${options.stylize(this.constructor.name, 'special')}${inspect(this._options, newOptions)\n      .replace(/^{/, '<').replace(/}$/, '>')\n      .replace(/\\n/, `\\n${' '.repeat(this.constructor.name.length)}`)\n    }`;\n  }\n\n}\n"]}