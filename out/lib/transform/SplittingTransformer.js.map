{"version":3,"sources":["../../../src/lib/transform/SplittingTransformer.js"],"names":["CombineFilesCache","constructor","_files","_required","_waitingFor","_wrappers","Map","missingExtensions","dir","required","files","filter","ext","undefined","gotAllFiles","node","callback","relative","wrapper","length","get","wrapperExt","wrapperName","set","err","name","endsWith","match","RegExp","map","hasWrapper","key","has","SplittingTransformer","PartialTransformer","options","_combineFilesCache","shouldBeTransformed","direction","TransformDirection","FromDB","createCombinedFile","sources","Error","transformFromFilesystem","enc","allFiles","splitFile","newExtension","Object","assign","fullyMapped","value","noWrite","createChild","extension","_flush","missingDirnames","keys"],"mappings":"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","sourcesContent":["import { readdir } from 'fs';\nimport { extname, basename, join, dirname } from 'path';\nimport PartialTransformer from './PartialTransformer';\nimport { TransformDirection } from './Transformer';\n\n/**\n * Determines which files are needed to create a combined file and stores these files as long as\n * some of them are missing.\n */\nexport class CombineFilesCache {\n\n  /**\n   * Creates a new DisplayCache.\n   */\n  constructor() {\n    /**\n     * The files caches for the given path.\n     * @type {Map<String, Node>}\n     */\n    this._files = {};\n\n    /**\n     * The extensions of the files required.\n     * @type {String[]}\n     */\n    this._required = {};\n    this._waitingFor = {};\n\n    this._wrappers = new Map();\n  }\n\n  /**\n   * Returns the extensions of the missing files for the given `dir`.\n   * @param {string} dir The cache key to look for.\n   * @return {String[]} Extensions of the missing files.\n   */\n  missingExtensions(dir) {\n    const required = this._required[dir];\n    const files = this._files[dir];\n\n    return required.filter(ext => files[ext] === undefined);\n  }\n\n  /**\n   * Checks if, when `file` is added, all required files are cached.\n   * @param {SourceNode} node The node to add before checking.\n   * @param {function(err: ?Error, files: ?Map<string, Node>)} callback Called with the error\n   * that occured while checking or all source nodes of `node` if all required files are already\n   * cached.\n   */\n  gotAllFiles(node, callback) {\n    if (this._waitingFor[node.relative]) {\n      const wrapper = dirname(node.relative);\n\n      this._files[wrapper][extname(node.relative)] = node;\n\n      if (this.missingExtensions(wrapper).length === 0) {\n        const files = this._files[wrapper];\n        callback(null, this._wrappers.get(wrapper), files);\n\n        delete this._files[wrapper];\n        delete this._required[wrapper];\n      } else {\n        callback(null);\n      }\n\n      delete this._waitingFor[node.relative];\n      return;\n    }\n\n    const wrapperExt = extname(node.relative);\n    const wrapperName = basename(node.relative, wrapperExt);\n    this._wrappers.set(node.relative, node);\n\n    readdir(node.relative, (err, files) => {\n      if (err) {\n        callback(err);\n      } else {\n        this._files[node.relative] = {};\n        this._required[node.relative] = files\n          .filter(name => name[0] !== '.' &&\n            !name.endsWith(wrapperExt) &&\n            name.match(new RegExp(`^${wrapperName}\\\\..+`)))\n          .map(name => {\n            this._waitingFor[join(node.relative, name)] = true;\n            return extname(name);\n          });\n\n        callback(null);\n      }\n    });\n  }\n\n  hasWrapper(key) {\n    return this._wrappers.has(key);\n  }\n\n}\n\n/**\n * A transformer that splits files into multiple others.\n * @abstract\n */\nexport default class SplittingTransformer extends PartialTransformer {\n\n  /**\n   * Creates a new SplittingTransformer.\n   * @param {Object} options The options to apply.\n   */\n  constructor(options) {\n    super(options);\n\n    /**\n     * The cache used when collecting files to combine.\n     * @type {CombineFilesCache}\n     */\n    this._combineFilesCache = new CombineFilesCache();\n  }\n\n  /**\n   * Returns `true` for all nodes the transformer currently waits for (works only when transforming\n   * from the filesystem). For example: In the {@link DisplayTransformer} class it returns `true`\n   * for all display source files, which are a *json*, a *svg* and optionally a *js* file.\n   * @param {Node} node The node to check.\n   */\n  shouldBeTransformed(node) {\n    if (this.direction === TransformDirection.FromDB) { return false; }\n\n    return this._combineFilesCache._waitingFor[node.relative] || false;\n  }\n\n  /**\n   * Creates a combined node from the cached source nodes.\n   * @param {Node} node The node collected. This is the only node guaranteed to be\n   * set, therefore us if for error messages, etc.\n   * @param {Map<string, Node>} sources The cached files stored against their extensions.\n   * @param {function(err: ?Error, data: ?Node)} callback Should be called with any errors\n   * that occur while combining the files, or optionally the resulting file.\n   * @abstract\n   */\n  createCombinedFile(node, sources, callback) { // eslint-disable-line no-unused-vars\n    throw new Error(\n      'SplittingTransformer#createCombinedFile must be implemented by all subclasses'\n    );\n  }\n\n  /**\n   * Calls {@link SplittingTransformer#createCombinedFile} as soon as all dependencies are\n   * required files are cached.\n   * @param {Node} node The read node.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error, data: ?Node)} callback Called with the error occured while\n   * caching files or creating the combined file or optionally the resulting combined file.\n   */\n  transformFromFilesystem(node, enc, callback) {\n    // console.error('transforming', file);\n    this._combineFilesCache.gotAllFiles(node, (err, wrapper, allFiles) => {\n      if (err) {\n        callback(err);\n      } else if (allFiles) {\n        this.createCombinedFile(wrapper, allFiles, callback);\n      } else {\n        callback(null);\n      }\n    });\n  }\n\n  /**\n   * Splits a {@link Node}: The resulting is a clone of the input file, with a different path.\n   * @param {Node} node The file to split.\n   * @param {?String} newExtension The extension the resulting file gets.\n   * @return {Node} The resulting node.\n   */\n  static splitFile(node, newExtension) {\n    Object.assign(node, {\n      fullyMapped: true,\n      value: Object.assign(node.value, {\n        noWrite: true,\n      }),\n    });\n\n    return node.createChild({ extension: newExtension });\n  }\n\n  /**\n   * If there are any missing files this method loads these files and calls\n   * {SplittingTransformer#createCombinedFile} with them.\n   * @param {function(err: ?Error)} callback Called with the error that occurred while loading\n   * missing files.\n   */\n  _flush(callback) {\n    const missingDirnames = Object.keys(this._combineFilesCache._files);\n\n    if (missingDirnames.length > 0) {\n      callback();\n      // FIXME: Assert in push but not in watch task\n      /* callback(new Error(`Incomplete mapping: Missing files for ${\n        missingDirnames.join(', ')\n      }`)); */\n    } else {\n      callback();\n    }\n  }\n\n}\n\n"],"file":"SplittingTransformer.js"}