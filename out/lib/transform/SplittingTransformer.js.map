{"version":3,"sources":["../../../src/lib/transform/SplittingTransformer.js"],"names":["SplittingTransformer","PartialTransformer","extension","Error","sourceExtensions","splitFile","node","newExtension","Object","assign","fullyMapped","value","noWrite","createChild","transformFromDB","renameTo","name","constructor","readNodeFile","shouldBeTransformed","undefined","combineNodes","sourceNodes","_combineNodes","transformFromFilesystem","context","hasExtension","fileName","split","relative","regExp","RegExp","join","sourceFiles","childFiles","children","reduce","current","f","match","push","path","includes","Promise","all","map","readNode","tree","parent","result","n"],"mappings":"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","sourcesContent":["import { extname, basename, join } from 'path';\nimport { readdir } from 'fs-extra';\nimport PartialTransformer from './PartialTransformer.js';\n\n/**\n * A transformer that splits a node into multiple source nodes when pulling.\n */\nexport default class SplittingTransformer extends PartialTransformer {\n\n  /**\n   * The extension to add to container node names when they are pulled.\n   * @abstract\n   * @type {string}\n   */\n  static get extension() {\n    throw new Error('Must be implemented by all subclasses');\n  }\n\n  /**\n   * The source file extensions to allow.\n   * @abstract\n   * @type {string[]}\n   */\n  static get sourceExtensions() {\n    throw new Error('Must be implemented by all subclasses');\n  }\n\n  /**\n   * Splits a {@link Node}: The resulting is a clone of the input file, with a different path.\n   * @param {Node} node The file to split.\n   * @param {?string} newExtension The extension the resulting file gets.\n   * @return {Node} The resulting node.\n   */\n  static splitFile(node, newExtension) {\n    Object.assign(node, {\n      fullyMapped: true,\n      value: Object.assign(node.value, {\n        noWrite: true,\n      }),\n    });\n\n    return node.createChild({ extension: newExtension });\n  }\n\n  /**\n   * Renames a container node, should be called by all subclasses.\n   * @param {BrowsedNode} node A container node.\n   */\n  async transformFromDB(node) {\n    node.renameTo(`${node.name}${this.constructor.extension}`);\n  }\n\n  /**\n   * Returns `false` for all container nodes, so they don't get read.\n   * @param {BrowsedNode} node The node to check.\n   * @return {?boolean} If the node should be read.\n   */\n  readNodeFile(node) {\n    return this.shouldBeTransformed(node) ? false : undefined;\n  }\n\n  /**\n   * Combines the container node and the source nodes to one single node.\n   * @abstract\n   * @param {BrowsedNode} node The container node.\n   * @param {Map<string, BrowsedNode>} sourceNodes The source nodes.\n   */\n  combineNodes(node, sourceNodes) { // eslint-disable-line @typescript-eslint/no-unused-vars\n    throw new Error('Must be implemented by all subclasses');\n  }\n\n  /**\n   * Combines the container node and the source nodes to one single node by calling\n   * {@link SplittingTransformer#combineNodes}.\n   * @param {BrowsedNode} node The container node.\n   * @param {{ [extension: string]: BrowedNode }} sourceNodes The source nodes.\n   */\n  _combineNodes(node, sourceNodes) {\n    this.combineNodes(node, sourceNodes);\n    node.renameTo(basename(node.name, this.constructor.extension));\n  }\n\n  /**\n   * Reads a given container nodes source nodes and combines them.\n   * @param {BrowsedNode} node The node to transform.\n   * @param {Object} context The browser context.\n   */\n  async transformFromFilesystem(node, context) {\n    if (!this.shouldBeTransformed(node)) { return; }\n\n    const [name, hasExtension] = node.fileName.split(this.constructor.extension);\n\n    if (hasExtension !== '') { // FIXME: Remove\n      throw new Error(`${node.relative} shouldn't be transformed`);\n    }\n\n    const regExp = new RegExp(`^\\\\.${name}(${\n      this.constructor.sourceExtensions.join('|')\n    })\\\\.json$`);\n\n    // Find source files an child definition files\n    const sourceFiles = [];\n    const childFiles = [];\n\n    const children = (await readdir(node.relative))\n      .reduce((current, f) => {\n        if (f.match(regExp)) {\n          sourceFiles.push(f);\n        } else if (f.match(/^\\..*\\.json$/)) { // Other definition file -> child node\n          current.push({ name: f, path: join(node.relative, f) });\n          childFiles.push(f);\n        } else if (!sourceFiles.includes(`.${f}.json`) && !childFiles.includes(`.${f}.json`)) {\n          // This might be a child object's folder...\n          current.push({ name: f, path: join(node.relative, f) });\n        }\n\n        return current;\n      }, []);\n\n    // Manually set node.children for the container as source browser only handles definition files\n    Object.assign(node, { children });\n\n    const sourceNodes = await Promise.all(sourceFiles\n      .map(f => context.readNode({\n        path: join(node.relative, f),\n        tree: { parent: node },\n      }))\n    );\n\n\n    this._combineNodes(node, sourceNodes\n      .reduce((result, n) => Object.assign(result, {\n        [extname(n.fileName)]: n,\n      }), {}));\n  }\n\n}\n\n"],"file":"SplittingTransformer.js"}