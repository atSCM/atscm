{"version":3,"sources":["../../../src/lib/transform/SplittingTransformer.js"],"names":["SplittingTransformer","PartialTransformer","extension","Error","splitFile","node","newExtension","Object","assign","fullyMapped","value","noWrite","createChild","transformFromDB","renameTo","name","constructor","readNodeFile","shouldBeTransformed","undefined","combineNodes","sourceNodes","_combineNodes","transformFromFilesystem","context","hasExtension","fileName","split","relative","regExp","RegExp","sourceFiles","children","reduce","current","f","match","push","path","Promise","all","map","readNode","tree","parent","result","n"],"mappings":"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","sourcesContent":["import { extname, basename, join } from 'path';\nimport { readdir } from 'fs-extra';\nimport PartialTransformer from './PartialTransformer.js';\n\n/**\n * A transformer that splits a node into multiple source nodes when pulling.\n */\nexport default class SplittingTransformer extends PartialTransformer {\n\n  /**\n   * The extension to add to container node names when they are pulled.\n   * @abstract\n   * @type {string}\n   */\n  static get extension() {\n    throw new Error('Must be implemented by all subclasses');\n  }\n\n  /**\n   * Splits a {@link Node}: The resulting is a clone of the input file, with a different path.\n   * @param {Node} node The file to split.\n   * @param {?string} newExtension The extension the resulting file gets.\n   * @return {Node} The resulting node.\n   */\n  static splitFile(node, newExtension) {\n    Object.assign(node, {\n      fullyMapped: true,\n      value: Object.assign(node.value, {\n        noWrite: true,\n      }),\n    });\n\n    return node.createChild({ extension: newExtension });\n  }\n\n  /**\n   * Renames a container node, should be called by all subclasses.\n   * @param {BrowsedNode} node A container node.\n   */\n  async transformFromDB(node) {\n    node.renameTo(`${node.name}${this.constructor.extension}`);\n  }\n\n  /**\n   * Returns `false` for all container nodes, so they don't get read.\n   * @param {BrowsedNode} node The node to check.\n   * @return {?boolean} If the node should be read.\n   */\n  readNodeFile(node) {\n    return this.shouldBeTransformed(node) ? false : undefined;\n  }\n\n  /**\n   * Combines the container node and the source nodes to one single node.\n   * @abstract\n   * @param {BrowsedNode} node The container node.\n   * @param {Map<string, BrowsedNode>} sourceNodes The source nodes.\n   */\n  combineNodes(node, sourceNodes) { // eslint-disable-line @typescript-eslint/no-unused-vars\n    throw new Error('Must be implemented by all subclasses');\n  }\n\n  /**\n   * Combines the container node and the source nodes to one single node by calling\n   * {@link SplittingTransformer#combineNodes}.\n   * @param {BrowsedNode} node The container node.\n   * @param {{ [extension: string]: BrowedNode }} sourceNodes The source nodes.\n   */\n  _combineNodes(node, sourceNodes) {\n    this.combineNodes(node, sourceNodes);\n    node.renameTo(basename(node.name, this.constructor.extension));\n  }\n\n  /**\n   * Reads a given container nodes source nodes and combines them.\n   * @param {BrowsedNode} node The node to transform.\n   * @param {Object} context The browser context.\n   */\n  async transformFromFilesystem(node, context) {\n    if (!this.shouldBeTransformed(node)) { return; }\n\n    const [name, hasExtension] = node.fileName.split(this.constructor.extension);\n\n    if (hasExtension !== '') { // FIXME: Remove\n      throw new Error(`${node.relative} shouldn't be transformed`);\n    }\n\n    const regExp = new RegExp(`^\\\\.${name}(\\\\..*)\\\\.json$`);\n\n    // Find source files an child definition files\n    const sourceFiles = [];\n    const children = (await readdir(node.relative))\n      .reduce((current, f) => {\n        if (f.match(regExp)) {\n          sourceFiles.push(f);\n        } else if (f.match(/^\\..*\\.json$/)) { // Other definition file -> child node\n          current.push({ name: f, path: join(node.relative, f) });\n        }\n\n        return current;\n      }, []);\n\n    // Manually set node.children for the container as source browser only handles definition files\n    Object.assign(node, { children });\n\n    const sourceNodes = await Promise.all(sourceFiles\n      .map(f => context.readNode({\n        path: join(node.relative, f),\n        tree: { parent: node },\n      }))\n    );\n\n\n    this._combineNodes(node, sourceNodes\n      .reduce((result, n) => Object.assign(result, {\n        [extname(n.fileName)]: n,\n      }), {}));\n  }\n\n}\n\n"],"file":"SplittingTransformer.js"}