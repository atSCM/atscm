{"version":3,"sources":["../../../src/lib/transform/SplittingTransformer.js"],"names":["CombineFilesCache","constructor","_files","_required","_waitingFor","_wrappers","Map","missingExtensions","dir","required","files","filter","ext","undefined","gotAllFiles","node","callback","relative","wrapper","length","get","wrapperExt","wrapperName","set","err","name","endsWith","match","RegExp","map","hasWrapper","key","has","SplittingTransformer","options","_combineFilesCache","shouldBeTransformed","direction","FromDB","createCombinedFile","sources","Error","transformFromFilesystem","enc","allFiles","splitFile","newExtension","Object","assign","fullyMapped","value","noWrite","createChild","extension","_flush","missingDirnames","keys"],"mappings":"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","file":"SplittingTransformer.js","sourcesContent":["import { readdir } from 'fs';\nimport { extname, basename, join, dirname } from 'path';\nimport PartialTransformer from './PartialTransformer';\nimport { TransformDirection } from './Transformer';\n\n/**\n * Determines which files are needed to create a combined file and stores these files as long as\n * some of them are missing.\n */\nexport class CombineFilesCache {\n\n  /**\n   * Creates a new DisplayCache.\n   */\n  constructor() {\n    /**\n     * The files caches for the given path.\n     * @type {Map<String, Node>}\n     */\n    this._files = {};\n\n    /**\n     * The extensions of the files required.\n     * @type {String[]}\n     */\n    this._required = {};\n    this._waitingFor = {};\n\n    this._wrappers = new Map();\n  }\n\n  /**\n   * Returns the extensions of the missing files for the given `dir`.\n   * @param {string} dir The cache key to look for.\n   * @return {String[]} Extensions of the missing files.\n   */\n  missingExtensions(dir) {\n    const required = this._required[dir];\n    const files = this._files[dir];\n\n    return required.filter(ext => files[ext] === undefined);\n  }\n\n  /**\n   * Checks if, when `file` is added, all required files are cached.\n   * @param {SourceNode} node The node to add before checking.\n   * @param {function(err: ?Error, files: ?Map<string, Node>)} callback Called with the error\n   * that occured while checking or all source nodes of `node` if all required files are already\n   * cached.\n   */\n  gotAllFiles(node, callback) {\n    if (this._waitingFor[node.relative]) {\n      const wrapper = dirname(node.relative);\n\n      this._files[wrapper][extname(node.relative)] = node;\n\n      if (this.missingExtensions(wrapper).length === 0) {\n        const files = this._files[wrapper];\n        callback(null, this._wrappers.get(wrapper), files);\n\n        delete this._files[wrapper];\n        delete this._required[wrapper];\n      } else {\n        callback(null);\n      }\n\n      delete this._waitingFor[node.relative];\n      return;\n    }\n\n    const wrapperExt = extname(node.relative);\n    const wrapperName = basename(node.relative, wrapperExt);\n    this._wrappers.set(node.relative, node);\n\n    readdir(node.relative, (err, files) => {\n      if (err) {\n        callback(err);\n      } else {\n        this._files[node.relative] = {};\n        this._required[node.relative] = files\n          .filter(name => name[0] !== '.' &&\n            !name.endsWith(wrapperExt) &&\n            name.match(new RegExp(`^${wrapperName}\\\\..+`)))\n          .map(name => {\n            this._waitingFor[join(node.relative, name)] = true;\n            return extname(name);\n          });\n\n        callback(null);\n      }\n    });\n  }\n\n  hasWrapper(key) {\n    return this._wrappers.has(key);\n  }\n\n}\n\n/**\n * A transformer that splits files into multiple others.\n * @abstract\n */\nexport default class SplittingTransformer extends PartialTransformer {\n\n  /**\n   * Creates a new SplittingTransformer.\n   * @param {Object} options The options to apply.\n   */\n  constructor(options) {\n    super(options);\n\n    /**\n     * The cache used when collecting files to combine.\n     * @type {CombineFilesCache}\n     */\n    this._combineFilesCache = new CombineFilesCache();\n  }\n\n  /**\n   * Returns `true` for all nodes the transformer currently waits for (works only when transforming\n   * from the filesystem). For example: In the {@link DisplayTransformer} class it returns `true`\n   * for all display source files, which are a *json*, a *svg* and optionally a *js* file.\n   * @param {Node} node The node to check.\n   */\n  shouldBeTransformed(node) {\n    if (this.direction === TransformDirection.FromDB) { return false; }\n\n    return this._combineFilesCache._waitingFor[node.relative] || false;\n  }\n\n  /**\n   * Creates a combined node from the cached source nodes.\n   * @param {Node} node The node collected. This is the only node guaranteed to be\n   * set, therefore us if for error messages, etc.\n   * @param {Map<string, Node>} sources The cached files stored against their extensions.\n   * @param {function(err: ?Error, data: ?Node)} callback Should be called with any errors\n   * that occur while combining the files, or optionally the resulting file.\n   * @abstract\n   */\n  createCombinedFile(node, sources, callback) { // eslint-disable-line no-unused-vars\n    throw new Error(\n      'SplittingTransformer#createCombinedFile must be implemented by all subclasses'\n    );\n  }\n\n  /**\n   * Calls {@link SplittingTransformer#createCombinedFile} as soon as all dependencies are\n   * required files are cached.\n   * @param {Node} node The read node.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error, data: ?Node)} callback Called with the error occured while\n   * caching files or creating the combined file or optionally the resulting combined file.\n   */\n  transformFromFilesystem(node, enc, callback) {\n    // console.error('transforming', file);\n    this._combineFilesCache.gotAllFiles(node, (err, wrapper, allFiles) => {\n      if (err) {\n        callback(err);\n      } else if (allFiles) {\n        this.createCombinedFile(wrapper, allFiles, callback);\n      } else {\n        callback(null);\n      }\n    });\n  }\n\n  /**\n   * Splits a {@link Node}: The resulting is a clone of the input file, with a different path.\n   * @param {Node} node The file to split.\n   * @param {?String} newExtension The extension the resulting file gets.\n   * @return {Node} The resulting node.\n   */\n  static splitFile(node, newExtension) {\n    Object.assign(node, {\n      fullyMapped: true,\n      value: Object.assign(node.value, {\n        noWrite: true,\n      }),\n    });\n\n    return node.createChild({ extension: newExtension });\n  }\n\n  /**\n   * If there are any missing files this method loads these files and calls\n   * {SplittingTransformer#createCombinedFile} with them.\n   * @param {function(err: ?Error)} callback Called with the error that occurred while loading\n   * missing files.\n   */\n  _flush(callback) {\n    const missingDirnames = Object.keys(this._combineFilesCache._files);\n\n    if (missingDirnames.length > 0) {\n      callback();\n      // FIXME: Assert in push but not in watch task\n      /* callback(new Error(`Incomplete mapping: Missing files for ${\n        missingDirnames.join(', ')\n      }`)); */\n    } else {\n      callback();\n    }\n  }\n\n}\n\n"]}