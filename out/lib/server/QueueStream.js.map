{"version":3,"sources":["../../../src/lib/server/QueueStream.js"],"names":["QueueStream","constructor","options","maxParallel","Object","assign","highWaterMark","_processing","_processed","_queued","_maxParallel","_start","Date","getTime","on","queueEmpty","_processChunk","shift","emit","hasPending","length","processed","opsPerSecond","processErrorMessage","chunk","Error","processChunk","handleErrors","err","statusCode","onSuccess","message","Good","description","_enqueueChunk","push","_transform","enc","callback","session","once","_flush"],"mappings":"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","file":"QueueStream.js","sourcesContent":["import { StatusCodes } from 'node-opcua';\nimport Stream from './Stream';\n\n/**\n * A stream that process atvise server requests in parallel.\n * @abstract\n */\nexport default class QueueStream extends Stream {\n\n  /**\n   * Creates a new QueueStream with the given options.\n   * @param {Object} [options] The options to use\n   * @param {Number} [options.maxParallel] The maximum of parallel tasks to execute.\n   */\n  constructor(options = {}) {\n    const maxParallel = options.maxParallel || 250;\n    super(Object.assign(options, { highWaterMark: maxParallel }));\n\n    /**\n     * The number of running operations.\n     * @type {Number}\n     */\n    this._processing = 0;\n\n    /**\n     * The number of chunks processed so far.\n     * @type {Number}\n     */\n    this._processed = 0;\n\n    /**\n     * The queued chunks.\n     * @type {*[]}\n     */\n    this._queued = [];\n\n    /**\n     * The maximum of parallel tasks to execute\n     * @type {number}\n     */\n    this._maxParallel = maxParallel;\n\n    /**\n     * The timestamp of the date when the stream was created.\n     * @type {Number}\n     */\n    this._start = (new Date()).getTime();\n\n    this.on('processed-chunk', () => {\n      if (!this.queueEmpty) {\n        this._processChunk(this._queued.shift());\n      } else if (this._processing === 0) {\n        this.emit('drained');\n      }\n    });\n  }\n\n  /**\n   * `true` if there are queued operations or an operation is running right now.\n   * @type {Boolean}\n   */\n  get hasPending() {\n    return this._processing > 0 || this._queued.length > 0;\n  }\n\n  /**\n   * `true` if there are no queued operations\n   * @type {Boolean}\n   */\n  get queueEmpty() {\n    return this._queued.length === 0;\n  }\n\n  /**\n   * The number of chunks already processed.\n   * @type {Number}\n   */\n  get processed() {\n    return this._processed;\n  }\n\n  /**\n   * The number of processed chunks per second.\n   * @type {Number}\n   */\n  get opsPerSecond() {\n    return (this._processed / (((new Date()).getTime() - this._start) / 1000)) || 0;\n  }\n\n  /**\n   * The error message to use when processing a chunk fails. **Must be overridden by all\n   * subclasses!**\n   * @param {*} chunk The chunk being processed.\n   * @return {String} The error message to use.\n   * @abstract\n   */\n  processErrorMessage(chunk) { // eslint-disable-line no-unused-vars\n    throw new Error('QueueStream#processErrorMessage must be implemented by all subclasses');\n  }\n\n  /**\n   * The function to call when a chunk is ready to be processed. **Must be overridden by all\n   * subclasses.**\n   * @param {*} chunk The chunk to process.\n   * @param {function(err: Error, statusCode: node-opcua~StatusCodes, onSuccess: function)}\n   * handleErrors Call this function to handle errors and bad status codes. When no error occured\n   * and the status code received is fine, `onSuccess` is called. Further processing of valid\n   * chunks, e.g. recursions should happen in `onSuccess`. **Note that `onSuccess` is an\n   * asynchronous function with a callback as an argument.**\n   * @example <caption>Basic implementation</caption>\n   * class MyQueueStream extends QueueStream {\n   *   ...\n   *   processChunk(chunk, handle) {\n   *     client.session.doSomething((err, result, statusCode) => handle(err, statusCode, done => {\n   *       // This is called if err is falsy and status code is node-opcua~StatusCodes.Good\n   *       doSomethingWith(result);\n   *       done();\n   *     }));\n   *   }\n   *   ...\n   * }\n   * @example <caption>Implement a recursion</caption>\n   * class RecursiveQueueStream extends QueueStream {\n   *   ...\n   *   processChunk(chunk, handle) {\n   *     client.session.doSomething((err, result, statusCode) => handle(err, statusCode, done => {\n   *       // Write the result back to the stream.\n   *       // This means, that `result` will be queued and, as soon as possible, #processChunk will\n   *       // be called with `result` as the `chunk` argument.\n   *       this.write(result, null, done);\n   *     }));\n   *   }\n   *   ...\n   * }\n   * @example <caption>Allowing some invalid status codes</caption>\n   * import { StatusCodes } from 'node-opcua';\n   *\n   * class FriendlyQueueStream extends QueueStream {\n   *   ...\n   *   processChunk(chunk, handle) {\n   *     client.session.doSomething((err, result, statusCode) => {\n   *       if (statusCode === StatusCodes.BadUserAccessDenied) {\n   *         Logger.warn(`Ignored invalid status: ${statusCode.description}`);\n   *         handle(err, StatusCodes.Good, done => done());\n   *       } else {\n   *         handle(err, statusCode, done => done());\n   *       }\n   *     });\n   *   }\n   *   ...\n   * }\n   * @abstract\n   */\n  processChunk(chunk, handleErrors) { // eslint-disable-line no-unused-vars\n    handleErrors(new Error('QueueStream#processChunk must be implemented by all subclasses'));\n  }\n\n  /**\n   * Calls {@link QueueStream#processChunk} and handles errors and invalid status codes.\n   * @param {*} chunk The chunk to process.\n   * @emits {*} Emits a `processed-chunk` event once a chunk was processed.\n   */\n  _processChunk(chunk) {\n    this._processing++;\n\n    this.processChunk(chunk, (err, statusCode, onSuccess) => {\n      if (err) {\n        this.emit('error', new Error(`${this.processErrorMessage(chunk)}: ${err.message}`));\n      } else if (statusCode !== StatusCodes.Good) {\n        this.emit('error',\n          new Error(`${this.processErrorMessage(chunk)}: ${statusCode.description}`));\n      } else {\n        onSuccess(() => {\n          this._processing--;\n          this._processed++;\n          this.emit('processed-chunk', chunk);\n        });\n      }\n    });\n  }\n\n  /**\n   * Enqueues the given chunk for processing.\n   * @param {*} chunk The chunk to enqueue.\n   */\n  _enqueueChunk(chunk) {\n    if (this._processing < this._maxParallel) {\n      this._processChunk(chunk);\n    } else {\n      this._queued.push(chunk);\n    }\n  }\n\n  /**\n   * Calls {@link QueueStream#_enqueueChunk} as soon as the stream's session is opened.\n   * @param {*} chunk The chunk to transform.\n   * @param {String} enc The encoding used.\n   * @param {function} callback Called once the chunk has been enqueued.\n   */\n  _transform(chunk, enc, callback) {\n    if (this.session) {\n      this._enqueueChunk(chunk);\n      callback();\n    } else {\n      this.once('session-open', () => {\n        this._enqueueChunk(chunk);\n        callback();\n      });\n    }\n  }\n\n  /**\n   * Waits for pending operations to complete.\n   * @param {function} callback Called once all queued chunks have been processed.\n   */\n  _flush(callback) {\n    if (this.hasPending) {\n      this.once('drained', () => {\n        super._flush(callback);\n      });\n    } else {\n      super._flush(callback);\n    }\n  }\n\n}\n"]}