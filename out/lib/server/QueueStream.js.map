{"version":3,"sources":["../../../src/lib/server/QueueStream.js"],"names":["QueueStream","Stream","constructor","options","maxParallel","Object","assign","highWaterMark","_processing","_processed","_queued","_maxParallel","_start","Date","getTime","on","queueEmpty","_processChunk","shift","emit","hasPending","length","processed","opsPerSecond","processErrorMessage","chunk","Error","processChunk","handleErrors","err","statusCode","onSuccess","finished","error","message","process","env","CONTINUE_ON_FAILURE","Logger","StatusCodes","Good","description","_enqueueChunk","push","_transform","enc","callback","session","once","_flush"],"mappings":"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","sourcesContent":["/* Needed as long as https://github.com/gajus/eslint-plugin-jsdoc/issues/56 is open */\n/* eslint-disable jsdoc/check-param-names */\n\nimport { StatusCodes } from 'node-opcua/lib/datamodel/opcua_status_code';\nimport Logger from 'gulplog';\nimport Stream from './Stream';\n\n/**\n * A stream that process atvise server requests in parallel.\n * @abstract\n */\nexport default class QueueStream extends Stream {\n\n  /**\n   * Creates a new QueueStream with the given options.\n   * @param {Object} [options] The options to use.\n   * @param {number} [options.maxParallel] The maximum of parallel tasks to execute.\n   */\n  constructor(options = {}) {\n    const maxParallel = options.maxParallel || 250;\n    super(Object.assign(options, { highWaterMark: maxParallel }));\n\n    /**\n     * The number of running operations.\n     * @type {Number}\n     */\n    this._processing = 0;\n\n    /**\n     * The number of chunks processed so far.\n     * @type {Number}\n     */\n    this._processed = 0;\n\n    /**\n     * The queued chunks.\n     * @type {*[]}\n     */\n    this._queued = [];\n\n    /**\n     * The maximum of parallel tasks to execute\n     * @type {number}\n     */\n    this._maxParallel = maxParallel;\n\n    /**\n     * The timestamp of the date when the stream was created.\n     * @type {Number}\n     */\n    this._start = (new Date()).getTime();\n\n    this.on('processed-chunk', () => {\n      if (!this.queueEmpty) {\n        this._processChunk(this._queued.shift());\n      } else if (this._processing === 0) {\n        this.emit('drained');\n      }\n    });\n  }\n\n  /**\n   * `true` if there are queued operations or an operation is running right now.\n   * @type {boolean}\n   */\n  get hasPending() {\n    return this._processing > 0 || this._queued.length > 0;\n  }\n\n  /**\n   * `true` if there are no queued operations.\n   * @type {boolean}\n   */\n  get queueEmpty() {\n    return this._queued.length === 0;\n  }\n\n  /**\n   * The number of chunks already processed.\n   * @type {number}\n   */\n  get processed() {\n    return this._processed;\n  }\n\n  /**\n   * The number of processed chunks per second.\n   * @type {number}\n   */\n  get opsPerSecond() {\n    return (this._processed / (((new Date()).getTime() - this._start) / 1000)) || 0;\n  }\n\n  /**\n   * The error message to use when processing a chunk fails. **Must be overridden by all\n   * subclasses!**.\n   * @param {*} chunk The chunk being processed.\n   * @return {string} The error message to use.\n   * @abstract\n   */\n  processErrorMessage(chunk) { // eslint-disable-line @typescript-eslint/no-unused-vars\n    throw new Error('QueueStream#processErrorMessage must be implemented by all subclasses');\n  }\n\n  /**\n   * The function to call when a chunk is ready to be processed. **Must be overridden by all\n   * subclasses.**.\n   * @param {*} chunk The chunk to process.\n   * @param {function(err: Error, statusCode: node-opcua~StatusCodes, onSuccess: function)}\n   * handleErrors Call this function to handle errors and bad status codes. When no error occured\n   * and the status code received is fine, `onSuccess` is called. Further processing of valid\n   * chunks, for example Recursions should happen in `onSuccess`. **Note that `onSuccess` is an\n   * asynchronous function with a callback as an argument.**.\n   * @example <caption>Basic implementation</caption>\n   * class MyQueueStream extends QueueStream {\n   *   ...\n   *   processChunk(chunk, handle) {\n   *     client.session.doSomething((err, result, statusCode) => handle(err, statusCode, done => {\n   *       // This is called if err is falsy and status code is node-opcua~StatusCodes.Good\n   *       doSomethingWith(result);\n   *       done();\n   *     }));\n   *   }\n   *   ...\n   * }\n   * @example <caption>Implement a recursion</caption>\n   * class RecursiveQueueStream extends QueueStream {\n   *   ...\n   *   processChunk(chunk, handle) {\n   *     client.session.doSomething((err, result, statusCode) => handle(err, statusCode, done => {\n   *       // Write the result back to the stream.\n   *       // This means, that `result` will be queued and, as soon as possible, #processChunk will\n   *       // be called with `result` as the `chunk` argument.\n   *       this.write(result, null, done);\n   *     }));\n   *   }\n   *   ...\n   * }\n   * @example <caption>Allowing some invalid status codes</caption>\n   * import { StatusCodes } from 'node-opcua';\n   *\n   * class FriendlyQueueStream extends QueueStream {\n   *   ...\n   *   processChunk(chunk, handle) {\n   *     client.session.doSomething((err, result, statusCode) => {\n   *       if (statusCode === StatusCodes.BadUserAccessDenied) {\n   *         Logger.warn(`Ignored invalid status: ${statusCode.description}`);\n   *         handle(err, StatusCodes.Good, done => done());\n   *       } else {\n   *         handle(err, statusCode, done => done());\n   *       }\n   *     });\n   *   }\n   *   ...\n   * }\n   * @abstract\n   */\n  processChunk(chunk, handleErrors) { // eslint-disable-line no-unused-vars\n    handleErrors(new Error('QueueStream#processChunk must be implemented by all subclasses'));\n  }\n\n  /**\n   * Calls {@link QueueStream#processChunk} and handles errors and invalid status codes.\n   * @param {*} chunk The chunk to process.\n   * @emits {*} Emits a `processed-chunk` event once a chunk was processed.\n   */\n  _processChunk(chunk) {\n    this._processing++;\n\n    this.processChunk(chunk, (err, statusCode, onSuccess) => {\n      const finished = (error) => {\n        this._processing--;\n        this._processed++;\n        this.emit('processed-chunk', chunk, error);\n      };\n\n      let error = err;\n\n      if (err) {\n        const message = `${this.processErrorMessage(chunk)}: ${err.message}`;\n\n        if (process.env.CONTINUE_ON_FAILURE === 'true') {\n          Logger.error(`FAILURE: ${message}`);\n        } else {\n          this.emit('error', Object.assign(err, { message }));\n        }\n      } else if (statusCode !== StatusCodes.Good) {\n        const message = `${this.processErrorMessage(chunk)}: ${statusCode.description}`;\n        error = new Error(message);\n\n        if (process.env.CONTINUE_ON_FAILURE === 'true') {\n          Logger.error(`FAILURE: ${message}`);\n        } else {\n          this.emit('error', new Error(message));\n        }\n      } else {\n        onSuccess(finished);\n        return;\n      }\n\n      finished(error);\n    });\n  }\n\n  /**\n   * Enqueues the given chunk for processing.\n   * @param {*} chunk The chunk to enqueue.\n   */\n  _enqueueChunk(chunk) {\n    if (this._processing < this._maxParallel) {\n      this._processChunk(chunk);\n    } else {\n      this._queued.push(chunk);\n    }\n  }\n\n  /**\n   * Calls {@link QueueStream#_enqueueChunk} as soon as the stream's session is opened.\n   * @param {*} chunk The chunk to transform.\n   * @param {string} enc The encoding used.\n   * @param {Function} callback Called once the chunk has been enqueued.\n   */\n  _transform(chunk, enc, callback) {\n    if (this.session) {\n      this._enqueueChunk(chunk);\n      callback();\n    } else {\n      this.once('session-open', () => {\n        this._enqueueChunk(chunk);\n        callback();\n      });\n    }\n  }\n\n  /**\n   * Waits for pending operations to complete.\n   * @param {Function} callback Called once all queued chunks have been processed.\n   */\n  _flush(callback) {\n    if (this.hasPending) {\n      this.once('drained', () => {\n        super._flush(callback);\n      });\n    } else {\n      super._flush(callback);\n    }\n  }\n\n}\n"],"file":"QueueStream.js"}