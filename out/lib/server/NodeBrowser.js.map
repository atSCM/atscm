{"version":3,"sources":["../../../src/lib/server/NodeBrowser.js"],"names":["HierachicalReferencesTypeIds","Set","ReferenceTypeIds","HasChild","Aggregates","HasComponent","HasOrderedComponent","HasHistoricalConfiguration","HasProperty","HasSubtype","HasEventSource","HasNotifier","Organizes","BrowsedNode","ServerNode","constructor","parent","reference","nodeClass","name","browseName","addReference","toParent","referenceTypeId","value","id","nodeId","addReferences","references","forEach","createChild","options","node","NodeBrowser","concurrency","ignoreNodes","ProjectConfig","handleNode","recursive","queue","PromiseQueue","_handled","Map","_waitingFor","_ignoreNodesRegExp","RegExp","map","n","join","_recursive","_printSortOrderWarning","_handleNode","_pushed","parentNode","ensureHandled","_readValue","isVariable","Promise","resolve","reject","_session","readVariableValue","err","result","then","endsWith","removed","siblings","children","c","idName","filter","existing","exists","find","push","length","namespaceIndex","Logger","warn","toRead","AttributeIds","DataType","ValueRank","attributeId","read","_","dataType","valueRank","arrayType","VariantArrayType","Scalar","Array","_browse","browseDirection","BrowseDirection","Forward","resultMask","browse","data","_browseNode","allReferences","typeDefinitionReference","ref","HasTypeDefinition","isUserGroup","Object","setPrototypeOf","NodeId","prototype","ignored","test","external","_isExternalReference","has","split","preserveSortOrderNodes","prefix","subPath","isExternal","get","undefined","add","earlierParent","ReferenceTypeNames","set","debug","_push","error","originalId","isPaused","addAll","child","_process","idValue","delete","dep","dependencies","catch","_reject","addNode","transform","_sourceNodesRegExp","_hasDependencies","dependencyCount","values","concat","_getSourceNodes","nodeIds","browseUp","path","Inverse","unshift","ObjectIds","RootFolder","Error","browseDown","target","all","i","pathDown","reduce","replace","Session","create","nodes","processError","pause","clear","onIdle","close","keys","unresolved","entries","to","from","type","refs","size","pushed"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;AAEA;;;;AAIA,MAAMA,4BAA4B,GAAG,IAAIC,GAAJ,CAAQ,CAC3CC,uBAAiBC,QAD0B,EAE3CD,uBAAiBE,UAF0B,EAG3CF,uBAAiBG,YAH0B,EAI3CH,uBAAiBI,mBAJ0B,EAK3CJ,uBAAiBK,0BAL0B,EAM3CL,uBAAiBM,WAN0B,EAO3CN,uBAAiBO,UAP0B,EAQ3CP,uBAAiBQ,cAR0B,EAS3CR,uBAAiBS,WAT0B,EAU3CT,uBAAiBU,SAV0B,CAAR,CAArC;AAaA;;;;AAGO,MAAMC,WAAN,SAA0BC,gBAA1B,CAAqC;AAC1C;;;;;;AAMAC,EAAAA,WAAW,CAAC;AAAEC,IAAAA,MAAF;AAAUC,IAAAA,SAAV;AAAqBC,IAAAA,SAArB;AAAgCC,IAAAA;AAAhC,GAAD,EAAyC;AAClD,UAAM;AACJH,MAAAA,MADI;AAEJE,MAAAA,SAAS,EAAED,SAAS,GAAGA,SAAS,CAACC,SAAb,GAAyBA,SAFzC;AAGJC,MAAAA,IAAI,EAAEF,SAAS,GAAGA,SAAS,CAACG,UAAV,CAAqBD,IAAxB,GAA+BA;AAH1C,KAAN;;AAMA,QAAIF,SAAJ,EAAe;AACb;AACA,WAAKI,YAAL,CAAkBnB,uBAAiBoB,QAAnC,EAA6CL,SAAS,CAACM,eAAV,CAA0BC,KAAvE;AAEA;;AACA,WAAKC,EAAL,GAAUR,SAAS,CAACS,MAApB;AACD;AAED;;;;AAEA,SAAKF,KAAL,GAAa,EAAb;AACD;AAED;;;;;;AAIAG,EAAAA,aAAa,CAACC,UAAD,EAAa;AACxBA,IAAAA,UAAU,CAACC,OAAX,CAAmBZ,SAAS,IAAI;AAC9B,WAAKI,YAAL,CAAkBJ,SAAS,CAACM,eAAV,CAA0BC,KAA5C,EAAmDP,SAAS,CAACS,MAAV,CAAiBF,KAApE;AACD,KAFD;AAGD;AAED;;;;;;;AAKAM,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,UAAMC,IAAI,GAAG,MAAMF,WAAN,CAAkBC,OAAlB,CAAb;AAEAC,IAAAA,IAAI,CAACP,EAAL,GAAU,KAAKA,EAAf;AAEA,WAAOO,IAAP;AACD;;AAhDyC;AAmD5C;;;;;;;AAGe,MAAMC,WAAN,CAAkB;AAC/B;;;;;;;AAOAlB,EAAAA,WAAW,CAAC;AACVmB,IAAAA,WAAW,GAAG,GADJ;AAEVC,IAAAA,WAAW,GAAGC,uBAAcD,WAFlB;AAGVE,IAAAA,UAHU;AAIVC,IAAAA,SAAS,GAAG;AAJF,MAKR,EALO,EAKH;AACN;;AAEA,SAAKC,KAAL,GAAa,IAAIC,eAAJ,CAAiB;AAC5B;AACAN,MAAAA;AAF4B,KAAjB,CAAb;AAKA;;;;;AAIA,SAAKO,QAAL,GAAgB,IAAIC,GAAJ,EAAhB;AAEA,SAAKC,WAAL,GAAmB,EAAnB;AAEA;;AACA,SAAKC,kBAAL,GAA0B,IAAIC,MAAJ,CAAY,KAAIV,WAAW,CAACW,GAAZ,CAAgBC,CAAC,IAAIA,CAAC,CAACvB,KAAvB,EAA8BwB,IAA9B,CAAmC,GAAnC,CAAwC,GAAxD,CAA1B;AAEA;;AACA,SAAKC,UAAL,GAAkBX,SAAlB;AAEA;;;AAEA,SAAKY,sBAAL,GAA8BZ,SAA9B;AAEA;;AACA,SAAKa,WAAL,GAAmBd,UAAnB;AAEA;;AACA,SAAKe,OAAL,GAAe,CAAf;AAEA;;;;AAGA,SAAKC,UAAL,GAAkB,IAAIX,GAAJ,EAAlB;AAEA,SAAKY,aAAL,GAAqB,IAAIrD,GAAJ,EAArB;AACD;AAED;;;;;;AAIAsD,EAAAA,UAAU,CAACvB,IAAD,EAAO;AACf,QAAI,CAACA,IAAI,CAACwB,UAAV,EAAsB;AACpB,aAAO,IAAP;AACD;;AACD,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,WAAKC,QAAL,CAAcC,iBAAd,CAAgC7B,IAAI,CAACP,EAArC,EAAyC,CAACqC,GAAD,EAAMC,MAAN,KAAiB;AACxD,YAAID,GAAJ,EAAS;AACP,iBAAOH,MAAM,CAACG,GAAD,CAAb;AACD;;AACD,eAAOJ,OAAO,CAACK,MAAM,IAAIA,MAAM,CAACvC,KAAlB,CAAd;AACD,OALD;AAMD,KAPM,EAOJwC,IAPI,CAOCxC,KAAK,IAAI;AACf,UAAIQ,IAAI,CAACN,MAAL,CAAYuC,QAAZ,CAAqB,YAArB,CAAJ,EAAwC;AACtC,cAAMC,OAAO,GAAG,EAAhB;AACA,cAAMC,QAAQ,GAAGnC,IAAI,CAAChB,MAAL,CAAYoD,QAAZ,CAAqBtB,GAArB,CAAyBuB,CAAC,IAAIA,CAAC,CAACC,MAAhC,EAAwCC,MAAxC,CAA+CxB,CAAC,IAAIA,CAAC,KAAK,WAA1D,CAAjB;AACA,cAAMyB,QAAQ,GAAGhD,KAAK,CAACA,KAAN,CACdsB,GADc,CACV,CAAC;AAAE3B,UAAAA;AAAF,SAAD,KAAcA,IADJ,EAEdoD,MAFc,CAEPpD,IAAI,IAAI;AACd,gBAAMsD,MAAM,GAAGN,QAAQ,CAACO,IAAT,CAAcL,CAAC,IAAIA,CAAC,KAAKlD,IAAzB,CAAf;;AAEA,cAAIsD,MAAJ,EAAY;AACV,mBAAO,IAAP;AACD;;AAEDP,UAAAA,OAAO,CAACS,IAAR,CAAaxD,IAAb;AACA,iBAAO,KAAP;AACD,SAXc,CAAjB,CAHsC,CAgBtC;;AAEA,YAAI+C,OAAO,CAACU,MAAZ,EAAoB;AAClB;AACApD,UAAAA,KAAK,CAACA,KAAN,GAAcgD,QAAQ,CAAC1B,GAAT,CAAa3B,IAAI,KAAK;AAAE0D,YAAAA,cAAc,EAAE,CAAlB;AAAqB1D,YAAAA;AAArB,WAAL,CAAjB,CAAd;;AACA2D,2BAAOC,IAAP,CAAa,WAAUb,OAAO,CAACU,MAAO,6BAA4B5C,IAAI,CAACN,MAAO,GAA9E;AACD;AACF;;AAED,UAAIF,KAAJ,EAAW;AACT,eAAOA,KAAP;AACD,OA5Bc,CA8Bf;;;AACA,aAAO,IAAIiC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,cAAMqB,MAAM,GAAG,CAACC,2BAAaC,QAAd,EAAwBD,2BAAaE,SAArC,EAAgDrC,GAAhD,CAAoDsC,WAAW,KAAK;AACjF1D,UAAAA,MAAM,EAAEM,IAAI,CAACP,EADoE;AAEjF2D,UAAAA;AAFiF,SAAL,CAA/D,CAAf;;AAIA,aAAKxB,QAAL,CAAcyB,IAAd,CACEL,MADF,EAEE,CACElB,GADF,EAEEwB,CAFF,EAGE,CACE;AACE9D,UAAAA,KAAK,EAAE;AAAEA,YAAAA,KAAK,EAAE+D;AAAT;AADT,SADF,EAIE;AACE/D,UAAAA,KAAK,EAAE;AAAEA,YAAAA,KAAK,EAAEgE;AAAT;AADT,SAJF,IAOI,EAVN,KAWK;AACH,cAAI1B,GAAJ,EAAS,OAAOH,MAAM,CAACG,GAAD,CAAb,CADN,CAGH;;AACA,gBAAM2B,SAAS,GAAGD,SAAS,GAAG,CAAZ,GAAgBE,0BAAiBC,MAAjC,GAA0CD,0BAAiBE,KAA7E;AAEA,iBAAOlC,OAAO,CAAC;AACb6B,YAAAA,QAAQ,EAAEL,kBAASK,QAAQ,CAAC/D,KAAlB,CADG;AAEbiE,YAAAA,SAFa;AAGbjE,YAAAA,KAAK,EAAE;AAHM,WAAD,CAAd;AAKD,SAxBH;AA0BD,OA/BM,CAAP;AAgCD,KAtEM,CAAP;AAuED,GApI8B,CAsI/B;AACA;;AACA;;;;;;AAIAqE,EAAAA,OAAO,CAAC;AAAEnE,IAAAA,MAAF;AAAUoE,IAAAA,eAAe,GAAGC,gCAAgBC,OAA5C;AAAqDC,IAAAA,UAAU,GAAG;AAAlE,GAAD,EAAyE;AAC9E,WAAO,IAAIxC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,WAAKC,QAAL,CAAcsC,MAAd,CAAqB;AAAExE,QAAAA,MAAF;AAAUoE,QAAAA,eAAV;AAA2BG,QAAAA;AAA3B,OAArB,EAA8D,CAACnC,GAAD,EAAMqC,IAAI,GAAG,EAAb,KAC5DrC,GAAG,GAAGH,MAAM,CAACG,GAAD,CAAT,GAAiBJ,OAAO,CAACyC,IAAI,CAAC,CAAD,CAAJ,CAAQvE,UAAT,CAD7B;AAGD,KAJM,CAAP;AAKD;AAED;;;;;;AAIAwE,EAAAA,WAAW,CAACpE,IAAD,EAAO;AAChB,WAAO,KAAK6D,OAAL,CAAa;AAAEnE,MAAAA,MAAM,EAAEM,IAAI,CAACP;AAAf,KAAb,EAAkCuC,IAAlC,CAAuCqC,aAAa,IAAI;AAC7D,YAAMjC,QAAQ,GAAG,EAAjB;AACA,YAAMxC,UAAU,GAAG,EAAnB;AAEA,YAAM0E,uBAAuB,GAAGD,aAAa,CAAC3B,IAAd,CAC9B6B,GAAG,IAAIA,GAAG,CAAChF,eAAJ,CAAoBC,KAApB,KAA8BtB,uBAAiBsG,iBADxB,CAAhC;AAIA,YAAMC,WAAW,GACfH,uBAAuB,IACvBA,uBAAuB,CAAC5E,MAAxB,CAA+BF,KAA/B,KAAyC,0BAF3C;AAIA6E,MAAAA,aAAa,CAACxE,OAAd,CAAsBZ,SAAS,IAAI;AACjC;AACAyF,QAAAA,MAAM,CAACC,cAAP,CAAsB1F,SAAS,CAACS,MAAhC,EAAwCkF,gBAAOC,SAA/C;;AAEA,cAAMC,OAAO,GAAG,KAAKlE,kBAAL,CAAwBmE,IAAxB,CAA6B9F,SAAS,CAACS,MAAV,CAAiBF,KAA9C,CAAhB;;AACA,cAAMwF,QAAQ,GAAG,KAAKC,oBAAL,CAA0BhG,SAAS,CAACS,MAAV,CAAiBF,KAA3C,CAAjB;;AAEA,YACExB,4BAA4B,CAACkH,GAA7B,CAAiCjG,SAAS,CAACM,eAAV,CAA0BC,KAA3D,KACA,CAACsF,OADD,IAEA,CAACE,QAHH,EAIE;AACA,cACE/F,SAAS,CAACM,eAAV,CAA0BC,KAA1B,KAAoCtB,uBAAiBK,0BAArD,IACCkG,WAAW,IAAIxF,SAAS,CAACS,MAAV,CAAiBF,KAAjB,CAAuB2F,KAAvB,CAA6BnF,IAAI,CAACN,MAAlC,EAA0CkD,MAA1C,KAAqD,CAFvE,EAGE;AACAhD,YAAAA,UAAU,CAAC+C,IAAX,CAAgB1D,SAAhB;AACA;AACD;;AAED,cACE,CAACmB,uBAAcgF,sBAAf,IACAnG,SAAS,CAACS,MAAV,CAAiBF,KAAjB,CAAuByC,QAAvB,CAAgC,YAAhC,CAFF,EAGE;AACA,gBAAI,KAAKf,sBAAT,EAAiC;AAC/B4B,+BAAOC,IAAP,CAAa;;+EAAb;;AAGA,mBAAK7B,sBAAL,GAA8B,KAA9B;AACD;;AACD;AACD;;AAED,gBAAM,CAACmE,MAAD,EAASC,OAAT,IAAoBrG,SAAS,CAACS,MAAV,CAAiBF,KAAjB,CAAuB2F,KAAvB,CAA6BnF,IAAI,CAACP,EAAL,CAAQD,KAArC,CAA1B;;AACA,cAAI,CAAC8F,OAAD,IAAYD,MAAM,KAAK,EAA3B,EAA+B;AAC7B,gBAAI,CAACjF,uBAAcmF,UAAd,CAAyBtG,SAAS,CAACS,MAAV,CAAiBV,MAAjB,CAAwBQ,KAAjD,CAAL,EAA8D;AAC5DI,cAAAA,UAAU,CAAC+C,IAAX,CAAgB1D,SAAhB;;AAEA,kBAAI,KAAKwB,QAAL,CAAc+E,GAAd,CAAkBvG,SAAS,CAACS,MAAV,CAAiBF,KAAnC,MAA8CiG,SAAlD,EAA6D;AAC3D,qBAAKnE,aAAL,CAAmBoE,GAAnB,CAAuBzG,SAAS,CAACS,MAAV,CAAiBF,KAAxC;AACD;;AACD;AACD;AACF;;AAED,gBAAMmG,aAAa,GAAG,KAAKtE,UAAL,CAAgBmE,GAAhB,CAAoBvG,SAAS,CAACS,MAAV,CAAiBF,KAArC,CAAtB;;AACA,cAAImG,aAAJ,EAAmB;AACjB7C,6BAAOC,IAAP,CAAa,IACX9D,SAAS,CAACS,MAAV,CAAiBF,KAClB,6CAA4CmG,aAAc,UAAS3F,IAAI,CAACP,EAAL,CAAQD,KAAM;sCACxDoG,yBAAmB3G,SAAS,CAACM,eAAV,CAA0BC,KAA7C,CAAoD,KAC5EP,SAAS,CAACM,eAAV,CAA0BC,KAC3B,GALD;AAMD;;AAED,cAAI,KAAKiB,QAAL,CAAc+E,GAAd,CAAkBvG,SAAS,CAACS,MAAV,CAAiBF,KAAnC,MAA8CiG,SAAlD,EAA6D;AAC3D,iBAAKpE,UAAL,CAAgBwE,GAAhB,CAAoB5G,SAAS,CAACS,MAAV,CAAiBF,KAArC,EAA4CQ,IAAI,CAACP,EAAL,CAAQD,KAApD;AACA4C,YAAAA,QAAQ,CAACO,IAAT,CACE,IAAI9D,WAAJ,CAAgB;AACdG,cAAAA,MAAM,EAAEgB,IADM;AAEdf,cAAAA;AAFc,aAAhB,CADF;AAMD,WApDD,CAoDE;;AACH,SAzDD,MAyDO,IAAIA,SAAS,CAACM,eAAV,CAA0BC,KAA1B,KAAoC,EAAxC,EAA4C;AACjD;AACA;AACA;AACA,cACEP,SAAS,CAACM,eAAV,CAA0BC,KAA1B,KAAoC,GAApC,IACAP,SAAS,CAACS,MAAV,CAAiBF,KAAjB,MAA4BQ,IAAI,CAAChB,MAAL,IAAegB,IAAI,CAAChB,MAAL,CAAYS,EAAZ,CAAeD,KAA1D,CAFF,EAGE;AACA;AACD,WATgD,CAWjD;;;AACA,cAAI,CAACsF,OAAL,EAAc;AACZlF,YAAAA,UAAU,CAAC+C,IAAX,CAAgB1D,SAAhB;AACD,WAFD,MAEO;AACL6D,6BAAOgD,KAAP,CACG,0BAAyB9F,IAAI,CAACP,EAAL,CAAQD,KAAM,KACtCoG,yBAAmB3G,SAAS,CAACM,eAAV,CAA0BC,KAA7C,CACD,QAAOP,SAAS,CAACS,MAAV,CAAiBF,KAAM,EAHjC;AAKD;AACF;AACF,OAtFD,EAZ6D,CAoG7D;;AACAQ,MAAAA,IAAI,CAACoC,QAAL,GAAgBA,QAAhB;AACApC,MAAAA,IAAI,CAACL,aAAL,CAAmBC,UAAnB;AAEA,aAAO;AAAEwC,QAAAA,QAAF;AAAYxC,QAAAA;AAAZ,OAAP;AACD,KAzGM,CAAP;AA0GD;AAED;;;;;;;AAKA,QAAMmG,KAAN,CAAY/F,IAAZ,EAAkB;AAChB,QAAI,KAAKS,QAAL,CAAc+E,GAAd,CAAkBxF,IAAI,CAACP,EAAL,CAAQD,KAA1B,CAAJ,EAAsC;AACpCsD,uBAAOkD,KAAP,CAAa,iCAAb,EAAgDhG,IAAI,CAACP,EAAL,CAAQD,KAAxD;;AACA;AACD,KAJe,CAMhB;;;AACA,SAAKiB,QAAL,CAAcoF,GAAd,CAAkB7F,IAAI,CAACP,EAAL,CAAQD,KAA1B,EAAiC,YAAjC,EAPgB,CAShB;;;AACAQ,IAAAA,IAAI,CAACR,KAAL,GAAa,CAAC,MAAM,KAAK+B,UAAL,CAAgBvB,IAAhB,CAAP,KAAiCA,IAAI,CAACR,KAAnD,CAVgB,CAYhB;;AAEA,UAAMyG,UAAU,GAAGjG,IAAI,CAACP,EAAL,CAAQD,KAA3B;AAEA,UAAM,KAAK2B,WAAL,CAAiBnB,IAAjB,CAAN;AAEA,SAAKoB,OAAL,IAAgB,CAAhB,CAlBgB,CAoBhB;;AACA,QAAI,CAAC,KAAKH,UAAN,IAAoB,KAAKV,KAAL,CAAW2F,QAAnC,EAA6C;AAC3C;AACA;AACD;;AAED,SAAK3F,KAAL,CAAW4F,MAAX,CAAkBnG,IAAI,CAACoC,QAAL,CAActB,GAAd,CAAkBsF,KAAK,IAAI,MAAM,KAAKC,QAAL,CAAcD,KAAd,CAAjC,CAAlB;AAEA,UAAME,OAAO,GAAGtG,IAAI,CAACP,EAAL,CAAQD,KAAxB;;AACA,SAAKiB,QAAL,CAAcoF,GAAd,CAAkBS,OAAlB,EAA2B,IAA3B;;AACA,SAAKhF,aAAL,CAAmBiF,MAAnB,CAA0BN,UAA1B,EA9BgB,CAgChB;;AACA,QAAI,KAAKtF,WAAL,CAAiB2F,OAAjB,CAAJ,EAA+B;AAC7B,WAAK3F,WAAL,CAAiB2F,OAAjB,EAA0BzG,OAA1B,CAAkC2G,GAAG,IAAI;AACvC;AACA,YAAI,EAAEA,GAAG,CAACC,YAAN,KAAuB,CAA3B,EAA8B;AAC5B;AACA,eAAKlG,KAAL,CAAWmF,GAAX,CAAe,MAAM,KAAKK,KAAL,CAAWS,GAAX,CAArB,EAAsCE,KAAtC,CAA4C,KAAKC,OAAjD;AACD;AACF,OAND;;AAQA,aAAO,KAAKhG,WAAL,CAAiB2F,OAAjB,CAAP;AACD;AACF;AAED;;;;;;;;AAMAM,EAAAA,OAAO,CAAC5G,IAAD,EAAO;AACZ,QAAI,KAAKO,KAAL,CAAW2F,QAAf,EAAyB;AACvBpD,uBAAOgD,KAAP,CAAa,iCAAb;;AACA,aAAOrE,OAAO,CAACC,OAAR,EAAP;AACD;;AAED,WAAO,KAAKnB,KAAL,CAAWmF,GAAX,CAAe,MAAM,KAAKvE,WAAL,CAAiBnB,IAAjB,EAAuB;AAAE6G,MAAAA,SAAS,EAAE;AAAb,KAAvB,CAArB,EAAmEH,KAAnE,CAAyE,KAAKC,OAA9E,CAAP;AACD;AAED;;;;;;;AAKA1B,EAAAA,oBAAoB,CAACqB,OAAD,EAAU;AAC5B;AACA,WAAO,OAAOA,OAAP,KAAmB,QAAnB,IAA+B,CAAC,KAAKQ,kBAAL,CAAwB/B,IAAxB,CAA6BuB,OAA7B,CAAvC;AACD;AAED;;;;;;AAIAS,EAAAA,gBAAgB,CAAC/G,IAAD,EAAO;AACrB,QAAIgH,eAAe,GAAG,CAAtB;;AAEA,SAAK,MAAMpH,UAAX,IAAyBI,IAAI,CAACJ,UAAL,CAAgBqH,MAAhB,EAAzB,EAAmD;AACjD,WAAK,MAAMhI,SAAX,IAAwBW,UAAxB,EAAoC;AAClC,YACE,KAAKa,QAAL,CAAc+E,GAAd,CAAkBvG,SAAlB,MAAiC,IAAjC,IACA,CAAC,KAAKgG,oBAAL,CAA0BhG,SAA1B,CADD,IAEA,CAAC,KAAK2B,kBAAL,CAAwBmE,IAAxB,CAA6B9F,SAA7B,CAHH,EAIE;AACA+H,UAAAA,eAAe;AACf,eAAKrG,WAAL,CAAiB1B,SAAjB,IAA8B,CAAC,KAAK0B,WAAL,CAAiB1B,SAAjB,KAA+B,EAAhC,EAAoCiI,MAApC,CAA2ClH,IAA3C,CAA9B;AACD;AACF;AACF,KAdoB,CAgBrB;;;AACAA,IAAAA,IAAI,CAACyG,YAAL,GAAoBO,eAApB;AAEA,WAAOA,eAAe,GAAG,CAAzB;AACD;AAED;;;;;;;AAKA,QAAMX,QAAN,CAAerG,IAAf,EAAqB;AACnB,QAAI;AACF,UAAI,KAAKS,QAAL,CAAcyE,GAAd,CAAkBlF,IAAI,CAACP,EAAL,CAAQD,KAA1B,CAAJ,EAAsC;AACpC;AACA,eAAOiG,SAAP;AACD;;AACD,WAAKhF,QAAL,CAAcoF,GAAd,CAAkB7F,IAAI,CAACP,EAAL,CAAQD,KAA1B,EAAiC,KAAjC;;AACA,YAAM,KAAK4E,WAAL,CAAiBpE,IAAjB,CAAN;;AAEA,UAAI,CAAC,KAAK+G,gBAAL,CAAsB/G,IAAtB,CAAL,EAAkC;AAChC,cAAM,KAAK+F,KAAL,CAAW/F,IAAX,CAAN;AACD;AACF,KAXD,CAWE,OAAO8B,GAAP,EAAY;AACZ,WAAK6E,OAAL,CAAa7E,GAAb;AACD;;AAED,WAAO9B,IAAP;AACD;AAED;;;;;;;AAKAmH,EAAAA,eAAe,CAACC,OAAD,EAAU;AACvB,UAAMC,QAAQ,GAAG,CAAC;AAAE3H,MAAAA,MAAF;AAAU4H,MAAAA,IAAI,GAAG;AAAjB,KAAD,KACf,KAAKzD,OAAL,CAAa;AACXnE,MAAAA,MADW;AAEXoE,MAAAA,eAAe,EAAEC,gCAAgBwD;AAFtB,KAAb,EAGGvF,IAHH,CAGQpC,UAAU,IAAI;AACpB,WAAK,MAAMX,SAAX,IAAwBW,UAAxB,EAAoC;AAClC,YAAI5B,4BAA4B,CAACkH,GAA7B,CAAiCjG,SAAS,CAACM,eAAV,CAA0BC,KAA3D,CAAJ,EAAuE;AACrE8H,UAAAA,IAAI,CAACE,OAAL,CAAavI,SAAS,CAACS,MAAvB;AACA,iBAAOT,SAAS,CAACS,MAAV,CAAiBF,KAAjB,KAA2BiI,0BAAUC,UAArC,GACHJ,IADG,GAEHD,QAAQ,CAAC;AAAE3H,YAAAA,MAAM,EAAET,SAAS,CAACS,MAApB;AAA4B4H,YAAAA;AAA5B,WAAD,CAFZ;AAGD;AACF;;AACD,YAAM,IAAIK,KAAJ,CAAW,iCAAgCjI,MAAO,EAAlD,CAAN;AACD,KAbD,CADF;;AAgBA,UAAMkI,UAAU,GAAG,CAACN,IAAD,EAAOO,MAAP,KACjBpG,OAAO,CAACqG,GAAR,CACER,IAAI,CAACxG,GAAL,CAAS,CAACpB,MAAD,EAASqI,CAAT,KACP,KAAKlE,OAAL,CAAa;AAAEnE,MAAAA;AAAF,KAAb,EAAyBsC,IAAzB,CAA8BpC,UAAU,IACtCA,UAAU,CAAC8C,IAAX,CACE6B,GAAG,IAAIA,GAAG,CAAC7E,MAAJ,CAAWF,KAAX,MAAsB8H,IAAI,CAACS,CAAC,GAAG,CAAL,CAAJ,GAAcT,IAAI,CAACS,CAAC,GAAG,CAAL,CAAJ,CAAYvI,KAA1B,GAAkCqI,MAAM,CAACrI,KAA/D,CADT,CADF,CADF,CADF,CADF;;AAWA,WAAOiC,OAAO,CAACqG,GAAR,CACLV,OAAO,CAACtG,GAAR,CAAYpB,MAAM,IAChB2H,QAAQ,CAAC;AAAE3H,MAAAA;AAAF,KAAD,CAAR,CACGsC,IADH,CACQsF,IAAI,IAAIM,UAAU,CAACN,IAAD,EAAO5H,MAAP,CAD1B,EAEGsC,IAFH,CAEQgG,QAAQ,IACZA,QAAQ,CAACC,MAAT,CAAgB,CAACjJ,MAAD,EAASC,SAAT,KAAuB,IAAIJ,WAAJ,CAAgB;AAAEG,MAAAA,MAAF;AAAUC,MAAAA;AAAV,KAAhB,CAAvC,EAA+E,IAA/E,CAHJ,CADF,CADK,CAAP;AASD;AAED;;;;;;;AAKA,QAAMiF,MAAN,CAAakD,OAAb,EAAsB;AACpB,SAAKN,kBAAL,GAA0B,IAAIjG,MAAJ,CACvB,KAAIuG,OAAO,CAACtG,GAAR,CAAY,CAAC;AAAEtB,MAAAA;AAAF,KAAD,KAAgB,GAAEA,KAAK,CAAC0I,OAAN,CAAc,KAAd,EAAqB,KAArB,CAA4B,EAA1D,EAA6DlH,IAA7D,CAAkE,GAAlE,CAAuE,GADpD,CAA1B;AAIA,SAAKY,QAAL,GAAgB,MAAMuG,iBAAQC,MAAR,EAAtB,CALoB,CAOpB;;AACA,UAAMC,KAAK,GAAG,MAAM,KAAKlB,eAAL,CAAqBC,OAArB,CAApB;AACA,SAAK7G,KAAL,CAAW4F,MAAX,CAAkBkC,KAAK,CAACvH,GAAN,CAAUd,IAAI,IAAI,MAAM,KAAKqG,QAAL,CAAcrG,IAAd,CAAxB,CAAlB,EAToB,CAWpB;;AACA,QAAIsI,YAAY,GAAG,IAAnB;;AACA,SAAK3B,OAAL,GAAe7E,GAAG,IAAI;AACpB,UAAIwG,YAAJ,EAAkB;AAChB;AACA;AACAxF,yBAAOgD,KAAP,CAAa,kBAAb,EAAiChE,GAAjC;;AACA;AACD;;AAEDwG,MAAAA,YAAY,GAAGxG,GAAf;AACA,WAAKvB,KAAL,CAAWgI,KAAX;AACA,WAAKhI,KAAL,CAAWiI,KAAX;AACD,KAXD;;AAaA,WAAO,IAAI/G,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,WAAKpB,KAAL,CAAWkI,MAAX,GAAoBzG,IAApB,CAAyB,YAAY;AACnC,cAAMmG,iBAAQO,KAAR,CAAc,KAAK9G,QAAnB,CAAN;;AAEA,YAAI0G,YAAJ,EAAkB;AAChB3G,UAAAA,MAAM,CAAC2G,YAAD,CAAN;AACA;AACD;;AAED,YAAI5D,MAAM,CAACiE,IAAP,CAAY,KAAKhI,WAAjB,EAA8BiC,MAAlC,EAA0C;AACxC,gBAAMgG,UAAU,GAAGlE,MAAM,CAACmE,OAAP,CAAe,KAAKlI,WAApB,EAAiCsH,MAAjC,CACjB,CAACH,GAAD,EAAM,CAACgB,EAAD,EAAK1G,QAAL,CAAN,KACE0F,GAAG,CAACZ,MAAJ,CACE9E,QAAQ,CAACtB,GAAT,CAAauB,CAAC,KAAK;AACjB0G,YAAAA,IAAI,EAAE1G,CAAC,CAAC5C,EAAF,CAAKD,KADM;AAEjBsJ,YAAAA,EAFiB;AAGjBE,YAAAA,IAAI,EACFpD,yBACEhC,KAAK,CAACmF,IAAN,CAAW1G,CAAC,CAACzC,UAAb,EAAyB8C,IAAzB,CAA8B,CAAC,GAAGuG,IAAH,CAAD,KAAcA,IAAI,CAAC/D,GAAL,CAAS4D,EAAT,CAA5C,EAA0D,CAA1D,CADF;AAJe,WAAL,CAAd,CADF,CAFe,EAYjB,EAZiB,CAAnB;AAeAnH,UAAAA,MAAM,CACJ,IAAIgG,KAAJ,CAAW,8BAA6BiB,UAAU,CAAChG,MAAX,GAAoB,CAApB,GAAwB,GAAxB,GAA8B,EAAG;;IAEjFgG,UAAU,CAAC9H,GAAX,CAAe,CAAC;AAAEiI,YAAAA,IAAF;AAAQC,YAAAA,IAAR;AAAcF,YAAAA;AAAd,WAAD,KAAyB,GAAEC,IAAK,OAAMC,IAAK,OAAMF,EAAG,EAAnE,EAAsE9H,IAAtE,CAA2E,MAA3E,CAAmF;CAF3E,CADI,CAAN;AAMA;AACD;;AAED,YAAI,KAAKM,aAAL,CAAmB4H,IAAvB,EAA6B;AAC3BvH,UAAAA,MAAM,CACJ,IAAIgG,KAAJ,CAAW;KAClB/D,KAAK,CAACmF,IAAN,CAAW,KAAKzH,aAAhB,EAA+BN,IAA/B,CAAoC,OAApC,CAA6C,EADtC,CADI,CAAN;AAIA;AACD;;AAED,YAAI4C,KAAK,CAACmF,IAAN,CAAW,KAAKtI,QAAhB,EAA0BiC,IAA1B,CAA+B,CAAC,GAAGyG,MAAH,CAAD,KAAgB,CAACA,MAAhD,CAAJ,EAA6D;AAC3D,gBAAM,IAAIxB,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAEDjG,QAAAA,OAAO;AACR,OA9CD;AA+CD,KAhDM,CAAP;AAiDD;;AA/f8B","sourcesContent":["import { ObjectIds } from 'node-opcua/lib/opcua_node_ids.js';\nimport { BrowseDirection } from 'node-opcua/lib/services/browse_service.js';\nimport { AttributeIds } from 'node-opcua/lib/services/read_service';\nimport { VariantArrayType, DataType } from 'node-opcua/lib/datamodel/variant';\nimport Logger from 'gulplog';\nimport PromiseQueue from 'p-queue';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport NodeId from '../model/opcua/NodeId';\nimport { ServerNode, ReferenceTypeIds, ReferenceTypeNames } from '../model/Node';\nimport Session from './Session';\n\n/**\n * A set of all hierarchical reference types.\n * @type {Set<number>}\n */\nconst HierachicalReferencesTypeIds = new Set([\n  ReferenceTypeIds.HasChild,\n  ReferenceTypeIds.Aggregates,\n  ReferenceTypeIds.HasComponent,\n  ReferenceTypeIds.HasOrderedComponent,\n  ReferenceTypeIds.HasHistoricalConfiguration,\n  ReferenceTypeIds.HasProperty,\n  ReferenceTypeIds.HasSubtype,\n  ReferenceTypeIds.HasEventSource,\n  ReferenceTypeIds.HasNotifier,\n  ReferenceTypeIds.Organizes,\n]);\n\n/**\n * A node discovered while browsing the server's database.\n */\nexport class BrowsedNode extends ServerNode {\n  /**\n   * Creates a new node.\n   * @param {Object} options The options to use.\n   * @param {?BrowsedNode} options.parent The parent node.\n   * @param {Object} options.reference The reference to pick metadata from.\n   */\n  constructor({ parent, reference, nodeClass, name }) {\n    super({\n      parent,\n      nodeClass: reference ? reference.nodeClass : nodeClass,\n      name: reference ? reference.browseName.name : name,\n    });\n\n    if (reference) {\n      // NOTE: You should always provide reference, this only for #createChild\n      this.addReference(ReferenceTypeIds.toParent, reference.referenceTypeId.value);\n\n      /** The node's id. @type {NodeId} */\n      this.id = reference.nodeId;\n    }\n\n    /** The node's value\n     * @type {node-opcua~Variant} */\n    this.value = {};\n  }\n\n  /**\n   * Add multiple references at once.\n   * @param {Object[]} references The references to add.\n   */\n  addReferences(references) {\n    references.forEach(reference => {\n      this.addReference(reference.referenceTypeId.value, reference.nodeId.value);\n    });\n  }\n\n  /**\n   * Creates new child node.\n   * @param {Object} options The options to use.\n   * @see {Node#createChild}\n   */\n  createChild(options) {\n    const node = super.createChild(options);\n\n    node.id = this.id;\n\n    return node;\n  }\n}\n\n/**\n * Browses the server database.\n */\nexport default class NodeBrowser {\n  /**\n   * Creates a new node browser.\n   * @param {Object} options The options to use.\n   * @param {number} [options.concurrency=250] The maximum of nodes to process in parallel.\n   * @param {function(node: BrowsedNode): Promise<any>} options.handleNode A custom node handler.\n   * @param {boolean} [options.recursive] If the whole node tree should be processed.\n   */\n  constructor({\n    concurrency = 250,\n    ignoreNodes = ProjectConfig.ignoreNodes,\n    handleNode,\n    recursive = true,\n  } = {}) {\n    /** The queue used to process nodes in parallel\n     * @type {p-queue~PQueue} */\n    this.queue = new PromiseQueue({\n      // autoStart: false,\n      concurrency,\n    });\n\n    /** A map of nodes already handled. Keys are ids, values are `true` if the node was already\n     * pushed and `false` otherwise.\n     * @type {Map<string, boolean>}\n     * */\n    this._handled = new Map();\n\n    this._waitingFor = {};\n\n    /** A regular expression matching all ignored nodes. @type {RegExp} */\n    this._ignoreNodesRegExp = new RegExp(`^(${ignoreNodes.map(n => n.value).join('|')})`);\n\n    /** If the browser should recurse. @type {boolean} */\n    this._recursive = recursive;\n\n    /** If a warning should be printed for attempting to pull sort order nodes\n     * @type {boolean} */\n    this._printSortOrderWarning = recursive;\n\n    /** The custom node handler. @type {function(node: BrowsedNode): Promise<any>} */\n    this._handleNode = handleNode;\n\n    /** The number of pushed (discovered and handled) nodes. @type {number} */\n    this._pushed = 0;\n\n    /** A map that maps node ids against their discovered hierarchical parent nodes. Used to detect\n     * reference conflicts.\n     * @type {Map<string, string>} */\n    this.parentNode = new Map();\n\n    this.ensureHandled = new Set();\n  }\n\n  /**\n   * Reads the given node's value.\n   * @param {BrowsedNode} node The node to read.\n   */\n  _readValue(node) {\n    if (!node.isVariable) {\n      return null;\n    }\n    return new Promise((resolve, reject) => {\n      this._session.readVariableValue(node.id, (err, result) => {\n        if (err) {\n          return reject(err);\n        }\n        return resolve(result && result.value);\n      });\n    }).then(value => {\n      if (node.nodeId.endsWith('.SortOrder')) {\n        const removed = [];\n        const siblings = node.parent.children.map(c => c.idName).filter(n => n !== 'SortOrder');\n        const existing = value.value\n          .map(({ name }) => name)\n          .filter(name => {\n            const exists = siblings.find(c => c === name);\n\n            if (exists) {\n              return true;\n            }\n\n            removed.push(name);\n            return false;\n          });\n\n        // We could also add missing references here...\n\n        if (removed.length) {\n          // eslint-disable-next-line no-param-reassign\n          value.value = existing.map(name => ({ namespaceIndex: 1, name }));\n          Logger.warn(`Removed ${removed.length} invalid references from '${node.nodeId}'`);\n        }\n      }\n\n      if (value) {\n        return value;\n      }\n\n      // Node is a variable but has no value -> Need to read dataType and arrayType directly.\n      return new Promise((resolve, reject) => {\n        const toRead = [AttributeIds.DataType, AttributeIds.ValueRank].map(attributeId => ({\n          nodeId: node.id,\n          attributeId,\n        }));\n        this._session.read(\n          toRead,\n          (\n            err,\n            _,\n            [\n              {\n                value: { value: dataType },\n              },\n              {\n                value: { value: valueRank },\n              },\n            ] = []\n          ) => {\n            if (err) return reject(err);\n\n            // FIXME: valueRank -2 (Any) and -3 (ScalarOrOneDimension) are not handled properly here\n            const arrayType = valueRank < 0 ? VariantArrayType.Scalar : VariantArrayType.Array;\n\n            return resolve({\n              dataType: DataType[dataType.value],\n              arrayType,\n              value: null,\n            });\n          }\n        );\n      });\n    });\n  }\n\n  // FIXME: Debounce á la https://runkit.com/5c347d277da2ad00125b6bc2/5c50161cbc21520012c42290\n  // FIXME: Move to api\n  /**\n   * Browses the server address space at the given node id.\n   * @param {Object} options The options to use.\n   */\n  _browse({ nodeId, browseDirection = BrowseDirection.Forward, resultMask = 63 }) {\n    return new Promise((resolve, reject) => {\n      this._session.browse({ nodeId, browseDirection, resultMask }, (err, data = []) =>\n        err ? reject(err) : resolve(data[0].references)\n      );\n    });\n  }\n\n  /**\n   * Browses a node.\n   * @param {BrowsedNode} node The node to browse.\n   */\n  _browseNode(node) {\n    return this._browse({ nodeId: node.id }).then(allReferences => {\n      const children = [];\n      const references = [];\n\n      const typeDefinitionReference = allReferences.find(\n        ref => ref.referenceTypeId.value === ReferenceTypeIds.HasTypeDefinition\n      );\n\n      const isUserGroup =\n        typeDefinitionReference &&\n        typeDefinitionReference.nodeId.value === 'ObjectTypes.ATVISE.Group';\n\n      allReferences.forEach(reference => {\n        // \"Cast\" ref.nodeId to NodeId\n        Object.setPrototypeOf(reference.nodeId, NodeId.prototype);\n\n        const ignored = this._ignoreNodesRegExp.test(reference.nodeId.value);\n        const external = this._isExternalReference(reference.nodeId.value);\n\n        if (\n          HierachicalReferencesTypeIds.has(reference.referenceTypeId.value) &&\n          !ignored &&\n          !external\n        ) {\n          if (\n            reference.referenceTypeId.value === ReferenceTypeIds.HasHistoricalConfiguration ||\n            (isUserGroup && reference.nodeId.value.split(node.nodeId).length === 1)\n          ) {\n            references.push(reference);\n            return;\n          }\n\n          if (\n            !ProjectConfig.preserveSortOrderNodes &&\n            reference.nodeId.value.endsWith('.SortOrder')\n          ) {\n            if (this._printSortOrderWarning) {\n              Logger.warn(`Skipped pulling an atvise builder sort order node.\n - Reason: These nodes are not consistent across pulls.\n - You can force pulling them by setting Atviseproject.preserveSortOrderNodes.`);\n              this._printSortOrderWarning = false;\n            }\n            return;\n          }\n\n          const [prefix, subPath] = reference.nodeId.value.split(node.id.value);\n          if (!subPath || prefix !== '') {\n            if (!ProjectConfig.isExternal(reference.nodeId.parent.value)) {\n              references.push(reference);\n\n              if (this._handled.get(reference.nodeId.value) === undefined) {\n                this.ensureHandled.add(reference.nodeId.value);\n              }\n              return;\n            }\n          }\n\n          const earlierParent = this.parentNode.get(reference.nodeId.value);\n          if (earlierParent) {\n            Logger.warn(`'${\n              reference.nodeId.value\n            }' was discovered as a child node of both '${earlierParent}' and '${node.id.value}'.\n  - Reference type (to the latter): ${ReferenceTypeNames[reference.referenceTypeId.value]} (${\n              reference.referenceTypeId.value\n            })`);\n          }\n\n          if (this._handled.get(reference.nodeId.value) === undefined) {\n            this.parentNode.set(reference.nodeId.value, node.id.value);\n            children.push(\n              new BrowsedNode({\n                parent: node,\n                reference,\n              })\n            );\n          } // else node is already handled\n        } else if (reference.referenceTypeId.value !== 50) {\n          // Added by atvise builder\n          // 'HasModelParent' reference set in atvise 3.3.2+\n          // Always points to parent node, which atscm already handles\n          if (\n            reference.referenceTypeId.value === 334 &&\n            reference.nodeId.value === (node.parent && node.parent.id.value)\n          ) {\n            return;\n          }\n\n          // Do not add ignored\n          if (!ignored) {\n            references.push(reference);\n          } else {\n            Logger.debug(\n              `Ignored reference from ${node.id.value} (${\n                ReferenceTypeNames[reference.referenceTypeId.value]\n              }) to ${reference.nodeId.value}`\n            );\n          }\n        }\n      });\n\n      // eslint-disable-next-line no-param-reassign\n      node.children = children;\n      node.addReferences(references);\n\n      return { children, references };\n    });\n  }\n\n  /**\n   * Finishes processing a given node: After calling {@link NodeBrowser#_handleNode}, it resolves\n   * is's dependencies.\n   * @param {BrowsedNode} node The node handled.\n   */\n  async _push(node) {\n    if (this._handled.get(node.id.value)) {\n      Logger.error('Prevented duplicate handling of', node.id.value);\n      return;\n    }\n\n    // Prevent duplicate pushes while reading value file\n    this._handled.set(node.id.value, 'processing');\n\n    // eslint-disable-next-line no-param-reassign\n    node.value = (await this._readValue(node)) || node.value;\n\n    // TODO: Remove additional properties (children, ...) for better memory-usage\n\n    const originalId = node.id.value;\n\n    await this._handleNode(node);\n\n    this._pushed += 1;\n\n    // Do not proceed if queue is stopped (because an error occured)\n    if (!this._recursive || this.queue.isPaused) {\n      // Queue is stopped, not adding...\n      return;\n    }\n\n    this.queue.addAll(node.children.map(child => () => this._process(child)));\n\n    const idValue = node.id.value;\n    this._handled.set(idValue, true);\n    this.ensureHandled.delete(originalId);\n\n    // Handle dependencies\n    if (this._waitingFor[idValue]) {\n      this._waitingFor[idValue].forEach(dep => {\n        // eslint-disable-next-line no-param-reassign\n        if (--dep.dependencies === 0) {\n          // Adding as dependencies are resolved\n          this.queue.add(() => this._push(dep)).catch(this._reject);\n        }\n      });\n\n      delete this._waitingFor[idValue];\n    }\n  }\n\n  /**\n   * Instructs the browser to handle a node that would otherwise be queued behind others (eg: its\n   * parent node).\n   * @param {BrowsedNode} node The node to add.\n   * @return {Promise<?BrowsedNode>} The fully processed node.\n   */\n  addNode(node) {\n    if (this.queue.isPaused) {\n      Logger.debug('Queue is stopped, not adding...');\n      return Promise.resolve();\n    }\n\n    return this.queue.add(() => this._handleNode(node, { transform: false })).catch(this._reject);\n  }\n\n  /**\n   * Returns `true` for node ids that should be treated as external references.\n   * @param {string|number} idValue Value of the id to check.\n   * @return {boolean} If the id should be treated as external.\n   */\n  _isExternalReference(idValue) {\n    // FIXME: Allow plugins\n    return typeof idValue !== 'string' || !this._sourceNodesRegExp.test(idValue);\n  }\n\n  /**\n   * Returns `true` if a node has dependencies it should be queued behind.\n   * @param {BrowsedNode} node The node to check.\n   */\n  _hasDependencies(node) {\n    let dependencyCount = 0;\n\n    for (const references of node.references.values()) {\n      for (const reference of references) {\n        if (\n          this._handled.get(reference) !== true &&\n          !this._isExternalReference(reference) &&\n          !this._ignoreNodesRegExp.test(reference)\n        ) {\n          dependencyCount++;\n          this._waitingFor[reference] = (this._waitingFor[reference] || []).concat(node);\n        }\n      }\n    }\n\n    // eslint-disable-next-line no-param-reassign\n    node.dependencies = dependencyCount;\n\n    return dependencyCount > 0;\n  }\n\n  /**\n   * Processes a single node: Requires special error handling.\n   * @param {BrowsedNode} node The node to process.\n   * @return {Promise<?BrowsedNode>} The fully processed node.\n   */\n  async _process(node) {\n    try {\n      if (this._handled.has(node.id.value)) {\n        // Already queued\n        return undefined;\n      }\n      this._handled.set(node.id.value, false);\n      await this._browseNode(node);\n\n      if (!this._hasDependencies(node)) {\n        await this._push(node);\n      }\n    } catch (err) {\n      this._reject(err);\n    }\n\n    return node;\n  }\n\n  /**\n   * Discovers and browses the source nodes.\n   * @param {Array<string, NodeId>} nodeIds The source ids.\n   * @return {Promise<Node[]>} Resolved once finished.\n   */\n  _getSourceNodes(nodeIds) {\n    const browseUp = ({ nodeId, path = [] }) =>\n      this._browse({\n        nodeId,\n        browseDirection: BrowseDirection.Inverse,\n      }).then(references => {\n        for (const reference of references) {\n          if (HierachicalReferencesTypeIds.has(reference.referenceTypeId.value)) {\n            path.unshift(reference.nodeId);\n            return reference.nodeId.value === ObjectIds.RootFolder\n              ? path\n              : browseUp({ nodeId: reference.nodeId, path });\n          }\n        }\n        throw new Error(`Unable to find parent node of ${nodeId}`);\n      });\n\n    const browseDown = (path, target) =>\n      Promise.all(\n        path.map((nodeId, i) =>\n          this._browse({ nodeId }).then(references =>\n            references.find(\n              ref => ref.nodeId.value === (path[i + 1] ? path[i + 1].value : target.value)\n            )\n          )\n        )\n      );\n\n    return Promise.all(\n      nodeIds.map(nodeId =>\n        browseUp({ nodeId })\n          .then(path => browseDown(path, nodeId))\n          .then(pathDown =>\n            pathDown.reduce((parent, reference) => new BrowsedNode({ parent, reference }), null)\n          )\n      )\n    );\n  }\n\n  /**\n   * Starts the browser of the given nodes.\n   * @param {NodeId[]} nodeIds The nodes to browse.\n   * @return {Promise<any>} Resolved once all nodes are finished.\n   */\n  async browse(nodeIds) {\n    this._sourceNodesRegExp = new RegExp(\n      `^(${nodeIds.map(({ value }) => `${value.replace(/\\./g, '\\\\.')}`).join('|')})`\n    );\n\n    this._session = await Session.create();\n\n    // Add source nodes\n    const nodes = await this._getSourceNodes(nodeIds);\n    this.queue.addAll(nodes.map(node => () => this._process(node)));\n\n    // Queue error handling\n    let processError = null;\n    this._reject = err => {\n      if (processError) {\n        // Multiple errors occured. In most cases this means, that the server connection was closed\n        // after the first error.\n        Logger.debug('Additional error', err);\n        return;\n      }\n\n      processError = err;\n      this.queue.pause();\n      this.queue.clear();\n    };\n\n    return new Promise((resolve, reject) => {\n      this.queue.onIdle().then(async () => {\n        await Session.close(this._session);\n\n        if (processError) {\n          reject(processError);\n          return;\n        }\n\n        if (Object.keys(this._waitingFor).length) {\n          const unresolved = Object.entries(this._waitingFor).reduce(\n            (all, [to, children]) =>\n              all.concat(\n                children.map(c => ({\n                  from: c.id.value,\n                  to,\n                  type:\n                    ReferenceTypeNames[\n                      Array.from(c.references).find(([, refs]) => refs.has(to))[0]\n                    ],\n                }))\n              ),\n            []\n          );\n\n          reject(\n            new Error(`Unable to resolve reference${unresolved.length > 1 ? 's' : ''}:\n\n  ${unresolved.map(({ from, type, to }) => `${from} → (${type}) → ${to}`).join('\\n  ')}\n`)\n          );\n          return;\n        }\n\n        if (this.ensureHandled.size) {\n          reject(\n            new Error(`Some referenced nodes were not handled,\n - ${Array.from(this.ensureHandled).join('\\n - ')}`)\n          );\n          return;\n        }\n\n        if (Array.from(this._handled).find(([, pushed]) => !pushed)) {\n          throw new Error('A node was processed, but not pushed');\n        }\n\n        resolve();\n      });\n    });\n  }\n}\n"],"file":"NodeBrowser.js"}