{"version":3,"sources":["../../../src/lib/server/NodeBrowser.js"],"names":["HierachicalReferencesTypeIds","Set","HasChild","Aggregates","HasComponent","HasOrderedComponent","HasHistoricalConfiguration","HasProperty","HasSubtype","HasEventSource","HasNotifier","Organizes","BrowsedNode","constructor","parent","reference","nodeClass","name","browseName","addReference","toParent","referenceTypeId","value","id","nodeId","addReferences","references","forEach","createChild","options","node","NodeBrowser","nodes","ignoreNodes","recursive","_sourceNodes","_sourceNodesRegExp","RegExp","map","replace","join","_ignoreNodesRegExp","n","_recursive","_discoveredNodes","_nextToBrowse","_queued","_pushed","_dependingNodes","_dependencies","_isStopped","_isDestroyed","_ended","create","then","session","_session","_getSourceNodes","_browseNext","catch","err","_isDisconnected","onError","disconnect","close","destroy","stop","_browse","Promise","resolve","reject","browse","results","_readValues","readVariableValue","_discoveredNode","dependencyCount","values","namespace","has","test","push","_pushNode","onNode","add","dependency","_getSourcePaths","paths","browseNext","index","browsePath","items","browseDirection","BrowseDirection","Inverse","resultMask","result","i","statusCode","Error","RootFolder","unshift","length","_browseSourcePaths","targets","remainingPaths","Array","browsePaths","p","shift","Forward","item","next","find","browseCount","Math","min","debug","browseNow","splice","all","isChildReference","prefix","postfix","split","Object","setPrototypeOf","prototype","onEnd","start"],"mappings":"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","file":"NodeBrowser.js","sourcesContent":["import { ObjectIds, browse_service as BrowseService } from 'node-opcua';\nimport Logger from 'gulplog';\nimport NodeId from '../model/opcua/NodeId';\nimport { ServerNode, ReferenceTypeIds } from '../model/Node';\nimport Session from './Session';\n\n/**\n * A set of all hierarchical reference types.\n * @type {Set<number>}\n */\nconst HierachicalReferencesTypeIds = new Set([\n  ReferenceTypeIds.HasChild,\n  ReferenceTypeIds.Aggregates,\n  ReferenceTypeIds.HasComponent,\n  ReferenceTypeIds.HasOrderedComponent,\n  ReferenceTypeIds.HasHistoricalConfiguration,\n  ReferenceTypeIds.HasProperty,\n  ReferenceTypeIds.HasSubtype,\n  ReferenceTypeIds.HasEventSource,\n  ReferenceTypeIds.HasNotifier,\n  ReferenceTypeIds.Organizes,\n]);\n\n/**\n * A node discovered while browsing the server's database.\n */\nexport class BrowsedNode extends ServerNode {\n\n  /**\n   * Creates a new node.\n   * @param {Object} options The options to use.\n   * @param {?BrowsedNode} options.parent The parent node.\n   * @param {Object} options.reference The reference to pick metadata from.\n   */\n  constructor({ parent, reference }) {\n    super({\n      parent,\n      nodeClass: reference.nodeClass,\n      name: reference.browseName.name,\n    });\n\n    this.addReference(ReferenceTypeIds.toParent, reference.referenceTypeId.value);\n\n    /** The node's id. @type {NodeId} */\n    this.id = reference.nodeId;\n  }\n\n  /**\n   * Add multiple references at once.\n   * @param {Object[]} references The references to add.\n   */\n  addReferences(references) {\n    references.forEach(reference => {\n      this.addReference(reference.referenceTypeId.value, reference.nodeId.value);\n    });\n  }\n\n  /**\n   * Creates new child node.\n   * @param {Object} options The options to use.\n   * @see {Node#createChild}\n   */\n  createChild(options) {\n    const node = super.createChild(options);\n\n    node.id = this.id;\n\n    return node;\n  }\n\n}\n\n/**\n * Browses the server database.\n */\nexport default class NodeBrowser {\n\n  /**\n   * Creates a new browser.\n   * @param {Object} options The options to use.\n   * @param {NodeId[]} options.nodes The nodes to browse.\n   * @param {NodeId[]} options.ignoreNodes The nodes to igore.\n   * @param {boolean} options.recursive If the browser should recurse.\n   */\n  constructor({ nodes, ignoreNodes, recursive }/* : { nodes: NodeId[] } */ = {}) {\n    /** The browser's source nodes @type {NodeId[]} */\n    this._sourceNodes = nodes;\n\n    /** A regular expression matching all source nodes. @type {RegExp} */\n    this._sourceNodesRegExp = new RegExp(`^(${nodes\n      .map(({ value }) => `${value.replace(/\\./g, '\\\\.')}`)\n      .join('|')})`);\n    /** A regular expression matching all ignored nodes. @type {RegExp} */\n    this._ignoreNodesRegExp = new RegExp(`^(${ignoreNodes\n      .map(n => n.value)\n      .join('|')})`);\n\n    /** If the browser should recurse. @type {boolean} */\n    this._recursive = recursive;\n\n    /** Nodes discovered but not yet pushed. @type {ServerNode[]} */\n    this._discoveredNodes = [];\n    /** Nodes that should be browsed next. @type {NodeId[]} */\n    this._nextToBrowse = [];\n    /** Nodes queued. @type {Set<string>} */\n    this._queued = new Set();\n    /** Nodes pushed. @type {Set<string>} */\n    this._pushed = new Set();\n    /** Node dependency map. @type {Map<string, SourceNode[]>} */\n    this._dependingNodes = {};\n    /** The count of dependencies for nodes. @type {Map<string, number>} */\n    this._dependencies = {};\n\n    /** If the browser is stopped. @type {boolean} */\n    this._isStopped = false;\n    /** If the browser is destroyed. @type {boolean} */\n    this._isDestroyed = false;\n    /** If the browser ended. @type {boolean} */\n    this._ended = false;\n\n    Session.create()\n      .then(session => (this._session = session))\n      .then(() => this._getSourceNodes())\n      .then(() => this._browseNext())\n      .catch(err => {\n        if (!this._isDisconnected) {\n          this.onError(err);\n        }\n      });\n  }\n\n  /**\n   * Disconnects the browser.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  disconnect() {\n    this._isDestroyed = true;\n    return Session.close(this._session);\n  }\n\n  /**\n   * Destroys the browser.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  destroy() {\n    this.stop();\n    this._isDestroyed = true;\n\n    return this.disconnect();\n  }\n\n  /**\n   * Browses the given nodes.\n   * @param {NodeId[]} nodes The nodes to browse.\n   * @return {Promise<Object[]>} The browse results.\n   */\n  _browse(nodes) {\n    return new Promise((resolve, reject) => {\n      this._session.browse(nodes, (err, results) => {\n        if (err) { return reject(err); }\n        return resolve(results);\n      });\n    });\n  }\n\n  /**\n   * Reads the given nodes.\n   * @param {NodeId[]} nodes The nodes to read.\n   * @return {Promise<Object[]>} The read results.\n   */\n  _readValues(nodes) {\n    return new Promise((resolve, reject) => {\n      this._session.readVariableValue(nodes, (err, results) => {\n        if (err) { return reject(err); }\n        return resolve(results);\n      });\n    });\n  }\n\n  /**\n   * Called once a new node was discovered. Pushes it if possible.\n   * @param {ServerNode} node The discovered node.\n   */\n  _discoveredNode(node) {\n    let dependencyCount = 0;\n\n    for (const references of node.references.values()) {\n      for (const reference of references) {\n        if (\n          reference.namespace &&\n          !this._pushed.has(reference) &&\n          !this._sourceNodesRegExp.test(reference)\n        ) {\n          this._dependingNodes[reference] = this._dependingNodes[reference] || [];\n          this._dependingNodes[reference].push(node);\n          dependencyCount += 1;\n        }\n      }\n    }\n\n    if (dependencyCount) { // has dependencies\n      this._dependencies[node.id.value] = dependencyCount;\n    } else {\n      this._pushNode(node);\n    }\n  }\n\n  /**\n   * Pushes the given node and queues it's dependents.\n   * @param {ServerNode} node The pushed node.\n   */\n  _pushNode(node) {\n    if (!this._isStopped) {\n      this.onNode(node);\n    } else {\n      this._discoveredNodes.push(node);\n    }\n\n    this._pushed.add(node.id.value);\n\n    if (this._dependingNodes[node.id.value]) {\n      this._dependingNodes[node.id.value].forEach(dependency => {\n        this._dependencies[dependency.id.value] -= 1;\n\n        if (this._dependencies[dependency.id.value] === 0) {\n          this._pushNode(dependency);\n        } // else: Still got dependencies\n      });\n\n      delete this._dependingNodes[node.id.value];\n    }\n  }\n\n  /**\n   * Browses the source node to the root node.\n   * @param {NodeId[]} nodes The current nodes.\n   * @return {Promise<string[]>} The discovered source path.\n   */\n  async _getSourcePaths(nodes) {\n    const paths = nodes.map(() => []);\n\n    let browseNext = nodes.map((nodeId, index) => ({ nodeId, index }));\n    const browsePath = async items => {\n      browseNext = [];\n\n      const results = await this._browse(items.map(({ nodeId }) => ({\n        nodeId,\n        browseDirection: BrowseService.BrowseDirection.Inverse,\n        resultMask: 63,\n      })));\n\n      results.forEach((result, i) => {\n        if (result.statusCode.value !== 0) {\n          throw new Error(`Unable to browse ${items[i].nodeId}`);\n        }\n\n        for (const reference of result.references) {\n          if (HierachicalReferencesTypeIds.has(reference.referenceTypeId.value)) {\n            const index = items[i].index;\n\n            if (reference.nodeId.value !== ObjectIds.RootFolder) {\n              browseNext.push({ nodeId: reference.nodeId, index });\n            }\n\n            paths[index].unshift(reference.nodeId);\n\n            return;\n          }\n        }\n\n        throw new Error(`Unable to get parent node of ${items[i].nodeId}`);\n      });\n    };\n\n    while (browseNext.length) {\n      await browsePath(browseNext);\n    }\n\n    return paths;\n  }\n\n  /**\n   * Browses the source nodes's root paths.\n   * @param {string[][]} paths The source paths.\n   * @param {NodeId} targets The target nodes to browse onto.\n   */\n  async _browseSourcePaths(paths, targets) {\n    const remainingPaths = paths;\n    const nodes = new Array(paths.length);\n\n    const browsePaths = async () => {\n      const browse = [];\n      remainingPaths.forEach((p, index) => {\n        if (p.length) { browse.push({ nodeId: p.shift(), index }); }\n      });\n\n      const results = await this._browse(browse.map(({ nodeId }) => ({\n        nodeId,\n        browseDirection: BrowseService.BrowseDirection.Forward,\n        resultMask: 63,\n      })));\n\n      results.forEach((result, i) => {\n        const item = browse[i];\n        const next = remainingPaths[item.index][0] || targets[item.index];\n\n        for (const reference of result.references) {\n          if (reference.nodeId.value === next.value) {\n            nodes[item.index] = new BrowsedNode({\n              parent: nodes[item.index],\n              reference,\n            });\n\n            return;\n          }\n        }\n\n        throw new Error('Fatal error');\n      });\n    };\n\n    while (remainingPaths.find(i => i.length)) {\n      await browsePaths();\n    }\n\n    return nodes;\n  }\n\n  /**\n   * Discovers and browses the source nodes.\n   * @return {Promise<void>} Resolved once finished.\n   */\n  _getSourceNodes() {\n    return this._getSourcePaths(this._sourceNodes)\n      .then(paths => this._browseSourcePaths(paths, this._sourceNodes))\n      .then(nodes => {\n        nodes.forEach(node => this._nextToBrowse.push(node));\n      });\n  }\n\n  /**\n   * Browses the next nodes queued.\n   */\n  async _browseNext() {\n    if (this._isDestroyed) { return Promise.resolve(); }\n\n    const browseCount = Math.min(this._nextToBrowse.length, 10000);\n    Logger.debug('browsing', browseCount, 'nodes...');\n    const browseNow = this._nextToBrowse.splice(0, browseCount);\n\n    const [results, values] = await Promise.all([\n      this._browse(browseNow.map(node => ({\n        nodeId: node.id,\n        browseDirection: BrowseService.BrowseDirection.Forward,\n        resultMask: 63,\n      }))),\n      this._readValues(browseNow.map(node => node.id)),\n    ]);\n\n    const isChildReference = (parent, reference) => {\n      const [prefix, postfix] = reference.nodeId.value.split(parent.id.value);\n\n      return prefix === '' && postfix/* .slice(1) === reference.browseName.name */;\n    };\n\n    results.forEach((result, i) => {\n      const node = browseNow[i];\n      const references = [];\n\n      // FIXME: Check status\n      node.value = values[i].value;\n\n      result.references.forEach(reference => {\n        // \"Cast\" ref.nodeId to NodeId\n        Object.setPrototypeOf(reference.nodeId, NodeId.prototype);\n\n        if (\n          HierachicalReferencesTypeIds.has(reference.referenceTypeId.value) &&\n          isChildReference(node, reference) &&\n          !this._ignoreNodesRegExp.test(reference.nodeId.value)\n        ) {\n          if (!this._queued.has(reference.nodeId.value) && this._recursive) {\n            this._queued.add(reference.nodeId.value);\n            this._nextToBrowse.push(new BrowsedNode({\n              parent: node,\n              reference,\n            }));\n          }\n        } else if (reference.referenceTypeId.value !== 50) { // Added by atvise builder\n          references.push(reference);\n        }\n      });\n\n      node.addReferences(references);\n      this._discoveredNode(node);\n    });\n\n    if (this._nextToBrowse.length) {\n      return this._browseNext();\n    }\n\n    // All nodes have been browsed\n    if (this._isStopped) {\n      this._ended = true;\n      return Promise.resolve();\n    }\n    return this.onEnd();\n  }\n\n  /**\n   * Starts the browser.\n   */\n  start() {\n    this._isStopped = false;\n\n    while (this._discoveredNodes.length) {\n      this.onNode(this._discoveredNodes.shift());\n      if (this._isStopped) { break; }\n    }\n\n    if (!this._discoveredNodes.length && this._ended) {\n      this.onEnd();\n    }\n  }\n\n  /**\n   * Stops the browser.\n   */\n  stop() {\n    this._isStopped = true;\n  }\n\n}\n"]}