{"version":3,"sources":["../../../../src/lib/server/scripts/CallScriptStream.js"],"names":["CallScriptStream","methodId","NodeIdType","STRING","scriptId","Error","scriptBaseId","parent","scriptParameters","file","inputArguments","params","paramNames","Object","keys","dataType","NodeId","value","String","arrayType","Array","Variant","map","key","processErrorMessage","relative","processChunk","handleErrors","err","status","success","processedStatus","atscmScript","match","BadMethodInvalid","description"],"mappings":";;;;;;AAAA;;AACA;;;;AACA;;;;;;AAEA;;;;AAIe,MAAMA,gBAAN,oCAAgD;;AAE7D;;;;AAIA,MAAIC,QAAJ,GAAe;AACb,WAAO,qBAAW,iBAAOC,UAAP,CAAkBC,MAA7B,EAAqC,iCAArC,EAAwE,CAAxE,CAAP;AACD;;AAED;;;;;AAKA,MAAIC,QAAJ,GAAe;AACb,UAAM,IAAIC,KAAJ,CAAU,uCAAV,CAAN;AACD;;AAED;;;;AAIA,MAAIC,YAAJ,GAAmB;AACjB,WAAO,KAAKF,QAAL,CAAcG,MAArB;AACD;;AAED;;;;;AAKAC,mBAAiBC,IAAjB,EAAuB;AAAE;AACvB,WAAO,EAAP;AACD;;AAED;;;;;AAKAC,iBAAeD,IAAf,EAAqB;AACnB,UAAME,SAAS,KAAKH,gBAAL,CAAsBC,IAAtB,CAAf;;AAEA,QAAIE,WAAW,IAAf,EAAqB;AACnB,aAAO,IAAP;AACD;;AAED,UAAMC,aAAaC,OAAOC,IAAP,CAAYH,MAAZ,CAAnB;;AAEA,WAAO,CACL;AACEI,gBAAU,oBAASC,MADrB;AAEEC,aAAO,KAAKb;AAFd,KADK,EAKL;AACEW,gBAAU,oBAASC,MADrB;AAEEC,aAAO,KAAKX;AAFd,KALK,EASL;AACES,gBAAU,oBAASG,MADrB;AAEEC,iBAAW,4BAAiBC,KAF9B;AAGEH,aAAOL;AAHT,KATK,EAcL;AACEG,gBAAU,oBAASM,OADrB;AAEEF,iBAAW,4BAAiBC,KAF9B;AAGEH,aAAOL,WAAWU,GAAX,CAAeC,OAAOZ,OAAOY,GAAP,CAAtB;AAHT,KAdK,CAAP;AAoBD;;AAED;;;;;AAKAC,sBAAoBf,IAApB,EAA0B;AACxB,WAAQ,wBAAuB,KAAKL,QAAS,QAAOK,KAAKgB,QAAS,EAAlE;AACD;;AAED;;;;;;;AAOAC,eAAajB,IAAb,EAAmBkB,YAAnB,EAAiC;AAC/B,UAAMD,YAAN,CAAmBjB,IAAnB,EAAyB,CAACmB,GAAD,EAAMC,MAAN,EAAcC,OAAd,KAA0B;AACjD,YAAMC,kBAAkBF,MAAxB;;AAEA,YAAMG,cAAc,KAAK5B,QAAL,CAAca,KAAd,CAAoBgB,KAApB,CAA0B,4BAA1B,CAApB;AACA,UAAIJ,WAAW,uBAAYK,gBAAvB,IAA2CF,WAA/C,EAA4D;AAC1DD,wBAAgBI,WAAhB,GAA+B,QAAOH,YAAY,CAAZ,CAAe;wCAArD;AAED;;AAEDL,mBAAaC,GAAb,EAAkBG,eAAlB,EAAmCD,OAAnC;AACD,KAVD;AAWD;;AApG4D;kBAA1C9B,gB","file":"CallScriptStream.js","sourcesContent":["import { DataType, VariantArrayType, StatusCodes } from 'node-opcua';\nimport NodeId from '../../model/opcua/NodeId';\nimport CallMethodStream from './CallMethodStream';\n\n/**\n * A stream that calls atvise server scripts for all passed nodes.\n * @abstract\n */\nexport default class CallScriptStream extends CallMethodStream {\n\n  /**\n   * The id of the *callScript* method.\n   * @type {NodeId}\n   */\n  get methodId() {\n    return new NodeId(NodeId.NodeIdType.STRING, 'AGENT.SCRIPT.METHODS.callScript', 1);\n  }\n\n  /**\n   * **Must be implemented by all subclasses:** The id of the script to call.\n   * @type {NodeId}\n   * @abstract\n   */\n  get scriptId() {\n    throw new Error('Must be implemented by all subclasses');\n  }\n\n  /**\n   * Id of the script's base object.\n   * @type {NodeId}\n   */\n  get scriptBaseId() {\n    return this.scriptId.parent;\n  }\n\n  /**\n   * Returns the parameters to call the script with for the given file.\n   * @param {AtviseFile} file The processed file.\n   * @return {Object} The parameters passed to the script.\n   */\n  scriptParameters(file) { // eslint-disable-line no-unused-vars\n    return {};\n  }\n\n  /**\n   * Creates the raw method input arguments for the given file.\n   * @param {AtviseFile} file The processed file.\n   * @return {?node-opcua~Variant[]} Input arguments for the *callScript* method.\n   */\n  inputArguments(file) {\n    const params = this.scriptParameters(file);\n\n    if (params === null) {\n      return null;\n    }\n\n    const paramNames = Object.keys(params);\n\n    return [\n      {\n        dataType: DataType.NodeId,\n        value: this.scriptId,\n      },\n      {\n        dataType: DataType.NodeId,\n        value: this.scriptBaseId,\n      },\n      {\n        dataType: DataType.String,\n        arrayType: VariantArrayType.Array,\n        value: paramNames,\n      },\n      {\n        dataType: DataType.Variant,\n        arrayType: VariantArrayType.Array,\n        value: paramNames.map(key => params[key]),\n      },\n    ];\n  }\n\n  /**\n   * Returns the error message logged if running the script fails.\n   * @param {AtviseFile} file The processed file.\n   * @return {string} The resulting error message.\n   */\n  processErrorMessage(file) {\n    return `Error running script ${this.scriptId} for ${file.relative}`;\n  }\n\n  /**\n   * Calls the script specified in {@link CallScriptStream#scriptId}. If the script does not exist\n   * but could be imported by running `atscm import` a special status description is returned.\n   * @param {vinyl~File} file The file being processed.\n   * @param {function(err: Error, status: node-opcua~StatusCodes, success: function)} handleErrors\n   * The error handler to call. See {@link QueueStream#processChunk} for details.\n  */\n  processChunk(file, handleErrors) {\n    super.processChunk(file, (err, status, success) => {\n      const processedStatus = status;\n\n      const atscmScript = this.scriptId.value.match(/SERVERSCRIPTS\\.atscm\\.(.*)/);\n      if (status === StatusCodes.BadMethodInvalid && atscmScript) {\n        processedStatus.description = `The '${atscmScript[1]}' script does not exist.\n- Did you forget to run 'atscm import'?`;\n      }\n\n      handleErrors(err, processedStatus, success);\n    });\n  }\n\n}\n"]}