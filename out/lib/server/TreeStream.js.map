{"version":3,"sources":["../../../src/lib/server/TreeStream.js"],"names":["TreeStream","constructor","options","_nodeIdsProcessing","Set","_waitingForParent","on","nodeId","error","id","toString","waiting","warn","length","forEach","chunk","_enqueueChunk","delete","file","add","parentProcessing","has","parent","key","push"],"mappings":";;;;;;AAAA;;;;AACA;;;;;;AAEA;;;;;AAKe,MAAMA,UAAN,+BAAqC;;AAElD;;;;AAIAC,cAAYC,UAAU,EAAtB,EAA0B;AACxB,UAAMA,OAAN;;AAEA;;;;AAIA,SAAKC,kBAAL,GAA0B,IAAIC,GAAJ,EAA1B;;AAEA;;;;AAIA,SAAKC,iBAAL,GAAyB,EAAzB;;AAEA,SAAKC,EAAL,CAAQ,iBAAR,EAA2B,CAAC,EAAEC,MAAF,EAAD,EAAaC,KAAb,KAAuB;AAChD,YAAMC,KAAKF,OAAOG,QAAP,EAAX;AACA,YAAMC,UAAU,KAAKN,iBAAL,CAAuBI,EAAvB,CAAhB;;AAEA,UAAIE,OAAJ,EAAa;AACX,YAAIH,KAAJ,EAAW;AACT,4BAAOI,IAAP,CAAa,YAAWD,QAAQE,MAAO,cAAvC;AACD,SAFD,MAEO;AACLF,kBAAQG,OAAR,CAAgBC,SAAS;AACvB,kBAAMC,aAAN,CAAoBD,KAApB;AACD,WAFD;AAGD;;AAED,eAAO,KAAKV,iBAAL,CAAuBI,EAAvB,CAAP;AACD;;AAED,WAAKN,kBAAL,CAAwBc,MAAxB,CAA+BR,EAA/B;AACD,KAjBD;AAkBD;;AAED;;;;AAIAO,gBAAcE,IAAd,EAAoB;AAClB,UAAM,EAAEX,MAAF,KAAaW,IAAnB;;AAEA,SAAKf,kBAAL,CAAwBgB,GAAxB,CAA4BZ,OAAOG,QAAP,EAA5B;;AAEA,UAAMU,mBAAmB,KAAKjB,kBAAL,CAAwBkB,GAAxB,CAA4Bd,OAAOe,MAAP,CAAcZ,QAAd,EAA5B,CAAzB;;AAEA,QAAIU,gBAAJ,EAAsB;AACpB,YAAMG,MAAMhB,OAAOe,MAAP,CAAcZ,QAAd,EAAZ;;AAEA,UAAI,CAAC,KAAKL,iBAAL,CAAuBkB,GAAvB,CAAL,EAAkC;AAChC,aAAKlB,iBAAL,CAAuBkB,GAAvB,IAA8B,CAACL,IAAD,CAA9B;AACD,OAFD,MAEO;AACL,aAAKb,iBAAL,CAAuBkB,GAAvB,EAA4BC,IAA5B,CAAiCN,IAAjC;AACD;AACF,KARD,MAQO;AACL;AACA,YAAMF,aAAN,CAAoBE,IAApB;AACD;AACF;;AAhEiD;kBAA/BlB,U","file":"TreeStream.js","sourcesContent":["import Logger from 'gulplog';\nimport QueueStream from './QueueStream';\n\n/**\n * A stream of {@link AtviseFile}s that ensures the chunks are processed respecting the parent-child\n * relations between nodes.\n * @type {Object}\n */\nexport default class TreeStream extends QueueStream {\n\n  /**\n   * Creates a new stream.\n   * @param {Object} [options={}] The options passed to the underlying {@link QueueStream}.\n   */\n  constructor(options = {}) {\n    super(options);\n\n    /**\n     * A set of nodes currently handled.\n     * @type {Set}\n     */\n    this._nodeIdsProcessing = new Set();\n\n    /**\n     * Files stored against the nodes they are queued behind to respect the node tree.\n     * @type {Object}\n     */\n    this._waitingForParent = {};\n\n    this.on('processed-chunk', ({ nodeId }, error) => {\n      const id = nodeId.toString();\n      const waiting = this._waitingForParent[id];\n\n      if (waiting) {\n        if (error) {\n          Logger.warn(`Skipping ${waiting.length} child nodes`);\n        } else {\n          waiting.forEach(chunk => {\n            super._enqueueChunk(chunk);\n          });\n        }\n\n        delete this._waitingForParent[id];\n      }\n\n      this._nodeIdsProcessing.delete(id);\n    });\n  }\n\n  /**\n   * Enqueues a new chunk.\n   * @param {AtviseFile} file The file to enqueue for processing.\n   */\n  _enqueueChunk(file) {\n    const { nodeId } = file;\n\n    this._nodeIdsProcessing.add(nodeId.toString());\n\n    const parentProcessing = this._nodeIdsProcessing.has(nodeId.parent.toString());\n\n    if (parentProcessing) {\n      const key = nodeId.parent.toString();\n\n      if (!this._waitingForParent[key]) {\n        this._waitingForParent[key] = [file];\n      } else {\n        this._waitingForParent[key].push(file);\n      }\n    } else {\n      // Chunk can be enqueued safely\n      super._enqueueChunk(file);\n    }\n  }\n\n}\n"]}