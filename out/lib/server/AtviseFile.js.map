{"version":3,"sources":["../../../src/lib/server/AtviseFile.js"],"names":["AtviseTypesByValue","reduce","result","type","Object","assign","typeDefinition","value","AtviseTypesByIdentifier","identifier","ExtensionForDataType","Boolean","XmlElement","DataTypeForExtension","types","keys","typeExtensions","map","t","toLowerCase","VariableTypeDefinition","NodeIdType","NUMERIC","PropertyTypeDefinition","ExtensionRegExp","Decoder","stringValue","SByte","parseInt","Byte","Int16","UInt16","Int32","UInt32","Int64","JSON","parse","UInt64","Float","parseFloat","Double","String","DateTime","Date","NodeId","LocalizedText","Encoder","lo","high","ByteString","binaryArray","Buffer","text","locale","stringify","extensionForDataType","dataType","toString","ConfigFileRegexp","AtviseFile","pathForReadResult","readResult","path","nodeId","filePath","nodeClass","Variable","key","$dataType","arrayType","$arrayType","references","HasTypeDefinition","fileExtension","keepExtension","atType","Scalar","Array","encodeValue","from","encoder","encode","v","trim","decodeValue","buffer","length","decoder","decode","s","normalizeMtime","date","setMilliseconds","fromReadResult","mtime","Error","contents","_nodeClass","_dataType","_arrayType","_references","stat","undefined","_getMetadata","stem","split","entries","refs","isArray","extensions","m","relative","match","dirnameExts","dirname","unshift","ifLastExtensionMatches","matches","fn","pop","complete","ext","Matrix","includes","indexOf","foundAtType","forEach","getMetadata","isReferenceConfig","isDisplay","isScript","isQuickDynamic","newValue","createNodeValue","valueOf","fromFilePath","idPath","exts","clone","options","clonedFile","read","Promise","resolve","reject","err"],"mappings":"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","file":"AtviseFile.js","sourcesContent":["import { readFile } from 'fs';\nimport { dirname } from 'path';\nimport { NodeClass, DataType, VariantArrayType, resolveNodeId, LocalizedText } from 'node-opcua';\nimport File from 'vinyl';\nimport NodeId from '../model/opcua/NodeId';\nimport { reverse } from '../helpers/Object';\nimport AtviseTypes from './Types';\n\n/**\n * A map of AtviseTypes against their definition id's value.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByValue = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.typeDefinition.value]: type,\n  }), {});\n\n/**\n * A map of AtviseTypes against their identifiers.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByIdentifier = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.identifier]: type,\n  }), {});\n\n/**\n * A map providing shorter extensions for data types\n * @type {Map<node-opcua~DataType, String>}\n */\nexport const ExtensionForDataType = {\n  [DataType.Boolean]: 'bool',\n  [DataType.XmlElement]: 'xml',\n};\n\n/**\n * A map providing data types for shorter extensions (Reverse of {@link DataTypeForExtension}).\n * * @type {Map<String, node-opcua~DataType>}\n */\nexport const DataTypeForExtension = reverse(ExtensionForDataType);\n\n// Cache DataType\n/**\n * OPC-UA data type names.\n * @type {String[]}\n */\nconst types = Object.keys(DataType);\n\n/**\n * OPC-UA data type extensions.\n * @type {String[]}\n */\nconst typeExtensions = types.map(t => t.toLowerCase());\n\n// Cache TypeDefinitions\n/**\n * Variable data type definition node id.\n * @type {NodeId}\n */\nconst VariableTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0);\n/**\n * Property data type definition node id.\n * @type {NodeId}\n */\nconst PropertyTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0);\n\n// Cache Regular expressions\n/**\n * A regular expression picking file extensions from file names.\n * @type {RegExp}\n */\nconst ExtensionRegExp = /\\.([^/\\\\]*)$/;\n\n/**\n * A set of functions that decode raw stored node values to their original value.\n * @type {Map<node-opcua~DataType, function(rawValue: String): *>}\n */\nconst Decoder = {\n  [DataType.Boolean]: stringValue => stringValue === 'true',\n  [DataType.SByte]: stringValue => parseInt(stringValue, 10),\n  [DataType.Byte]: stringValue => parseInt(stringValue, 10),\n  [DataType.Int16]: stringValue => parseInt(stringValue, 10),\n  [DataType.UInt16]: stringValue => parseInt(stringValue, 10),\n  [DataType.Int32]: stringValue => parseInt(stringValue, 10),\n  [DataType.UInt32]: stringValue => parseInt(stringValue, 10),\n  [DataType.Int64]: stringValue => JSON.parse(stringValue),\n  [DataType.UInt64]: stringValue => JSON.parse(stringValue),\n  [DataType.Float]: stringValue => parseFloat(stringValue, 10),\n  [DataType.Double]: stringValue => parseFloat(stringValue, 10),\n  [DataType.String]: stringValue => stringValue,\n  [DataType.DateTime]: stringValue => new Date(stringValue),\n  [DataType.NodeId]: stringValue => resolveNodeId(stringValue),\n  [DataType.LocalizedText]: stringValue => new LocalizedText(JSON.parse(stringValue)),\n};\n\n/**\n * A set of functions that encode node values before storing them.\n * @type {Map<node-opcua~DataType, function(value: *): String>}\n */\nconst Encoder = {\n  [DataType.UInt64]: ([lo, high]) => `[${lo}, ${high}]`,\n  [DataType.Int64]: ([lo, high]) => `[${lo}, ${high}]`,\n  [DataType.ByteString]: binaryArray => new Buffer(binaryArray, 'binary'),\n  [DataType.LocalizedText]: ({ text, locale }) => (JSON.stringify({ text, locale })),\n};\n\n/**\n * Returns the extension for a specific {@link node-opcua~DataType}.\n * Algorithm:\n *   - if the type has a shortened extension defined in {@link ExtensionForDataType}, return it.\n *   - else return the DataType's name, in lowercase letters.\n * @param {node-opcua~DataType} dataType The datatype to get the extension for.\n * @return {string} The resulting extension.\n */\nfunction extensionForDataType(dataType) {\n  return ExtensionForDataType[dataType] || dataType.toString().toLowerCase();\n}\n\nconst ConfigFileRegexp = /^\\.((Object|Variable)(Type)?|Method|View|(Reference|Data)Type)\\.json$/;\n\n/**\n * An extension to {@link vinyl~File} providing some additional, atvise-related properties.\n * @property {node-opcua~DataType} AtviseFile#dataType The {@link node-opcua~DataType} the node is\n * stored against on atvise server.\n * @property {NodeId} typeDefinition The file's type definition on atvise server.\n * FIXME: Additional properties not showing in API docs.\n */\nexport default class AtviseFile extends File {\n\n  /**\n   * Returns a storage path for a {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to get a path for.\n   */\n  static pathForReadResult(readResult) {\n    let path = readResult.nodeId.filePath;\n\n    if (readResult.nodeClass.value !== NodeClass.Variable.value) {\n      return `${path}/.${readResult.nodeClass.key}.json`;\n    }\n\n    const dataType = readResult.value.$dataType;\n    const arrayType = readResult.value.$arrayType;\n    const typeDefinition = readResult.references.HasTypeDefinition[0];\n\n    if (typeDefinition.value === VariableTypeDefinition.value) {\n      // Variable nodes are stored with their lowercase datatype as an extension\n      path += `.${extensionForDataType(dataType)}`;\n    } else if (typeDefinition.value === PropertyTypeDefinition.value) {\n      // Property nodes are stored with \".prop\" and their lowercase datatype as an extension\n      path += `.prop.${extensionForDataType(dataType)}`;\n    } else {\n      // Handle custom types\n      let identifier = 'var';\n      let fileExtension = false;\n      let keepExtension = false;\n\n      const atType = AtviseTypesByValue[typeDefinition.value];\n      if (atType) {\n        identifier = atType.identifier;\n        fileExtension = atType.fileExtension;\n        keepExtension = atType.keepExtension;\n      }\n\n      if (!keepExtension) {\n        path += `.${identifier}.${fileExtension || extensionForDataType(dataType)}`;\n      }\n    }\n\n    // Add \"array\" or \"matrix\" extensions for corresponding array types\n    if (arrayType.value !== VariantArrayType.Scalar.value) {\n      path += `.${arrayType === VariantArrayType.Array ? 'array' : 'matrix'}`;\n    }\n\n    return path;\n  }\n\n  /**\n   * Encodes a node's value to file contents.\n   * @param {*} value The value to encode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to encode the value for.\n   * @param {node-opcua~VariantArrayType} arrayType The files array type.\n   * @return {?Buffer} The encoded file contents or null.\n   */\n  static encodeValue(value, dataType, arrayType) {\n    if (value.value === null) {\n      return Buffer.from('');\n    }\n\n    const encoder = Encoder[dataType];\n    const encode = v => {\n      if (v === null) { return null; }\n\n      return encoder ? encoder(v) : v.toString().trim();\n    };\n\n    if (arrayType !== VariantArrayType.Scalar) {\n      return Buffer.from(JSON.stringify(Array.from(value.value).map(encode), null, '  '));\n    }\n\n    return Buffer.from(encode(value.value));\n  }\n\n  /**\n   * Decodes a file's contents to a node's value.\n   * @param {Buffer} buffer The file contents to decode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to decode the contents.\n   * @param {node-opcua~VariantArrayType} arrayType The files array type.\n   * @return {?*} The decoded node value or null.\n   */\n  static decodeValue(buffer, dataType, arrayType) {\n    if (buffer === null || buffer.length === 0) {\n      return null;\n    }\n\n    if (dataType === DataType.ByteString) {\n      return buffer;\n    }\n\n    const stringValue = buffer.toString().trim();\n\n    const decoder = Decoder[dataType];\n    const decode = s => {\n      if (s === null) { return null; }\n\n      return decoder ? decoder(s) : s;\n    };\n\n    if (arrayType !== VariantArrayType.Scalar) {\n      return JSON.parse(stringValue).map(decode);\n    }\n\n    return decode(stringValue);\n  }\n\n  /**\n   * As file mtimes do not support millisecond resolution these must be removed before storing\n   * files.\n   * @param {Date} date The original mtime.\n   * @return {Date} The normalized mtime.\n   */\n  static normalizeMtime(date) {\n    date.setMilliseconds(0);\n\n    return date;\n  }\n\n  /**\n   * Creates a new {@link AtviseFile} for the given {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to create the file for.\n   * @return {AtviseFile} The resulting file.\n   */\n  static fromReadResult(readResult) {\n    const { nodeClass, references, value, mtime } = readResult;\n\n    if (nodeClass.value === NodeClass.Variable.value && !value) {\n      throw new Error('no value');\n    }\n\n    return new AtviseFile({\n      path: AtviseFile.pathForReadResult(readResult),\n      contents: value ?\n        AtviseFile.encodeValue(value, value.$dataType, value.$arrayType) : // Variables\n        Buffer.from(JSON.stringify({ references }, null, '  ')), // Objects, types, ...\n      _nodeClass: nodeClass,\n      _dataType: value && value.$dataType,\n      _arrayType: value && value.$arrayType,\n      _references: references,\n      stat: { mtime: mtime ? this.normalizeMtime(mtime) : undefined },\n    });\n  }\n\n  /**\n   * Recalculates {@link AtviseFile#dataType}, {@link AtviseFile#arrayType} and\n   * {@link AtviseFile#typeDefinition}. **Never call this method directly.**.\n   */\n  _getMetadata() {\n    if (this.stem[0] === '.') { // Got non-variable node\n      /**\n       * The node's class.\n       * @type {node-opcua~NodeClass}\n       */\n      this._nodeClass = NodeClass[this.stem.split('.')[1]];\n\n      const { references = {} } = JSON.parse(this.contents.toString());\n\n      /**\n       * References the node holds: In most cases this will be a single entry for\n       * `'HasTypeDefinition'`.\n       * @type {Map<String, NodeId[]>}\n       */\n      this._references = Object.entries(references)\n        .reduce((result, [type, refs]) => Object.assign(result, {\n          [type]: Array.isArray(refs) ? refs.map(v => new NodeId(v)) : new NodeId(refs),\n        }), {});\n      return;\n    }\n\n    this._nodeClass = NodeClass.Variable;\n\n    // Set default metadata\n    /**\n     * The node's stored {@link node-opcua~VariantArrayType}.\n     * @type {?node-opcua~VariantArrayType}\n     */\n    this._arrayType = VariantArrayType.Scalar;\n\n    this._references = {};\n\n    let extensions = [];\n    const m = this.relative.match(ExtensionRegExp);\n    if (m) {\n      extensions = m[1].split('.');\n    }\n\n    // For split files, add the directory name extension\n    const dirnameExts = this.dirname.split('.');\n    if (dirnameExts.length > 1) {\n      extensions.unshift(dirnameExts[dirnameExts.length - 1]);\n    }\n\n    function ifLastExtensionMatches(matches, fn) {\n      if (matches(extensions[extensions.length - 1])) {\n        fn(extensions.pop());\n      }\n    }\n\n    const complete = () => this._dataType !== undefined &&\n      this._references.HasTypeDefinition !== undefined;\n\n    // Handle array types\n    ifLastExtensionMatches(ext => ext === 'array', () => {\n      this._arrayType = VariantArrayType.Array;\n    });\n\n    ifLastExtensionMatches(ext => ext === 'matrix', () => {\n      this._arrayType = VariantArrayType.Matrix;\n    });\n\n    ifLastExtensionMatches(ext => typeExtensions.includes(ext), ext => {\n      /**\n       * The node's stored {@link node-opcua~DataType}.\n       * @type {?node-opcua~DataType}\n       */\n      this._dataType = DataType[types[typeExtensions.indexOf(ext)]];\n    });\n\n    // Handle wrapped data types (e.g. \"bool\" for DataType.Boolean)\n    ifLastExtensionMatches(ext => DataTypeForExtension[ext], ext => {\n      this._dataType = DataType[DataTypeForExtension[ext]];\n    });\n\n    if (extensions.length === 0) { // Got variable\n      /**\n       * The node's stored type definition.\n       * @type {?node-opcua~NodeId}\n       */\n      this._references.HasTypeDefinition = [new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0)];\n    }\n\n    ifLastExtensionMatches(ext => ext === 'prop', () => {\n      this._references.HasTypeDefinition = [new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0)];\n    });\n\n    ifLastExtensionMatches(ext => ext === 'var', () => {\n      this._references.HasTypeDefinition = [new NodeId('Custom.VarResourceType')];\n    });\n\n    if (!complete()) {\n      // Handle atvise types\n      let foundAtType = false;\n\n      Object.keys(AtviseTypesByIdentifier).forEach(identifier => {\n        if (!foundAtType && extensions.includes(identifier)) {\n          foundAtType = true;\n          const type = AtviseTypesByIdentifier[identifier];\n\n          this._references.HasTypeDefinition = [type.typeDefinition];\n          this._dataType = type.dataType;\n        }\n      });\n    }\n\n    if (!complete()) {\n      this._references.HasTypeDefinition = [\n        new NodeId('VariableTypes.ATVISE.Resource.OctetStream'),\n      ];\n      this._dataType = DataType.ByteString;\n    }\n  }\n\n  /**\n   * Computes a file's metadata if needed.\n   * @return {AtviseFile} The file.\n   */\n  getMetadata() {\n    if (!this._nodeClass) {\n      this._getMetadata();\n    }\n\n    return this;\n  }\n\n  /**\n   * The node's class.\n   * @type {node-opcua~NodeClass}\n   */\n  get nodeClass() {\n    if (!this._nodeClass) {\n      this._getMetadata();\n    }\n\n    return this._nodeClass;\n  }\n\n  /**\n   * The file's {@link node-opcua~DataType}.\n   * @type {node-opcua~DataType}\n   */\n  get dataType() {\n    if (!this._dataType) {\n      this._getMetadata();\n    }\n\n    return this._dataType;\n  }\n\n  /**\n   * The file's {@link node-opcua~VariantArrayType}.\n   * @type {node-opcua~VariantArrayType}\n   */\n  get arrayType() {\n    if (!this._arrayType) {\n      this._getMetadata();\n    }\n\n    return this._arrayType;\n  }\n\n  /**\n   * The files's references.\n   * @type {Map<string, NodeId|NodeId[]>}\n   */\n  get references() {\n    if (!this._references) {\n      this._getMetadata();\n    }\n\n    return this._references;\n  }\n\n  /**\n   * The file's type definition.\n   * @type {node-opcua~NodeId}\n   */\n  get typeDefinition() {\n    const refs = this.references;\n\n    if (refs && refs.HasTypeDefinition) {\n      return refs.HasTypeDefinition[0];\n    }\n\n    return new NodeId(NodeId.NodeIdType.NUMERIC, 0, 0);\n  }\n\n  // eslint-disable-next-line jsdoc/require-description-complete-sentence\n  /**\n   * `true` for reference config files (for example `.index.htm.json`).\n   * @type {boolean}\n   */\n  get isReferenceConfig() {\n    return this.stem[0] === '.' && !this.stem.match(ConfigFileRegexp);\n  }\n\n  /**\n   * `true` for files containing atvise displays.\n   * @type {boolean}\n   */\n  get isDisplay() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.Display';\n  }\n\n  /**\n   * `true` for files containing atvise scripts.\n   * @type {boolean}\n   */\n  get isScript() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.ScriptCode';\n  }\n\n  /**\n   * `true` for files containing atvise quick dynamics.\n   * @type {boolean}\n   */\n  get isQuickDynamic() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.QuickDynamic';\n  }\n\n  /**\n   * Sets the node value for the file.\n   * @param {?*} newValue The value to set.\n   */\n  set value(newValue) {\n    /**\n     * The file's contents.\n     * @type {?Buffer}\n     */\n    this.contents = AtviseFile.encodeValue(newValue, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for the file.\n   * @type {?*} The file's decoded value.\n   */\n  get value() {\n    return AtviseFile.decodeValue(this.contents, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for create node serverscript.\n   * @type {?*} The file's decoded value.\n   */\n  get createNodeValue() {\n    const value = this.value;\n\n    if (this.dataType === DataType.DateTime) {\n      return value.valueOf();\n    }\n\n    if (value instanceof Buffer) {\n      return value.toString();\n    }\n\n    return value;\n  }\n\n  /**\n   * Returns the node id associated with the file.\n   * @type {NodeId} The file's node id.\n   */\n  get nodeId() {\n    if (this.nodeClass.value !== NodeClass.Variable.value) {\n      return NodeId.fromFilePath(dirname(this.relative));\n    }\n    const atType = AtviseTypesByValue[this.typeDefinition.value];\n    let idPath = this.relative;\n\n    if (!atType || !atType.keepExtension) {\n      const exts = idPath.match(ExtensionRegExp)[1];\n      idPath = idPath.split(`.${exts}`)[0];\n    }\n\n    return NodeId.fromFilePath(idPath);\n  }\n\n  /**\n   * Returns a new file with all attributes of the current file.\n   * @param {Object} options See the {@link vinyl~File} docs for all options available.\n   * @return {AtviseFile} The cloned file.\n   * @see https://github.com/gulpjs/vinyl#filecloneoptions\n   */\n  clone(options) {\n    const clonedFile = super.clone(options);\n\n    clonedFile._nodeClass = this._nodeClass;\n    clonedFile._dataType = this._dataType;\n    clonedFile._arrayType = this._arrayType;\n    clonedFile._references = this._references;\n\n    return clonedFile;\n  }\n\n  /**\n   * Creates a new AtviseFile and reads it's contents.\n   * @param {Object} options See {@link vinyl~File} for available options.\n   * @return {Promise} Resolved with the new file of rejected with the error that occured while\n   * trying to read it's path.\n   */\n  static read(options = {}) {\n    return new Promise((resolve, reject) => {\n      if (!options.path) {\n        reject(new Error('options.path is required'));\n      } else {\n        readFile(options.path, (err, contents) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(new AtviseFile(Object.assign(options, { contents })));\n          }\n        });\n      }\n    });\n  }\n\n}\n"]}