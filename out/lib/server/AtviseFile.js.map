{"version":3,"sources":["../../../src/lib/server/AtviseFile.js"],"names":["AtviseTypesByValue","reduce","result","type","Object","assign","typeDefinition","value","AtviseTypesByIdentifier","identifier","ExtensionForDataType","Boolean","XmlElement","DataTypeForExtension","types","keys","typeExtensions","map","t","toLowerCase","VariableTypeDefinition","NodeIdType","NUMERIC","PropertyTypeDefinition","ExtensionRegExp","Decoder","stringValue","SByte","parseInt","Byte","Int16","UInt16","Int32","UInt32","Int64","JSON","parse","UInt64","Float","parseFloat","Double","String","DateTime","Date","NodeId","Encoder","lo","high","ByteString","binaryArray","Buffer","extensionForDataType","dataType","toString","AtviseFile","pathForReadResult","readResult","path","nodeId","filePath","nodeClass","Variable","key","$dataType","arrayType","$arrayType","references","HasTypeDefinition","fileExtension","keepExtension","atType","Scalar","Array","encodeValue","from","encoder","encode","v","trim","stringify","decodeValue","buffer","length","decoder","decode","s","normalizeMtime","date","setMilliseconds","fromReadResult","mtime","Error","contents","_nodeClass","_dataType","_arrayType","_references","stat","undefined","_getMetadata","stem","split","entries","refs","extensions","m","relative","match","dirnameExts","dirname","unshift","ifLastExtensionMatches","matches","fn","pop","complete","ext","Matrix","includes","indexOf","foundAtType","forEach","isDisplay","isScript","isQuickDynamic","newValue","createNodeValue","valueOf","fromFilePath","idPath","exts","clone","options","clonedFile","read","Promise","resolve","reject","err"],"mappings":"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","file":"AtviseFile.js","sourcesContent":["import { readFile } from 'fs';\nimport { dirname } from 'path';\nimport { NodeClass, DataType, VariantArrayType, resolveNodeId } from 'node-opcua';\nimport File from 'vinyl';\nimport NodeId from '../model/opcua/NodeId';\nimport { reverse } from '../helpers/Object';\nimport AtviseTypes from './Types';\n\n/**\n * A map of AtviseTypes against their definition id's value.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByValue = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.typeDefinition.value]: type,\n  }), {});\n\n/**\n * A map of AtviseTypes against their identifiers.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByIdentifier = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.identifier]: type,\n  }), {});\n\n/**\n * A map providing shorter extensions for data types\n * @type {Map<node-opcua~DataType, String>}\n */\nexport const ExtensionForDataType = {\n  [DataType.Boolean]: 'bool',\n  [DataType.XmlElement]: 'xml',\n};\n\n/**\n * A map providing data types for shorter extensions (Reverse of {@link DataTypeForExtension}).\n * * @type {Map<String, node-opcua~DataType>}\n */\nexport const DataTypeForExtension = reverse(ExtensionForDataType);\n\n// Cache DataType\n/**\n * OPC-UA data type names.\n * @type {String[]}\n */\nconst types = Object.keys(DataType);\n\n/**\n * OPC-UA data type extensions.\n * @type {String[]}\n */\nconst typeExtensions = types.map(t => t.toLowerCase());\n\n// Cache TypeDefinitions\n/**\n * Variable data type definition node id.\n * @type {NodeId}\n */\nconst VariableTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0);\n/**\n * Property data type definition node id.\n * @type {NodeId}\n */\nconst PropertyTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0);\n\n// Cache Regular expressions\n/**\n * A regular expression picking file extensions from file names.\n * @type {RegExp}\n */\nconst ExtensionRegExp = /\\.([^/\\\\]*)$/;\n\n/**\n * A set of functions that decode raw stored node values to their original value.\n * @type {Map<node-opcua~DataType, function(rawValue: String): *>}\n */\nconst Decoder = {\n  [DataType.Boolean]: stringValue => stringValue === 'true',\n  [DataType.SByte]: stringValue => parseInt(stringValue, 10),\n  [DataType.Byte]: stringValue => parseInt(stringValue, 10),\n  [DataType.Int16]: stringValue => parseInt(stringValue, 10),\n  [DataType.UInt16]: stringValue => parseInt(stringValue, 10),\n  [DataType.Int32]: stringValue => parseInt(stringValue, 10),\n  [DataType.UInt32]: stringValue => parseInt(stringValue, 10),\n  [DataType.Int64]: stringValue => JSON.parse(stringValue),\n  [DataType.UInt64]: stringValue => JSON.parse(stringValue),\n  [DataType.Float]: stringValue => parseFloat(stringValue, 10),\n  [DataType.Double]: stringValue => parseFloat(stringValue, 10),\n  [DataType.String]: stringValue => stringValue,\n  [DataType.DateTime]: stringValue => new Date(stringValue),\n  [DataType.NodeId]: stringValue => resolveNodeId(stringValue),\n};\n\n/**\n * A set of functions that encode node values before storing them.\n * @type {Map<node-opcua~DataType, function(value: *): String>}\n */\nconst Encoder = {\n  [DataType.UInt64]: ([lo, high]) => `[${lo}, ${high}]`,\n  [DataType.Int64]: ([lo, high]) => `[${lo}, ${high}]`,\n  [DataType.ByteString]: binaryArray => new Buffer(binaryArray, 'binary'),\n};\n\n/**\n * Returns the extension for a specific {@link node-opcua~DataType}.\n * Algorithm:\n *   - if the type has a shortened extension defined in {@link ExtensionForDataType}, return it.\n *   - else return the DataType's name, in lowercase letters.\n * @param {node-opcua~DataType} dataType The datatype to get the extension for.\n * @return {string} The resulting extension.\n */\nfunction extensionForDataType(dataType) {\n  return ExtensionForDataType[dataType] || dataType.toString().toLowerCase();\n}\n\n/**\n * An extension to {@link vinyl~File} providing some additional, atvise-related properties.\n * @property {node-opcua~DataType} AtviseFile#dataType The {@link node-opcua~DataType} the node is\n * stored against on atvise server.\n * @property {NodeId} typeDefinition The file's type definition on atvise server.\n * FIXME: Additional properties not showing in API docs.\n */\nexport default class AtviseFile extends File {\n\n  /**\n   * Returns a storage path for a {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to get a path for.\n   */\n  static pathForReadResult(readResult) {\n    let path = readResult.nodeId.filePath;\n\n    if (readResult.nodeClass.value !== NodeClass.Variable.value) {\n      return `${path}/.${readResult.nodeClass.key}.json`;\n    }\n\n    const dataType = readResult.value.$dataType;\n    const arrayType = readResult.value.$arrayType;\n    const typeDefinition = readResult.references.HasTypeDefinition[0];\n\n    if (typeDefinition.value === VariableTypeDefinition.value) {\n      // Variable nodes are stored with their lowercase datatype as an extension\n      path += `.${extensionForDataType(dataType)}`;\n    } else if (typeDefinition.value === PropertyTypeDefinition.value) {\n      // Property nodes are stored with \".prop\" and their lowercase datatype as an extension\n      path += `.prop.${extensionForDataType(dataType)}`;\n    } else {\n      // Handle custom types\n      let identifier = 'var';\n      let fileExtension = false;\n      let keepExtension = false;\n\n      const atType = AtviseTypesByValue[typeDefinition.value];\n      if (atType) {\n        identifier = atType.identifier;\n        fileExtension = atType.fileExtension;\n        keepExtension = atType.keepExtension;\n      }\n\n      if (!keepExtension) {\n        path += `.${identifier}.${fileExtension || extensionForDataType(dataType)}`;\n      }\n    }\n\n    // Add \"array\" or \"matrix\" extensions for corresponding array types\n    if (arrayType.value !== VariantArrayType.Scalar.value) {\n      path += `.${arrayType === VariantArrayType.Array ? 'array' : 'matrix'}`;\n    }\n\n    return path;\n  }\n\n  /**\n   * Encodes a node's value to file contents.\n   * @param {*} value The value to encode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to encode the value for.\n   * @param {node-opcua~VariantArrayType} arrayType The files array type.\n   * @return {?Buffer} The encoded file contents or null.\n   */\n  static encodeValue(value, dataType, arrayType) {\n    if (value.value === null) {\n      return Buffer.from('');\n    }\n\n    const encoder = Encoder[dataType];\n    const encode = v => {\n      if (v === null) { return null; }\n\n      return encoder ? encoder(v) : v.toString().trim();\n    };\n\n    if (arrayType !== VariantArrayType.Scalar) {\n      return Buffer.from(JSON.stringify(Array.from(value.value).map(encode), null, '  '));\n    }\n\n    return Buffer.from(encode(value.value));\n  }\n\n  /**\n   * Decodes a file's contents to a node's value.\n   * @param {Buffer} buffer The file contents to decode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to decode the contents.\n   * @param {node-opcua~VariantArrayType} arrayType The files array type.\n   * @return {?*} The decoded node value or null.\n   */\n  static decodeValue(buffer, dataType, arrayType) {\n    if (buffer === null || buffer.length === 0) {\n      return null;\n    }\n\n    if (dataType === DataType.ByteString) {\n      return buffer;\n    }\n\n    const stringValue = buffer.toString();\n\n    const decoder = Decoder[dataType];\n    const decode = s => {\n      if (s === null) { return null; }\n\n      return decoder ? decoder(s) : s;\n    };\n\n    if (arrayType !== VariantArrayType.Scalar) {\n      return JSON.parse(stringValue).map(decode);\n    }\n\n    return decode(stringValue);\n  }\n\n  /**\n   * As file mtimes do not support millisecond resolution these must be removed before storing\n   * files.\n   * @param {Date} date The original mtime.\n   * @return {Date} The normalized mtime.\n   */\n  static normalizeMtime(date) {\n    date.setMilliseconds(0);\n\n    return date;\n  }\n\n  /**\n   * Creates a new {@link AtviseFile} for the given {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to create the file for.\n   * @return {AtviseFile} The resulting file.\n   */\n  static fromReadResult(readResult) {\n    const { nodeClass, references, value, mtime } = readResult;\n\n    if (nodeClass.value === NodeClass.Variable.value && !value) {\n      throw new Error('no value');\n    }\n\n    return new AtviseFile({\n      path: AtviseFile.pathForReadResult(readResult),\n      contents: value ?\n        AtviseFile.encodeValue(value, value.$dataType, value.$arrayType) : // Variables\n        Buffer.from(JSON.stringify({ references }, null, '  ')), // Objects, types, ...\n      _nodeClass: nodeClass,\n      _dataType: value && value.$dataType,\n      _arrayType: value && value.$arrayType,\n      _references: references,\n      stat: { mtime: mtime ? this.normalizeMtime(mtime) : undefined },\n    });\n  }\n\n  /**\n   * Recalculates {@link AtviseFile#dataType}, {@link AtviseFile#arrayType} and\n   * {@link AtviseFile#typeDefinition}. **Never call this method directly.**.\n   */\n  _getMetadata() {\n    if (this.stem[0] === '.') { // Got non-variable node\n      /**\n       * The node's class.\n       * @type {node-opcua~NodeClass}\n       */\n      this._nodeClass = NodeClass[this.stem.split('.')[1]];\n\n      const { references = {} } = JSON.parse(this.contents.toString());\n\n      /**\n       * References the node holds: In most cases this will be a single entry for\n       * `'HasTypeDefinition'`.\n       * @type {Map<String, NodeId[]>}\n       */\n      this._references = Object.entries(references)\n        .reduce((result, [type, refs]) => Object.assign(result, {\n          [type]: refs.map(v => new NodeId(v)),\n        }), {});\n      return;\n    }\n\n    this._nodeClass = NodeClass.Variable;\n\n    // Set default metadata\n    /**\n     * The node's stored {@link node-opcua~VariantArrayType}.\n     * @type {?node-opcua~VariantArrayType}\n     */\n    this._arrayType = VariantArrayType.Scalar;\n\n    this._references = {};\n\n    let extensions = [];\n    const m = this.relative.match(ExtensionRegExp);\n    if (m) {\n      extensions = m[1].split('.');\n    }\n\n    // For split files, add the directory name extension\n    const dirnameExts = this.dirname.split('.');\n    if (dirnameExts.length > 1) {\n      extensions.unshift(dirnameExts[dirnameExts.length - 1]);\n    }\n\n    function ifLastExtensionMatches(matches, fn) {\n      if (matches(extensions[extensions.length - 1])) {\n        fn(extensions.pop());\n      }\n    }\n\n    const complete = () => this._dataType !== undefined &&\n      this._references.HasTypeDefinition !== undefined;\n\n    // Handle array types\n    ifLastExtensionMatches(ext => ext === 'array', () => {\n      this._arrayType = VariantArrayType.Array;\n    });\n\n    ifLastExtensionMatches(ext => ext === 'matrix', () => {\n      this._arrayType = VariantArrayType.Matrix;\n    });\n\n    ifLastExtensionMatches(ext => typeExtensions.includes(ext), ext => {\n      /**\n       * The node's stored {@link node-opcua~DataType}.\n       * @type {?node-opcua~DataType}\n       */\n      this._dataType = DataType[types[typeExtensions.indexOf(ext)]];\n    });\n\n    // Handle wrapped data types (e.g. \"bool\" for DataType.Boolean)\n    ifLastExtensionMatches(ext => DataTypeForExtension[ext], ext => {\n      this._dataType = DataType[DataTypeForExtension[ext]];\n    });\n\n    if (extensions.length === 0) { // Got variable\n      /**\n       * The node's stored type definition.\n       * @type {?node-opcua~NodeId}\n       */\n      this._references.HasTypeDefinition = [new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0)];\n    }\n\n    ifLastExtensionMatches(ext => ext === 'prop', () => {\n      this._references.HasTypeDefinition = [new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0)];\n    });\n\n    ifLastExtensionMatches(ext => ext === 'var', () => {\n      this._references.HasTypeDefinition = [new NodeId('Custom.VarResourceType')];\n    });\n\n    if (!complete()) {\n      // Handle atvise types\n      let foundAtType = false;\n\n      Object.keys(AtviseTypesByIdentifier).forEach(identifier => {\n        if (!foundAtType && extensions.includes(identifier)) {\n          foundAtType = true;\n          const type = AtviseTypesByIdentifier[identifier];\n\n          this._references.HasTypeDefinition = [type.typeDefinition];\n          this._dataType = type.dataType;\n        }\n      });\n    }\n\n    if (!complete()) {\n      this._references.HasTypeDefinition = [\n        new NodeId('VariableTypes.ATVISE.Resource.OctetStream'),\n      ];\n      this._dataType = DataType.ByteString;\n    }\n  }\n\n  /**\n   * The node's class.\n   * @type {node-opcua~NodeClass}\n   */\n  get nodeClass() {\n    if (!this._nodeClass) {\n      this._getMetadata();\n    }\n\n    return this._nodeClass;\n  }\n\n  /**\n   * The file's {@link node-opcua~DataType}.\n   * @type {node-opcua~DataType}\n   */\n  get dataType() {\n    if (!this._dataType) {\n      this._getMetadata();\n    }\n\n    return this._dataType;\n  }\n\n  /**\n   * The file's {@link node-opcua~VariantArrayType}.\n   * @type {node-opcua~VariantArrayType}\n   */\n  get arrayType() {\n    if (!this._arrayType) {\n      this._getMetadata();\n    }\n\n    return this._arrayType;\n  }\n\n  /**\n   * The file's type definition.\n   * @type {node-opcua~NodeId}\n   */\n  get typeDefinition() {\n    if (!this._references) {\n      this._getMetadata();\n    }\n\n    if (this._references && this._references.HasTypeDefinition) {\n      return this._references.HasTypeDefinition[0];\n    }\n\n    return new NodeId(NodeId.NodeIdType.NUMERIC, 0, 0);\n  }\n\n  /**\n   * `true` for files containing atvise displays.\n   * @type {boolean}\n   */\n  get isDisplay() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.Display';\n  }\n\n  /**\n   * `true` for files containing atvise scripts.\n   * @type {boolean}\n   */\n  get isScript() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.ScriptCode';\n  }\n\n  /**\n   * `true` for files containing atvise quick dynamics.\n   * @type {boolean}\n   */\n  get isQuickDynamic() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.QuickDynamic';\n  }\n\n  /**\n   * Sets the node value for the file.\n   * @param {?*} newValue The value to set.\n   */\n  set value(newValue) {\n    /**\n     * The file's contents.\n     * @type {?Buffer}\n     */\n    this.contents = AtviseFile.encodeValue(newValue, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for the file.\n   * @type {?*} The file's decoded value.\n   */\n  get value() {\n    return AtviseFile.decodeValue(this.contents, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for create node serverscript.\n   * @type {?*} The file's decoded value.\n   */\n  get createNodeValue() {\n    const value = this.value;\n\n    if (this.dataType === DataType.DateTime) {\n      return value.valueOf();\n    }\n\n    return value;\n  }\n\n  /**\n   * Returns the node id associated with the file.\n   * @type {NodeId} The file's node id.\n   */\n  get nodeId() {\n    if (this.nodeClass.value !== NodeClass.Variable.value) {\n      return NodeId.fromFilePath(dirname(this.relative));\n    }\n    const atType = AtviseTypesByValue[this.typeDefinition.value];\n    let idPath = this.relative;\n\n    if (!atType || !atType.keepExtension) {\n      const exts = idPath.match(ExtensionRegExp)[1];\n      idPath = idPath.split(`.${exts}`)[0];\n    }\n\n    return NodeId.fromFilePath(idPath);\n  }\n\n  /**\n   * Returns a new file with all attributes of the current file.\n   * @param {Object} options See the {@link vinyl~File} docs for all options available.\n   * @return {AtviseFile} The cloned file.\n   * @see https://github.com/gulpjs/vinyl#filecloneoptions\n   */\n  clone(options) {\n    const clonedFile = super.clone(options);\n\n    clonedFile._nodeClass = this._nodeClass;\n    clonedFile._dataType = this._dataType;\n    clonedFile._arrayType = this._arrayType;\n    clonedFile._references = this._references;\n\n    return clonedFile;\n  }\n\n  /**\n   * Creates a new AtviseFile and reads it's contents.\n   * @param {Object} options See {@link vinyl~File} for available options.\n   * @return {Promise} Resolved with the new file of rejected with the error that occured while\n   * trying to read it's path.\n   */\n  static read(options = {}) {\n    return new Promise((resolve, reject) => {\n      if (!options.path) {\n        reject(new Error('options.path is required'));\n      } else {\n        readFile(options.path, (err, contents) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(new AtviseFile(Object.assign(options, { contents })));\n          }\n        });\n      }\n    });\n  }\n\n}\n"]}