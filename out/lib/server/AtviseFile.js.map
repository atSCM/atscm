{"version":3,"sources":["../../../src/lib/server/AtviseFile.js"],"names":["AtviseTypesByValue","reduce","result","type","Object","assign","typeDefinition","value","AtviseTypesByIdentifier","identifier","ExtensionForDataType","Boolean","XmlElement","reverseObject","obj","keys","key","DataTypeForExtension","types","typeExtensions","map","t","toLowerCase","VariableTypeDefinition","NodeIdType","NUMERIC","PropertyTypeDefinition","ExtensionRegExp","Decoder","stringValue","String","NodeId","DateTime","Date","Number","parseInt","UInt64","JSON","parse","Encoder","date","getTime","toString","uInt32Array","stringify","extensionForDataType","dataType","AtviseFile","pathForReadResult","readResult","path","nodeId","filePath","$dataType","arrayType","$arrayType","referenceDescription","fileExtension","keepExtension","atType","Scalar","Array","encodeValue","Buffer","from","encoder","trim","decodeValue","buffer","length","decoder","normalizeMtime","setMilliseconds","fromReadResult","Error","contents","_dataType","_arrayType","_typeDefinition","stat","mtime","undefined","_getMetadata","extensions","m","relative","match","split","dirnameExts","dirname","unshift","ifLastExtensionMatches","matches","fn","pop","complete","ext","Matrix","includes","indexOf","foundAtType","forEach","ByteString","isDisplay","isScript","isQuickDynamic","newValue","idPath","exts","fromFilePath","clone","options","clonedFile","read","Promise","resolve","reject","err"],"mappings":"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","file":"AtviseFile.js","sourcesContent":["import { readFile } from 'fs';\nimport File from 'vinyl';\nimport { DataType, VariantArrayType, resolveNodeId } from 'node-opcua';\nimport AtviseTypes from './Types';\nimport NodeId from './NodeId';\n\n// Path related cache\n\n/**\n * A map of AtviseTypes against their definition id's value.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByValue = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.typeDefinition.value]: type,\n  }), {});\n\n/**\n * A map of AtviseTypes against their identifiers.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByIdentifier = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.identifier]: type,\n  }), {});\n\n/**\n * A map providing shorter extensions for data types\n * @type {Map<node-opcua~DataType, String>}\n */\nexport const ExtensionForDataType = {\n  [DataType.Boolean]: 'bool',\n  [DataType.XmlElement]: 'xml',\n};\n\n/**\n * Switches keys and values in an object. E.g.: { \"a\": 1 } becomes { 1: \"a\" }\n * @param {Object} obj The object to reverse.\n * @return {Object} The reversed object.\n */\nfunction reverseObject(obj) {\n  return Object.keys(obj)\n    .reduce((result, key) => Object.assign(result, {\n      [obj[key]]: key,\n    }), {});\n}\n\n/**\n * A map providing data types for shorter extensions (Reverse of {@link DataTypeForExtension}).\n * * @type {Map<String, node-opcua~DataType>}\n */\nexport const DataTypeForExtension = reverseObject(ExtensionForDataType);\n\n// Cache DataType\n/**\n * OPC-UA data type names.\n * @type {String[]}\n */\nconst types = Object.keys(DataType);\n\n/**\n * OPC-UA data type extensions.\n * @type {String[]}\n */\nconst typeExtensions = types.map(t => t.toLowerCase());\n\n// Cache TypeDefinitions\n/**\n * Variable data type definition node id.\n * @type {NodeId}\n */\nconst VariableTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0);\n/**\n * Property data type definition node id.\n * @type {NodeId}\n */\nconst PropertyTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0);\n\n// Cache Regular expressions\n/**\n * A regular expression picking file extensions from file names.\n * @type {RegExp}\n */\nconst ExtensionRegExp = /\\.([^/\\\\]*)$/;\n\n// Value encoding related cache\n/**\n * A set of functions that decode raw stored node values to their original value.\n * @type {Map<node-opcua~DataType, function(rawValue: String): *>}\n */\nconst Decoder = {\n  [DataType.Boolean]: stringValue => stringValue === 'true',\n  [DataType.String]: stringValue => stringValue,\n  [DataType.NodeId]: stringValue => resolveNodeId(stringValue),\n  [DataType.DateTime]: stringValue => new Date(Number.parseInt(stringValue, 10)),\n  [DataType.UInt64]: stringValue => JSON.parse(stringValue),\n};\n\n/**\n * A set of functions that encode node values before storing them.\n * @type {Map<node-opcua~DataType, function(value: *): String>}\n */\nconst Encoder = {\n  [DataType.DateTime]: date => date.getTime().toString(),\n  [DataType.UInt64]: uInt32Array => JSON.stringify(uInt32Array),\n};\n\n/**\n * Returns the extension for a specific {@link node-opcua~DataType}.\n * Algorithm:\n *   - if the type has a shortened extension defined in {@link ExtensionForDataType}, return it.\n *   - else return the DataType's name, in lowercase letters.\n * @param {node-opcua~DataType} dataType The datatype to get the extension for.\n * @return {String} The resulting extension.\n */\nfunction extensionForDataType(dataType) {\n  return ExtensionForDataType[dataType] || dataType.toString().toLowerCase();\n}\n\n/**\n * An extension to {@link vinyl~File} providing some additional, atvise-related properties.\n * @property {node-opcua~DataType} AtviseFile#dataType The {@link node-opcua~DataType} the node is\n * stored against on atvise server.\n * @property {NodeId} typeDefinition The file's type definition on atvise server.\n * FIXME: Additional properties not showing in API docs.\n */\nexport default class AtviseFile extends File {\n\n  /**\n   * Returns a storage path for a {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to get a path for.\n   */\n  static pathForReadResult(readResult) {\n    let path = readResult.nodeId.filePath;\n\n    const dataType = readResult.value.$dataType;\n    const arrayType = readResult.value.$arrayType;\n    const typeDefinition = readResult.referenceDescription.typeDefinition;\n\n    if (typeDefinition.value === VariableTypeDefinition.value) {\n      // Variable nodes are stored with their lowercase datatype as an extension\n      path += `.${extensionForDataType(dataType)}`;\n    } else if (typeDefinition.value === PropertyTypeDefinition.value) {\n      // Property nodes are stored with \".prop\" and their lowercase datatype as an extension\n      path += `.prop.${extensionForDataType(dataType)}`;\n    } else {\n      // Handle custom types\n      let identifier = 'var';\n      let fileExtension = false;\n      let keepExtension = false;\n\n      const atType = AtviseTypesByValue[typeDefinition.value];\n      if (atType) {\n        identifier = atType.identifier;\n        fileExtension = atType.fileExtension;\n        keepExtension = atType.keepExtension;\n      }\n\n      if (!keepExtension) {\n        path += `.${identifier}.${fileExtension || extensionForDataType(dataType)}`;\n      }\n    }\n\n    // Add \"array\" or \"matrix\" extensions for corresponding array types\n    if (arrayType.value !== VariantArrayType.Scalar.value) {\n      path += `.${arrayType === VariantArrayType.Array ? 'array' : 'matrix'}`;\n    }\n\n    return path;\n  }\n\n  /**\n   * Encodes a node's value to file contents.\n   * @param {*} value The value to encode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to encode the value for.\n   * @return {?Buffer} The encoded file contents or null.\n   */\n  static encodeValue(value, dataType) {\n    if (value.value === null) {\n      return Buffer.from('');\n    }\n\n    const encoder = Encoder[dataType];\n    return Buffer.from(encoder ? encoder(value.value) : value.value.toString().trim());\n  }\n\n  /**\n   * Decodes a file's contents to a node's value\n   * @param {Buffer} buffer The file contents to decode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to decode the contents\n   * for.\n   * @return {?*} The decoded node value or null.\n   */\n  static decodeValue(buffer, dataType) {\n    if (buffer === null || buffer.length === 0) {\n      return null;\n    }\n\n    const decoder = Decoder[dataType];\n\n    if (decoder) {\n      return decoder(buffer.toString());\n    }\n\n    return buffer;\n  }\n\n  /**\n   * As file mtimes do not support millisecond resolution these must be removed before storing\n   * files.\n   * @param {Date} date The original mtime.\n   * @return {Date} The normalized mtime.\n   */\n  static normalizeMtime(date) {\n    const result = date;\n    result.setMilliseconds(0);\n\n    return result;\n  }\n\n  /**\n   * Creates a new {@link AtviseFile} for the given {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to create the file for.\n   * @return {AtviseFile} The resulting file.\n   */\n  static fromReadResult(readResult) {\n    if (!readResult.value) {\n      throw new Error('no value');\n    }\n\n    return new AtviseFile({\n      path: AtviseFile.pathForReadResult(readResult),\n      contents: AtviseFile.encodeValue(readResult.value, readResult.value.$dataType),\n      _dataType: readResult.value.$dataType,\n      _arrayType: readResult.value.$arrayType,\n      _typeDefinition: readResult.referenceDescription.typeDefinition,\n      stat: { mtime: readResult.mtime ? this.normalizeMtime(readResult.mtime) : undefined },\n    });\n  }\n\n  /**\n   * Recalculates {@link AtviseFile#dataType}, {@link AtviseFile#arrayType} and\n   * {@link AtviseFile#typeDefinition}. **Never call this method directly.**\n   */\n  _getMetadata() {\n    // Set default metadata\n    /**\n     * The node's stored {@link node-opcua~VariantArrayType}.\n     * @type {?node-opcua~VariantArrayType}\n     */\n    this._arrayType = VariantArrayType.Scalar;\n\n    let extensions = [];\n    const m = this.relative.match(ExtensionRegExp);\n    if (m) {\n      extensions = m[1].split('.');\n    }\n\n    // For split files, add the directory name extension\n    const dirnameExts = this.dirname.split('.');\n    if (dirnameExts.length > 1) {\n      extensions.unshift(dirnameExts[dirnameExts.length - 1]);\n    }\n\n    function ifLastExtensionMatches(matches, fn) {\n      if (matches(extensions[extensions.length - 1])) {\n        fn(extensions.pop());\n      }\n    }\n\n    const complete = () => this._dataType !== undefined && this._typeDefinition !== undefined;\n\n    // Handle array types\n    ifLastExtensionMatches(ext => ext === 'array', () => {\n      this._arrayType = VariantArrayType.Array;\n    });\n\n    ifLastExtensionMatches(ext => ext === 'matrix', () => {\n      this._arrayType = VariantArrayType.Matrix;\n    });\n\n    ifLastExtensionMatches(ext => typeExtensions.includes(ext), ext => {\n      /**\n       * The node's stored {@link node-opcua~DataType}.\n       * @type {?node-opcua~DataType}\n       */\n      this._dataType = DataType[types[typeExtensions.indexOf(ext)]];\n    });\n\n    // Handle wrapped data types (e.g. \"bool\" for DataType.Boolean)\n    ifLastExtensionMatches(ext => DataTypeForExtension[ext], ext => {\n      this._dataType = DataType[DataTypeForExtension[ext]];\n    });\n\n    if (extensions.length === 0) { // Got variable\n      /**\n       * The node's stored type definition.\n       * @type {?node-opcua~NodeId}\n       */\n      this._typeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0);\n    }\n\n    ifLastExtensionMatches(ext => ext === 'prop', () => {\n      this._typeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0);\n    });\n\n    if (!complete()) {\n      // Handle atvise types\n      let foundAtType = false;\n\n      Object.keys(AtviseTypesByIdentifier).forEach(identifier => {\n        if (!foundAtType && extensions.includes(identifier)) {\n          foundAtType = true;\n          const type = AtviseTypesByIdentifier[identifier];\n\n          this._typeDefinition = type.typeDefinition;\n          this._dataType = type.dataType;\n        }\n      });\n    }\n\n    if (!complete()) {\n      this._typeDefinition = new NodeId('VariableTypes.ATVISE.Resource.OctetStream');\n      this._dataType = DataType.ByteString;\n    }\n  }\n\n  /**\n   * The file's {@link node-opcua~DataType}.\n   * @type {node-opcua~DataType}\n   */\n  get dataType() {\n    if (!this._dataType) {\n      this._getMetadata();\n    }\n\n    return this._dataType;\n  }\n\n  /**\n   * The file's {@link node-opcua~VariantArrayType}.\n   * @type {node-opcua~VariantArrayType}\n   */\n  get arrayType() {\n    if (!this._arrayType) {\n      this._getMetadata();\n    }\n\n    return this._arrayType;\n  }\n\n  /**\n   * The file's type definition.\n   * @type {node-opcua~NodeId}\n   */\n  get typeDefinition() {\n    if (!this._typeDefinition) {\n      this._getMetadata();\n    }\n\n    return this._typeDefinition;\n  }\n\n  /**\n   * `true` for files containing atvise displays.\n   * @type {Boolean}\n   */\n  get isDisplay() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.Display';\n  }\n\n  /**\n   * `true` for files containing atvise scripts.\n   * @type {Boolean}\n   */\n  get isScript() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.ScriptCode';\n  }\n\n  /**\n   * `true` for files containing atvise quick dynamics.\n   * @type {Boolean}\n   */\n  get isQuickDynamic() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.QuickDynamic';\n  }\n\n  /**\n   * Sets the node value for the file.\n   * @param {?*} newValue The value to set.\n   */\n  set value(newValue) {\n    /**\n     * The file's contents.\n     * @type {?Buffer}\n     */\n    this.contents = AtviseFile.encodeValue(newValue, this.dataType);\n  }\n\n  /**\n   * Returns the decoded node value for the file.\n   * @type {?*} The file's decoded value.\n   */\n  get value() {\n    return AtviseFile.decodeValue(this.contents, this.dataType);\n  }\n\n  /**\n   * Returns the node id associated with the file.\n   * @type {NodeId} The file's node id.\n   */\n  get nodeId() {\n    const atType = AtviseTypesByValue[this.typeDefinition.value];\n    let idPath = this.relative;\n\n    if (!atType || !atType.keepExtension) {\n      const exts = idPath.match(ExtensionRegExp)[1];\n      idPath = idPath.split(`.${exts}`)[0];\n    }\n\n    return NodeId.fromFilePath(idPath);\n  }\n\n  /**\n   * Returns a new file with all attributes of the current file.\n   * @param {Object} options See https://github.com/gulpjs/vinyl#filecloneoptions for all options\n   * available.\n   * @return {AtviseFile} The cloned file.\n   */\n  clone(options) {\n    const clonedFile = super.clone(options);\n\n    clonedFile._arrayType = this._arrayType;\n\n    return clonedFile;\n  }\n\n  /**\n   * Creates a new AtviseFile and reads it's contents.\n   * @param {Object} options See {@link vinyl~File} for available options.\n   * @return {Promise} Resolved with the new file of rejected with the error that occured while\n   * trying to read it's path.\n   */\n  static read(options = {}) {\n    return new Promise((resolve, reject) => {\n      if (!options.path) {\n        reject(new Error('options.path is required'));\n      } else {\n        readFile(options.path, (err, contents) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(new AtviseFile(Object.assign(options, { contents })));\n          }\n        });\n      }\n    });\n  }\n\n}\n"]}