{"version":3,"sources":["../../../src/lib/server/AtviseFile.js"],"names":["AtviseTypesByValue","reduce","result","type","Object","assign","typeDefinition","value","AtviseTypesByIdentifier","identifier","ExtensionForDataType","Boolean","XmlElement","DataTypeForExtension","types","keys","typeExtensions","map","t","toLowerCase","VariableTypeDefinition","NodeIdType","NUMERIC","PropertyTypeDefinition","ExtensionRegExp","asIs","b","mapPropertyAs","obj","key","dataType","toRawValue","Null","StatusCode","name","QualifiedName","namespaceIndex","LocalizedText","text","locale","DataValue","options","Variant","arrayType","dimensions","getRawValue","DiagnosticInfo","info","decodeAsString","toString","decodeAsInt","parseInt","decodeAsFloat","parseFloat","decodeAsJson","JSON","parse","decodeRawValue","SByte","Byte","Int16","UInt16","Int32","UInt32","Int64","UInt64","Float","Double","String","DateTime","Guid","NodeId","ExpandedNodeId","toNodeValue","s","Date","ByteString","Buffer","from","data","nodeId","defs","split","identifierType","namespace","namespaceUri","serverIndex","opts","def","match","val","slice","Scalar","getNodeValue","rawValue","raw","extensionForDataType","ConfigFileRegexp","AtviseFile","pathForReadResult","readResult","path","filePath","nodeClass","Variable","$dataType","$arrayType","references","HasTypeDefinition","fileExtension","keepExtension","atType","Array","encodeValue","stringify","a","toJSON","stringified","trim","decodeValue","buffer","length","normalizeMtime","date","setMilliseconds","fromReadResult","mtime","Error","contents","_nodeClass","_dataType","_arrayType","_references","stat","undefined","_getMetadata","stem","entries","refs","isArray","v","extensions","m","relative","dirnameExts","dirname","unshift","ifLastExtensionMatches","matches","fn","pop","complete","ext","Matrix","includes","indexOf","foundAtType","forEach","getMetadata","isReferenceConfig","isDisplay","isScript","isQuickDynamic","newValue","createNodeValue","valueOf","fromFilePath","idPath","exts","clone","clonedFile","read","Promise","resolve","reject","err"],"mappings":"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","file":"AtviseFile.js","sourcesContent":["import { readFile } from 'fs';\nimport { dirname } from 'path';\nimport { NodeClass, DataType, VariantArrayType, resolveNodeId, Variant, LocalizedText, StatusCodes,\n  QualifiedName, DataValue } from 'node-opcua';\nimport { ExpandedNodeId } from 'node-opcua/lib/datamodel/expanded_nodeid';\nimport { DiagnosticInfo } from 'node-opcua/lib/datamodel/diagnostic_info';\nimport File from 'vinyl';\nimport NodeId from '../model/opcua/NodeId';\nimport { reverse, pick } from '../helpers/Object';\nimport AtviseTypes from './Types';\n\n/**\n * A map of AtviseTypes against their definition id's value.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByValue = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.typeDefinition.value]: type,\n  }), {});\n\n/**\n * A map of AtviseTypes against their identifiers.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByIdentifier = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.identifier]: type,\n  }), {});\n\n/**\n * A map providing shorter extensions for data types\n * @type {Map<node-opcua~DataType, String>}\n */\nexport const ExtensionForDataType = {\n  [DataType.Boolean]: 'bool',\n  [DataType.XmlElement]: 'xml',\n};\n\n/**\n * A map providing data types for shorter extensions (Reverse of {@link DataTypeForExtension}).\n * * @type {Map<String, node-opcua~DataType>}\n */\nexport const DataTypeForExtension = reverse(ExtensionForDataType);\n\n// Cache DataType\n/**\n * OPC-UA data type names.\n * @type {String[]}\n */\nconst types = Object.keys(DataType);\n\n/**\n * OPC-UA data type extensions.\n * @type {String[]}\n */\nconst typeExtensions = types.map(t => t.toLowerCase());\n\n// Cache TypeDefinitions\n/**\n * Variable data type definition node id.\n * @type {NodeId}\n */\nconst VariableTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0);\n/**\n * Property data type definition node id.\n * @type {NodeId}\n */\nconst PropertyTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0);\n\n// Cache Regular expressions\n/**\n * A regular expression picking file extensions from file names.\n * @type {RegExp}\n */\nconst ExtensionRegExp = /\\.([^/\\\\]*)$/;\n\n/**\n * Function that returns the passed argument as is.\n * @param {*} b The input argument.\n * @return {*} The value passed.\n */\nconst asIs = b => b;\n\n/**\n * Maps a single property of an object using the the mapper defined in *map* for the given\n * *dataType*.\n * @param {Map<node-opcua~DataType, function} map The mappings to use.\n * @param {Object} obj The object to process.\n * @param {string} key Name of the property to map.\n * @param {node-opcua~DataType} dataType The data type to map the property to.\n */\nconst mapPropertyAs = (map, obj, key, dataType) => {\n  if (obj[key]) {\n    return Object.assign(obj, {\n      [key]: map[dataType](obj[key]),\n    });\n  }\n\n  return obj;\n};\n\n/**\n * Mapping functions that return serializable values for a node of the given\n * {@link node-opcua~DataType}.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst toRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.StatusCode]: ({ name }) => name,\n  [DataType.QualifiedName]: ({ namespaceIndex, name }) => ({ namespaceIndex, name }),\n  [DataType.LocalizedText]: ({ text, locale }) => ({ text, locale }),\n  [DataType.DataValue]: value => {\n    const options = pick(value, ['value', 'statusCode', 'sourceTimestamp', 'sourcePicoseconds',\n      'serverTimestamp', 'serverPicoseconds']);\n\n    mapPropertyAs(toRawValue, options, 'value', DataType.Variant);\n    mapPropertyAs(toRawValue, options, 'statusCode', DataType.StatusCode);\n    // NOTE: server- and sourceTimstamps get mapped as dates\n\n    return options;\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => ({\n    dataType,\n    arrayType,\n    value: getRawValue(value, dataType, arrayType), // eslint-disable-line no-use-before-define\n    dimensions,\n  }),\n  [DataType.DiagnosticInfo]: info => {\n    const options = pick(info, ['namespaceUri', 'symbolicId', 'locale', 'localizedText',\n      'additionalInfo', 'innerStatusCode', 'innerDiagnosticInfo']);\n\n    mapPropertyAs(toRawValue, options, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toRawValue, options, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n    return options;\n  },\n};\n\n/**\n * Decodes a buffer to a string.\n * @param {Buffer} b The buffer to decode from.\n * @return {string} The buffer's string representation.\n */\nconst decodeAsString = b => b.toString();\n\n/**\n * Decodes a buffer to an integer value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded integer.\n */\nconst decodeAsInt = b => parseInt(b.toString(), 10);\n\n/**\n * Decodes a buffer to a float value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded float.\n */\nconst decodeAsFloat = b => parseFloat(b.toString());\n\n/**\n * Decodes a buffer using JSON.\n * @param {Buffer} b The buffer to decode from.\n * @return {*} The decoded value, most likely an Object.\n */\nconst decodeAsJson = b => JSON.parse(b.toString());\n\n/**\n * Mapping functions that return raw values for a stored value of the given type.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst decodeRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.Boolean]: b => b.toString() === 'true',\n  [DataType.SByte]: decodeAsInt,\n  [DataType.Byte]: decodeAsInt,\n  [DataType.Int16]: decodeAsInt,\n  [DataType.UInt16]: decodeAsInt,\n  [DataType.Int32]: decodeAsInt,\n  [DataType.UInt32]: decodeAsInt,\n  [DataType.Int64]: decodeAsJson,\n  [DataType.UInt64]: decodeAsJson,\n  [DataType.Float]: decodeAsFloat,\n  [DataType.Double]: decodeAsFloat,\n  [DataType.String]: decodeAsString,\n  [DataType.DateTime]: decodeAsString,\n  [DataType.Guid]: decodeAsString,\n  // ByteString maps to Buffer\n  [DataType.XmlElement]: decodeAsString,\n  [DataType.NodeId]: decodeAsString,\n  [DataType.ExpandedNodeId]: decodeAsString,\n  [DataType.StatusCode]: decodeAsString,\n  [DataType.QualifiedName]: decodeAsJson,\n  [DataType.LocalizedText]: decodeAsJson,\n  // FIXME: Add ExtensionObject\n  [DataType.DataValue]: decodeAsJson,\n  [DataType.Variant]: decodeAsJson,\n  [DataType.DiagnosticInfo]: decodeAsJson,\n};\n\n/**\n * Mapping functions that return OPC-UA node values for raw values.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst toNodeValue = {\n  [DataType.DateTime]: s => new Date(s),\n  [DataType.ByteString]: b => {\n    if (b instanceof Buffer) { return b; }\n\n    return Buffer.from(b.data, 'binary');\n  },\n  [DataType.NodeId]: s => resolveNodeId(s),\n\n  // Jep, node-opcua does not provide a resolve function for expanded nodeids\n  [DataType.ExpandedNodeId]: s => {\n    const nodeId = resolveNodeId(s);\n    const [value, ...defs] = nodeId.value.split(';');\n\n    const { identifierType, namespace, namespaceUri, serverIndex } = defs.reduce((opts, def) => {\n      const match = def.match(/^([^:]+):(.*)/);\n      if (!match) { return opts; }\n\n      let [key, val] = match.slice(1); // eslint-disable-line prefer-const\n\n      if (key === 'serverIndex') {\n        val = parseInt(val, 10);\n      }\n\n      return Object.assign(opts, { [key]: val });\n    }, Object.assign({}, nodeId));\n\n    return new ExpandedNodeId(identifierType, value, namespace, namespaceUri, serverIndex);\n  },\n\n  [DataType.StatusCode]: name => StatusCodes[name],\n  [DataType.QualifiedName]: options => new QualifiedName(options),\n  [DataType.LocalizedText]: options => new LocalizedText(options),\n  [DataType.DataValue]: options => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'value', DataType.Variant);\n    mapPropertyAs(toNodeValue, opts, 'statusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'sourceTimestamp', DataType.DateTime);\n    mapPropertyAs(toNodeValue, opts, 'serverTimestamp', DataType.DateTime);\n\n    return new DataValue(opts);\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => new Variant({\n    dataType,\n    arrayType: VariantArrayType[arrayType],\n    value,\n    dimensions,\n  }),\n  [DataType.DiagnosticInfo]: options => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n\n    return new DiagnosticInfo(opts);\n  },\n};\n\n/**\n * Returns a node's raw value based on it's OPC-UA value and type.\n * @param {*} value A node's OPC-UA value.\n * @param {node-opcua~DataType} dataType The node's data type.\n * @param {node-opcua~VariantArrayType} arrayType The node's array type.\n * @return {*} The raw value of the given node.\n */\nconst getRawValue = (value, dataType, arrayType) => {\n  if (arrayType.value !== VariantArrayType.Scalar.value) {\n    return value.map(val => getRawValue(val, dataType, VariantArrayType[arrayType.value - 1]));\n  }\n\n  return (toRawValue[dataType] || asIs)(value);\n};\n\n/**\n * Returns a node's OPC-UA value based on it's raw value and type.\n * @param {*} rawValue A node's raw value.\n * @param {node-opcua~DataType} dataType A node's data type.\n * @param {node-opcua~VariantArrayType} arrayType A node's array type.\n */\nconst getNodeValue = (rawValue, dataType, arrayType) => {\n  if (arrayType.value !== VariantArrayType.Scalar.value) {\n    return rawValue.map(raw => getNodeValue(raw, dataType, VariantArrayType[arrayType.value - 1]));\n  }\n\n  return (toNodeValue[dataType] || asIs)(rawValue);\n};\n\n/**\n * Returns the extension for a specific {@link node-opcua~DataType}.\n * Algorithm:\n *   - if the type has a shortened extension defined in {@link ExtensionForDataType}, return it.\n *   - else return the DataType's name, in lowercase letters.\n * @param {node-opcua~DataType} dataType The datatype to get the extension for.\n * @return {string} The resulting extension.\n */\nfunction extensionForDataType(dataType) {\n  return ExtensionForDataType[dataType] || dataType.toString().toLowerCase();\n}\n\n/**\n * A regular expression that maches all reference definition files.\n * @type {RegExp}\n */\nconst ConfigFileRegexp = /^\\.((Object|Variable)(Type)?|Method|View|(Reference|Data)Type)\\.json$/;\n\n/**\n * An extension to {@link vinyl~File} providing some additional, atvise-related properties.\n * @property {node-opcua~DataType} AtviseFile#dataType The {@link node-opcua~DataType} the node is\n * stored against on atvise server.\n * @property {NodeId} typeDefinition The file's type definition on atvise server.\n * FIXME: Additional properties not showing in API docs.\n */\nexport default class AtviseFile extends File {\n\n  /**\n   * Returns a storage path for a {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to get a path for.\n   */\n  static pathForReadResult(readResult) {\n    let path = readResult.nodeId.filePath;\n\n    if (readResult.nodeClass.value !== NodeClass.Variable.value) {\n      return `${path}/.${readResult.nodeClass.key}.json`;\n    }\n\n    const dataType = readResult.value.$dataType;\n    const arrayType = readResult.value.$arrayType;\n    const typeDefinition = readResult.references.HasTypeDefinition[0];\n\n    if (typeDefinition.value === VariableTypeDefinition.value) {\n      // Variable nodes are stored with their lowercase datatype as an extension\n      path += `.${extensionForDataType(dataType)}`;\n    } else if (typeDefinition.value === PropertyTypeDefinition.value) {\n      // Property nodes are stored with \".prop\" and their lowercase datatype as an extension\n      path += `.prop.${extensionForDataType(dataType)}`;\n    } else {\n      // Handle custom types\n      let identifier = 'var';\n      let fileExtension = false;\n      let keepExtension = false;\n\n      const atType = AtviseTypesByValue[typeDefinition.value];\n      if (atType) {\n        identifier = atType.identifier;\n        fileExtension = atType.fileExtension;\n        keepExtension = atType.keepExtension;\n      }\n\n      if (!keepExtension) {\n        path += `.${identifier}.${fileExtension || extensionForDataType(dataType)}`;\n      }\n    }\n\n    // Add \"array\" or \"matrix\" extensions for corresponding array types\n    if (arrayType.value !== VariantArrayType.Scalar.value) {\n      path += `.${arrayType === VariantArrayType.Array ? 'array' : 'matrix'}`;\n    }\n\n    return path;\n  }\n\n  /**\n   * Encodes a node's value to file contents.\n   * @param {*} value The value to encode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to encode the value for.\n   * @param {node-opcua~VariantArrayType} arrayType The files array type.\n   * @return {?Buffer} The encoded file contents or null.\n   */\n  static encodeValue(value, dataType, arrayType) {\n    if (value.value === null) {\n      return Buffer.from('');\n    }\n\n    const rawValue = getRawValue(value.value, dataType, arrayType);\n\n    if (rawValue instanceof Buffer) {\n      return rawValue;\n    }\n\n    const stringify = a => (a.toJSON ? a.toJSON() : JSON.stringify(a, null, '  '));\n    const stringified = (typeof rawValue === 'object') ?\n      stringify(rawValue) :\n      rawValue.toString().trim();\n\n    return Buffer.from(stringified);\n  }\n\n  /**\n   * Decodes a file's contents to a node's value.\n   * @param {Buffer} buffer The file contents to decode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to decode the contents.\n   * @param {node-opcua~VariantArrayType} arrayType The files array type.\n   * @return {?*} The decoded node value or null.\n   */\n  static decodeValue(buffer, dataType, arrayType) {\n    if (buffer === null || buffer.length === 0) {\n      return null;\n    }\n\n    if (dataType === DataType.ByteString && arrayType === VariantArrayType.Scalar) {\n      return buffer;\n    }\n\n    const rawValue = arrayType === VariantArrayType.Scalar ?\n      (decodeRawValue[dataType] || asIs)(buffer) :\n      JSON.parse(buffer.toString());\n\n    return getNodeValue(rawValue, dataType, arrayType);\n  }\n\n  /**\n   * As file mtimes do not support millisecond resolution these must be removed before storing\n   * files.\n   * @param {Date} date The original mtime.\n   * @return {Date} The normalized mtime.\n   */\n  static normalizeMtime(date) {\n    date.setMilliseconds(0);\n\n    return date;\n  }\n\n  /**\n   * Creates a new {@link AtviseFile} for the given {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to create the file for.\n   * @return {AtviseFile} The resulting file.\n   */\n  static fromReadResult(readResult) {\n    const { nodeClass, references, value, mtime } = readResult;\n\n    if (nodeClass.value === NodeClass.Variable.value && !value) {\n      throw new Error('no value');\n    }\n\n    return new AtviseFile({\n      path: AtviseFile.pathForReadResult(readResult),\n      contents: value ?\n        AtviseFile.encodeValue(value, value.$dataType, value.$arrayType) : // Variables\n        Buffer.from(JSON.stringify({ references }, null, '  ')), // Objects, types, ...\n      _nodeClass: nodeClass,\n      _dataType: value && value.$dataType,\n      _arrayType: value && value.$arrayType,\n      _references: references,\n      stat: { mtime: mtime ? this.normalizeMtime(mtime) : undefined },\n    });\n  }\n\n  /**\n   * Recalculates {@link AtviseFile#dataType}, {@link AtviseFile#arrayType} and\n   * {@link AtviseFile#typeDefinition}. **Never call this method directly.**.\n   */\n  _getMetadata() {\n    if (this.stem[0] === '.') { // Got non-variable node\n      /**\n       * The node's class.\n       * @type {node-opcua~NodeClass}\n       */\n      this._nodeClass = NodeClass[this.stem.split('.')[1]];\n\n      const { references = {} } = JSON.parse(this.contents.toString());\n\n      /**\n       * References the node holds: In most cases this will be a single entry for\n       * `'HasTypeDefinition'`.\n       * @type {Map<String, NodeId[]>}\n       */\n      this._references = Object.entries(references)\n        .reduce((result, [type, refs]) => Object.assign(result, {\n          [type]: Array.isArray(refs) ? refs.map(v => new NodeId(v)) : new NodeId(refs),\n        }), {});\n\n      return;\n    }\n\n    this._nodeClass = NodeClass.Variable;\n\n    // Set default metadata\n    /**\n     * The node's stored {@link node-opcua~VariantArrayType}.\n     * @type {?node-opcua~VariantArrayType}\n     */\n    this._arrayType = VariantArrayType.Scalar;\n\n    this._references = {};\n\n    let extensions = [];\n    const m = this.relative.match(ExtensionRegExp);\n    if (m) {\n      extensions = m[1].split('.');\n    }\n\n    // For split files, add the directory name extension\n    const dirnameExts = this.dirname.split('.');\n    if (dirnameExts.length > 1) {\n      extensions.unshift(dirnameExts[dirnameExts.length - 1]);\n    }\n\n    function ifLastExtensionMatches(matches, fn) {\n      if (matches(extensions[extensions.length - 1])) {\n        fn(extensions.pop());\n      }\n    }\n\n    const complete = () => this._dataType !== undefined &&\n      this._references.HasTypeDefinition !== undefined;\n\n    // Handle array types\n    ifLastExtensionMatches(ext => ext === 'array', () => {\n      this._arrayType = VariantArrayType.Array;\n    });\n\n    ifLastExtensionMatches(ext => ext === 'matrix', () => {\n      this._arrayType = VariantArrayType.Matrix;\n    });\n\n    ifLastExtensionMatches(ext => typeExtensions.includes(ext), ext => {\n      /**\n       * The node's stored {@link node-opcua~DataType}.\n       * @type {?node-opcua~DataType}\n       */\n      this._dataType = DataType[types[typeExtensions.indexOf(ext)]];\n    });\n\n    // Handle wrapped data types (e.g. \"bool\" for DataType.Boolean)\n    ifLastExtensionMatches(ext => DataTypeForExtension[ext], ext => {\n      this._dataType = DataType[DataTypeForExtension[ext]];\n    });\n\n    if (extensions.length === 0) { // Got variable\n      /**\n       * The node's stored type definition.\n       * @type {?node-opcua~NodeId}\n       */\n      this._references.HasTypeDefinition = [new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0)];\n    }\n\n    ifLastExtensionMatches(ext => ext === 'prop', () => {\n      this._references.HasTypeDefinition = [new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0)];\n    });\n\n    ifLastExtensionMatches(ext => ext === 'var', () => {\n      this._references.HasTypeDefinition = [new NodeId('Custom.VarResourceType')];\n    });\n\n    if (!complete()) {\n      // Handle atvise types\n      let foundAtType = false;\n\n      Object.keys(AtviseTypesByIdentifier).forEach(identifier => {\n        if (!foundAtType && extensions.includes(identifier)) {\n          foundAtType = true;\n          const type = AtviseTypesByIdentifier[identifier];\n\n          this._references.HasTypeDefinition = [type.typeDefinition];\n          this._dataType = type.dataType;\n        }\n      });\n    }\n\n    if (!complete()) {\n      this._references.HasTypeDefinition = [\n        new NodeId('VariableTypes.ATVISE.Resource.OctetStream'),\n      ];\n      this._dataType = DataType.ByteString;\n    }\n  }\n\n  /**\n   * Computes a file's metadata if needed.\n   * @return {AtviseFile} The file.\n   */\n  getMetadata() {\n    if (!this._nodeClass) {\n      this._getMetadata();\n    }\n\n    return this;\n  }\n\n  /**\n   * The node's class.\n   * @type {node-opcua~NodeClass}\n   */\n  get nodeClass() {\n    if (!this._nodeClass) {\n      this._getMetadata();\n    }\n\n    return this._nodeClass;\n  }\n\n  /**\n   * The file's {@link node-opcua~DataType}.\n   * @type {node-opcua~DataType}\n   */\n  get dataType() {\n    if (!this._dataType) {\n      this._getMetadata();\n    }\n\n    return this._dataType;\n  }\n\n  /**\n   * The file's {@link node-opcua~VariantArrayType}.\n   * @type {node-opcua~VariantArrayType}\n   */\n  get arrayType() {\n    if (!this._arrayType) {\n      this._getMetadata();\n    }\n\n    return this._arrayType;\n  }\n\n  /**\n   * The files's references.\n   * @type {Map<string, NodeId|NodeId[]>}\n   */\n  get references() {\n    if (!this._references) {\n      this._getMetadata();\n    }\n\n    return this._references;\n  }\n\n  /**\n   * The file's type definition.\n   * @type {node-opcua~NodeId}\n   */\n  get typeDefinition() {\n    const refs = this.references;\n\n    if (refs && refs.HasTypeDefinition) {\n      return refs.HasTypeDefinition[0];\n    }\n\n    return new NodeId(NodeId.NodeIdType.NUMERIC, 0, 0);\n  }\n\n  // eslint-disable-next-line jsdoc/require-description-complete-sentence\n  /**\n   * `true` for reference config files (for example `.index.htm.json`).\n   * @type {boolean}\n   */\n  get isReferenceConfig() {\n    return this.stem[0] === '.' && !this.stem.match(ConfigFileRegexp);\n  }\n\n  /**\n   * `true` for files containing atvise displays.\n   * @type {boolean}\n   */\n  get isDisplay() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.Display';\n  }\n\n  /**\n   * `true` for files containing atvise scripts.\n   * @type {boolean}\n   */\n  get isScript() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.ScriptCode';\n  }\n\n  /**\n   * `true` for files containing atvise quick dynamics.\n   * @type {boolean}\n   */\n  get isQuickDynamic() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.QuickDynamic';\n  }\n\n  /**\n   * Sets the node value for the file.\n   * @param {?*} newValue The value to set.\n   */\n  set value(newValue) {\n    /**\n     * The file's contents.\n     * @type {?Buffer}\n     */\n    this.contents = AtviseFile.encodeValue(newValue, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for the file.\n   * @type {?*} The file's decoded value.\n   */\n  get value() {\n    return AtviseFile.decodeValue(this.contents, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for create node serverscript.\n   * @type {?*} The file's decoded value.\n   */\n  get createNodeValue() {\n    const value = this.value;\n\n    if (this.dataType === DataType.DateTime) {\n      return value.valueOf();\n    }\n\n    if (value instanceof Buffer) {\n      return value.toString();\n    }\n\n    return value;\n  }\n\n  /**\n   * Returns the node id associated with the file.\n   * @type {NodeId} The file's node id.\n   */\n  get nodeId() {\n    if (this.nodeClass.value !== NodeClass.Variable.value) {\n      return NodeId.fromFilePath(dirname(this.relative));\n    }\n    const atType = AtviseTypesByValue[this.typeDefinition.value];\n    let idPath = this.relative;\n\n    if (!atType || !atType.keepExtension) {\n      const exts = idPath.match(ExtensionRegExp)[1];\n      idPath = idPath.split(`.${exts}`)[0];\n    }\n\n    return NodeId.fromFilePath(idPath);\n  }\n\n  /**\n   * Returns a new file with all attributes of the current file.\n   * @param {Object} options See the {@link vinyl~File} docs for all options available.\n   * @return {AtviseFile} The cloned file.\n   * @see https://github.com/gulpjs/vinyl#filecloneoptions\n   */\n  clone(options) {\n    const clonedFile = super.clone(options);\n\n    clonedFile._nodeClass = this._nodeClass;\n    clonedFile._dataType = this._dataType;\n    clonedFile._arrayType = this._arrayType;\n    clonedFile._references = this._references;\n\n    return clonedFile;\n  }\n\n  /**\n   * Creates a new AtviseFile and reads it's contents.\n   * @param {Object} options See {@link vinyl~File} for available options.\n   * @return {Promise} Resolved with the new file of rejected with the error that occured while\n   * trying to read it's path.\n   */\n  static read(options = {}) {\n    return new Promise((resolve, reject) => {\n      if (!options.path) {\n        reject(new Error('options.path is required'));\n      } else {\n        readFile(options.path, (err, contents) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(new AtviseFile(Object.assign(options, { contents })));\n          }\n        });\n      }\n    });\n  }\n\n}\n"]}