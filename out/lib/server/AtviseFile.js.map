{"version":3,"sources":["../../../src/lib/server/AtviseFile.js"],"names":["AtviseTypesByValue","reduce","result","type","Object","assign","typeDefinition","value","AtviseTypesByIdentifier","identifier","ExtensionForDataType","Boolean","XmlElement","DataTypeForExtension","types","keys","typeExtensions","map","t","toLowerCase","VariableTypeDefinition","NodeIdType","NUMERIC","PropertyTypeDefinition","ExtensionRegExp","asIs","b","mapPropertyAs","obj","key","dataType","toRawValue","Null","StatusCode","name","QualifiedName","namespaceIndex","LocalizedText","text","locale","DataValue","options","Variant","arrayType","dimensions","getRawValue","DiagnosticInfo","info","decodeAsString","toString","trim","decodeAsInt","parseInt","decodeAsFloat","parseFloat","decodeAsJson","JSON","parse","decodeRawValue","SByte","Byte","Int16","UInt16","Int32","UInt32","Int64","UInt64","Float","Double","String","DateTime","Guid","NodeId","ExpandedNodeId","toNodeValue","s","Date","ByteString","Buffer","from","data","nodeId","defs","split","identifierType","namespace","namespaceUri","serverIndex","opts","def","match","val","slice","Scalar","array","Array","isArray","getNodeValue","rawValue","Error","raw","extensionForDataType","ConfigFileRegexp","AtviseFile","pathForReadResult","readResult","path","filePath","nodeClass","Variable","$dataType","$arrayType","references","HasTypeDefinition","fileExtension","keepExtension","atType","encodeValue","stringify","a","toJSON","stringified","decodeValue","buffer","length","normalizeMtime","date","setMilliseconds","fromReadResult","mtime","contents","_nodeClass","_dataType","_arrayType","_references","stat","undefined","_getMetadata","stem","entries","refs","v","_name","extensions","m","relative","dirnameExts","dirname","unshift","ifLastExtensionMatches","matches","fn","pop","complete","ext","Matrix","includes","indexOf","toParent","HasProperty","foundAtType","forEach","filter","e","join","getMetadata","isReferenceConfig","isDisplay","isScript","isQuickDynamic","newValue","createNodeValue","valueOf","fromFilePath","idPath","exts","parentNodeId","id","parts","parent","clone","clonedFile","read","Promise","resolve","reject","err"],"mappings":"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","file":"AtviseFile.js","sourcesContent":["import { readFile } from 'fs';\nimport { dirname } from 'path';\nimport { NodeClass, DataType, VariantArrayType, resolveNodeId, Variant, LocalizedText, StatusCodes,\n  QualifiedName, DataValue, ReferenceTypeIds } from 'node-opcua';\nimport { ExpandedNodeId } from 'node-opcua/lib/datamodel/expanded_nodeid';\nimport { DiagnosticInfo } from 'node-opcua/lib/datamodel/diagnostic_info';\nimport File from 'vinyl';\nimport NodeId from '../model/opcua/NodeId';\nimport { reverse, pick } from '../helpers/Object';\nimport { sortReferences } from '../helpers/mapping';\nimport AtviseTypes, { AtviseResourceType } from './Types';\n\n/**\n * A map of AtviseTypes against their definition id's value.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByValue = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.typeDefinition.value]: type,\n  }), {});\n\n/**\n * A map of AtviseTypes against their identifiers.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByIdentifier = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.identifier]: type,\n  }), {});\n\n/**\n * A map providing shorter extensions for data types\n * @type {Map<node-opcua~DataType, String>}\n */\nexport const ExtensionForDataType = {\n  [DataType.Boolean]: 'bool',\n  [DataType.XmlElement]: 'xml',\n};\n\n/**\n * A map providing data types for shorter extensions (Reverse of {@link DataTypeForExtension}).\n * * @type {Map<String, node-opcua~DataType>}\n */\nexport const DataTypeForExtension = reverse(ExtensionForDataType);\n\n// Cache DataType\n/**\n * OPC-UA data type names.\n * @type {String[]}\n */\nconst types = Object.keys(DataType);\n\n/**\n * OPC-UA data type extensions.\n * @type {String[]}\n */\nconst typeExtensions = types.map(t => t.toLowerCase());\n\n// Cache TypeDefinitions\n/**\n * Variable data type definition node id.\n * @type {NodeId}\n */\nconst VariableTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0);\n/**\n * Property data type definition node id.\n * @type {NodeId}\n */\nconst PropertyTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0);\n\n// Cache Regular expressions\n/**\n * A regular expression picking file extensions from file names.\n * @type {RegExp}\n */\nconst ExtensionRegExp = /\\.([^/\\\\]*)$/;\n\n/**\n * Function that returns the passed argument as is.\n * @param {*} b The input argument.\n * @return {*} The value passed.\n */\nconst asIs = b => b;\n\n/**\n * Maps a single property of an object using the the mapper defined in *map* for the given\n * *dataType*.\n * @param {Map<node-opcua~DataType, function} map The mappings to use.\n * @param {Object} obj The object to process.\n * @param {string} key Name of the property to map.\n * @param {node-opcua~DataType} dataType The data type to map the property to.\n */\nconst mapPropertyAs = (map, obj, key, dataType) => {\n  if (obj[key]) {\n    return Object.assign(obj, {\n      [key]: map[dataType](obj[key]),\n    });\n  }\n\n  return obj;\n};\n\n/**\n * Mapping functions that return serializable values for a node of the given\n * {@link node-opcua~DataType}.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst toRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.StatusCode]: ({ name }) => name,\n  [DataType.QualifiedName]: ({ namespaceIndex, name }) => ({ namespaceIndex, name }),\n  [DataType.LocalizedText]: ({ text, locale }) => ({ text, locale }),\n  [DataType.DataValue]: value => {\n    const options = pick(value, ['value', 'statusCode', 'sourceTimestamp', 'sourcePicoseconds',\n      'serverTimestamp', 'serverPicoseconds']);\n\n    mapPropertyAs(toRawValue, options, 'value', DataType.Variant);\n    mapPropertyAs(toRawValue, options, 'statusCode', DataType.StatusCode);\n    // NOTE: server- and sourceTimstamps get mapped as dates\n\n    return options;\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => ({\n    dataType,\n    arrayType,\n    value: getRawValue(value, dataType, arrayType), // eslint-disable-line no-use-before-define\n    dimensions,\n  }),\n  [DataType.DiagnosticInfo]: info => {\n    const options = pick(info, ['namespaceUri', 'symbolicId', 'locale', 'localizedText',\n      'additionalInfo', 'innerStatusCode', 'innerDiagnosticInfo']);\n\n    mapPropertyAs(toRawValue, options, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toRawValue, options, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n    return options;\n  },\n};\n\n/**\n * Decodes a buffer to a string.\n * @param {Buffer} b The buffer to decode from.\n * @return {string} The buffer's string representation.\n */\nconst decodeAsString = b => b.toString().trim();\n\n/**\n * Decodes a buffer to an integer value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded integer.\n */\nconst decodeAsInt = b => parseInt(decodeAsString(b), 10);\n\n/**\n * Decodes a buffer to a float value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded float.\n */\nconst decodeAsFloat = b => parseFloat(decodeAsString(b));\n\n/**\n * Decodes a buffer using JSON.\n * @param {Buffer} b The buffer to decode from.\n * @return {*} The decoded value, most likely an Object.\n */\nconst decodeAsJson = b => JSON.parse(b.toString());\n\n/**\n * Mapping functions that return raw values for a stored value of the given type.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst decodeRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.Boolean]: b => decodeAsString(b) === 'true',\n  [DataType.SByte]: decodeAsInt,\n  [DataType.Byte]: decodeAsInt,\n  [DataType.Int16]: decodeAsInt,\n  [DataType.UInt16]: decodeAsInt,\n  [DataType.Int32]: decodeAsInt,\n  [DataType.UInt32]: decodeAsInt,\n  [DataType.Int64]: decodeAsJson,\n  [DataType.UInt64]: decodeAsJson,\n  [DataType.Float]: decodeAsFloat,\n  [DataType.Double]: decodeAsFloat,\n  [DataType.String]: decodeAsString,\n  [DataType.DateTime]: decodeAsString,\n  [DataType.Guid]: decodeAsString,\n  // ByteString maps to Buffer\n  [DataType.XmlElement]: decodeAsString,\n  [DataType.NodeId]: decodeAsString,\n  [DataType.ExpandedNodeId]: decodeAsString,\n  [DataType.StatusCode]: decodeAsString,\n  [DataType.QualifiedName]: decodeAsJson,\n  [DataType.LocalizedText]: decodeAsJson,\n  // FIXME: Add ExtensionObject\n  [DataType.DataValue]: decodeAsJson,\n  [DataType.Variant]: decodeAsJson,\n  [DataType.DiagnosticInfo]: decodeAsJson,\n};\n\n/**\n * Mapping functions that return OPC-UA node values for raw values.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst toNodeValue = {\n  [DataType.DateTime]: s => new Date(s),\n  [DataType.ByteString]: b => {\n    if (b instanceof Buffer) { return b; }\n\n    return Buffer.from(b.data, 'binary');\n  },\n  [DataType.NodeId]: s => resolveNodeId(s),\n\n  // Jep, node-opcua does not provide a resolve function for expanded nodeids\n  [DataType.ExpandedNodeId]: s => {\n    const nodeId = resolveNodeId(s);\n    const [value, ...defs] = nodeId.value.split(';');\n\n    const { identifierType, namespace, namespaceUri, serverIndex } = defs.reduce((opts, def) => {\n      const match = def.match(/^([^:]+):(.*)/);\n      if (!match) { return opts; }\n\n      let [key, val] = match.slice(1); // eslint-disable-line prefer-const\n\n      if (key === 'serverIndex') {\n        val = parseInt(val, 10);\n      }\n\n      return Object.assign(opts, { [key]: val });\n    }, Object.assign({}, nodeId));\n\n    return new ExpandedNodeId(identifierType, value, namespace, namespaceUri, serverIndex);\n  },\n\n  [DataType.StatusCode]: name => StatusCodes[name],\n  [DataType.QualifiedName]: options => new QualifiedName(options),\n  [DataType.LocalizedText]: options => new LocalizedText(options),\n  [DataType.DataValue]: options => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'value', DataType.Variant);\n    mapPropertyAs(toNodeValue, opts, 'statusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'sourceTimestamp', DataType.DateTime);\n    mapPropertyAs(toNodeValue, opts, 'serverTimestamp', DataType.DateTime);\n\n    return new DataValue(opts);\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => new Variant({\n    dataType,\n    arrayType: VariantArrayType[arrayType],\n    value,\n    dimensions,\n  }),\n  [DataType.DiagnosticInfo]: options => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n    return new DiagnosticInfo(opts);\n  },\n};\n\n/**\n * Returns a node's raw value based on it's OPC-UA value and type.\n * @param {*} value A node's OPC-UA value.\n * @param {node-opcua~DataType} dataType The node's data type.\n * @param {node-opcua~VariantArrayType} arrayType The node's array type.\n * @return {*} The raw value of the given node.\n */\nconst getRawValue = (value, dataType, arrayType) => {\n  if (arrayType.value !== VariantArrayType.Scalar.value) {\n    const array = Array.isArray(value) ? value : Array.from(value);\n\n    return array.map(val => getRawValue(val, dataType, VariantArrayType[arrayType.value - 1]));\n  }\n\n  return (toRawValue[dataType] || asIs)(value);\n};\n\n/**\n * Returns a node's OPC-UA value based on it's raw value and type.\n * @param {*} rawValue A node's raw value.\n * @param {node-opcua~DataType} dataType A node's data type.\n * @param {node-opcua~VariantArrayType} arrayType A node's array type.\n */\nconst getNodeValue = (rawValue, dataType, arrayType) => {\n  if (arrayType.value !== VariantArrayType.Scalar.value) {\n    if (!Array.isArray(rawValue)) {\n      throw new Error('Value is not an array');\n    }\n\n    return rawValue.map(raw => getNodeValue(raw, dataType, VariantArrayType[arrayType.value - 1]));\n  }\n\n  return (toNodeValue[dataType] || asIs)(rawValue);\n};\n\n/**\n * Returns the extension for a specific {@link node-opcua~DataType}.\n * Algorithm:\n *   - if the type has a shortened extension defined in {@link ExtensionForDataType}, return it.\n *   - else return the DataType's name, in lowercase letters.\n * @param {node-opcua~DataType} dataType The datatype to get the extension for.\n * @return {string} The resulting extension.\n */\nfunction extensionForDataType(dataType) {\n  return ExtensionForDataType[dataType] || dataType.toString().toLowerCase();\n}\n\n/**\n * A regular expression that maches all reference definition files.\n * @type {RegExp}\n */\nconst ConfigFileRegexp = /^\\.((Object|Variable)(Type)?|Method|View|(Reference|Data)Type)\\.json$/;\n\n/**\n * An extension to {@link vinyl~File} providing some additional, atvise-related properties.\n * @property {node-opcua~DataType} AtviseFile#dataType The {@link node-opcua~DataType} the node is\n * stored against on atvise server.\n * @property {NodeId} typeDefinition The file's type definition on atvise server.\n * FIXME: Additional properties not showing in API docs.\n */\nexport default class AtviseFile extends File {\n\n  /**\n   * Returns a storage path for a {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to get a path for.\n   */\n  static pathForReadResult(readResult) {\n    let path = readResult.nodeId.filePath;\n\n    if (readResult.nodeClass.value !== NodeClass.Variable.value) {\n      return `${path}/.${readResult.nodeClass.key}.json`;\n    }\n\n    const dataType = readResult.value.$dataType;\n    const arrayType = readResult.value.$arrayType;\n    const typeDefinition = readResult.references.HasTypeDefinition[0];\n\n    if (typeDefinition.value === VariableTypeDefinition.value) {\n      // Variable nodes are stored with their lowercase datatype as an extension\n      path += `.${extensionForDataType(dataType)}`;\n    } else if (typeDefinition.value === PropertyTypeDefinition.value) {\n      // Property nodes are stored with \".prop\" and their lowercase datatype as an extension\n      path += `.prop.${extensionForDataType(dataType)}`;\n    } else {\n      // Handle custom types\n      let identifier = 'var';\n      let fileExtension = false;\n      let keepExtension = false;\n\n      const atType = AtviseTypesByValue[typeDefinition.value];\n      if (atType) {\n        identifier = atType.identifier;\n        fileExtension = atType.fileExtension;\n        keepExtension = atType.keepExtension;\n      }\n\n      if (!keepExtension) {\n        path += `.${identifier}.${fileExtension || extensionForDataType(dataType)}`;\n      }\n    }\n\n    // Add \"array\" or \"matrix\" extensions for corresponding array types\n    if (arrayType.value !== VariantArrayType.Scalar.value) {\n      path += `.${arrayType === VariantArrayType.Array ? 'array' : 'matrix'}`;\n    }\n\n    return path;\n  }\n\n  /**\n   * Encodes a node's value to file contents.\n   * @param {*} value The value to encode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to encode the value for.\n   * @param {node-opcua~VariantArrayType} arrayType The files array type.\n   * @return {?Buffer} The encoded file contents or null.\n   */\n  static encodeValue(value, dataType, arrayType) {\n    if (value.value === null) {\n      return Buffer.from('');\n    }\n\n    const rawValue = getRawValue(value.value, dataType, arrayType);\n\n    if (rawValue instanceof Buffer) {\n      return rawValue;\n    }\n\n    const stringify = a => (a.toJSON ? a.toJSON() : JSON.stringify(a, null, '  '));\n    const stringified = (typeof rawValue === 'object') ?\n      stringify(rawValue) :\n      rawValue.toString().trim();\n\n    return Buffer.from(stringified);\n  }\n\n  /**\n   * Decodes a file's contents to a node's value.\n   * @param {Buffer} buffer The file contents to decode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to decode the contents.\n   * @param {node-opcua~VariantArrayType} arrayType The files array type.\n   * @return {?*} The decoded node value or null.\n   */\n  static decodeValue(buffer, dataType, arrayType) {\n    if (buffer === null || buffer.length === 0) {\n      return null;\n    }\n\n    if (dataType === DataType.ByteString && arrayType === VariantArrayType.Scalar) {\n      return buffer;\n    }\n\n    const rawValue = arrayType === VariantArrayType.Scalar ?\n      (decodeRawValue[dataType] || asIs)(buffer) :\n      JSON.parse(buffer.toString());\n\n    return getNodeValue(rawValue, dataType, arrayType);\n  }\n\n  /**\n   * As file mtimes do not support millisecond resolution these must be removed before storing\n   * files.\n   * @param {Date} date The original mtime.\n   * @return {Date} The normalized mtime.\n   */\n  static normalizeMtime(date) {\n    date.setMilliseconds(0);\n\n    return date;\n  }\n\n  /**\n   * Creates a new {@link AtviseFile} for the given {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to create the file for.\n   * @return {AtviseFile} The resulting file.\n   */\n  static fromReadResult(readResult) {\n    const { nodeClass, references, value, mtime } = readResult;\n\n    if (nodeClass.value === NodeClass.Variable.value && !value) {\n      throw new Error('no value');\n    }\n\n    return new AtviseFile({\n      path: AtviseFile.pathForReadResult(readResult),\n      contents: value ?\n        AtviseFile.encodeValue(value, value.$dataType, value.$arrayType) : // Variables\n        Buffer.from(JSON.stringify({\n          references: sortReferences(references),\n        }, null, '  ')), // Objects, types, ...\n      _nodeClass: nodeClass,\n      _dataType: value && value.$dataType,\n      _arrayType: value && value.$arrayType,\n      _references: references,\n      stat: { mtime: mtime ? this.normalizeMtime(mtime) : undefined },\n    });\n  }\n\n  /**\n   * Recalculates {@link AtviseFile#dataType}, {@link AtviseFile#arrayType} and\n   * {@link AtviseFile#typeDefinition}. **Never call this method directly.**.\n   */\n  _getMetadata() {\n    if (this.stem[0] === '.') { // Got non-variable node\n      /**\n       * The node's class.\n       * @type {node-opcua~NodeClass}\n       */\n      this._nodeClass = NodeClass[this.stem.split('.')[1]];\n\n      const { references = {} } = JSON.parse(this.contents.toString());\n\n      /**\n       * References the node holds: In most cases this will be a single entry for\n       * `'HasTypeDefinition'`.\n       * @type {Map<String, NodeId[]>}\n       */\n      this._references = Object.entries(references)\n        .reduce((result, [type, refs]) => Object.assign(result, {\n          [type]: Array.isArray(refs) ? refs.map(v => new NodeId(v)) : new NodeId(refs),\n        }), {});\n\n      return;\n    }\n\n    this._nodeClass = NodeClass.Variable;\n\n    // Set default metadata\n    /**\n     * The node's stored {@link node-opcua~VariantArrayType}.\n     * @type {?node-opcua~VariantArrayType}\n     */\n    this._arrayType = VariantArrayType.Scalar;\n\n    this._references = {};\n\n    /**\n     * A node's browse- and display name.\n     * @type {?string}\n     */\n    this._name = this.stem.split('.')[0];\n\n    let extensions = [];\n    const m = this.relative.match(ExtensionRegExp);\n    if (m) {\n      extensions = m[1].split('.');\n    }\n\n    // For split files, add the directory name extension\n    const dirnameExts = this.dirname.split('.');\n    if (dirnameExts.length > 1) {\n      extensions.unshift(dirnameExts[dirnameExts.length - 1]);\n    }\n\n    function ifLastExtensionMatches(matches, fn) {\n      if (matches(extensions[extensions.length - 1])) {\n        fn(extensions.pop());\n      }\n    }\n\n    const complete = () => this._dataType !== undefined &&\n      this._references.HasTypeDefinition !== undefined;\n\n    // Handle array types\n    ifLastExtensionMatches(ext => ext === 'array', () => {\n      this._arrayType = VariantArrayType.Array;\n    });\n\n    ifLastExtensionMatches(ext => ext === 'matrix', () => {\n      this._arrayType = VariantArrayType.Matrix;\n    });\n\n    ifLastExtensionMatches(ext => typeExtensions.includes(ext), ext => {\n      /**\n       * The node's stored {@link node-opcua~DataType}.\n       * @type {?node-opcua~DataType}\n       */\n      this._dataType = DataType[types[typeExtensions.indexOf(ext)]];\n    });\n\n    // Handle wrapped data types (e.g. \"bool\" for DataType.Boolean)\n    ifLastExtensionMatches(ext => DataTypeForExtension[ext], ext => {\n      this._dataType = DataType[DataTypeForExtension[ext]];\n    });\n\n    if (extensions.length === 0) { // Got variable\n      /**\n       * The node's stored type definition.\n       * @type {?node-opcua~NodeId}\n       */\n      this._references.HasTypeDefinition = [new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0)];\n    }\n\n    ifLastExtensionMatches(ext => ext === 'prop', () => {\n      this._references.HasTypeDefinition = [new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0)];\n      this._references.toParent = ReferenceTypeIds.HasProperty;\n    });\n\n    ifLastExtensionMatches(ext => ext === 'var', () => {\n      this._references.HasTypeDefinition = [new NodeId('Custom.VarResourceType')];\n    });\n\n    if (!complete()) {\n      // Handle atvise types\n      let foundAtType = false;\n\n      Object.entries(AtviseTypesByIdentifier).forEach(([identifier, type]) => {\n        if (!foundAtType && extensions.includes(identifier)) {\n          foundAtType = true;\n\n          if (!(type instanceof AtviseResourceType)) {\n            extensions = extensions.filter(e => e !== identifier);\n          }\n\n          this._references.HasTypeDefinition = [type.typeDefinition];\n          this._dataType = type.dataType;\n        }\n      });\n    }\n\n    if (!complete()) {\n      this._references.HasTypeDefinition = [\n        new NodeId('VariableTypes.ATVISE.Resource.OctetStream'),\n      ];\n      this._dataType = DataType.ByteString;\n    }\n\n    this._name = [this._name, ...extensions.filter(e => !dirnameExts.includes(e))].join('.');\n  }\n\n  /**\n   * Computes a file's metadata if needed.\n   * @return {AtviseFile} The file.\n   */\n  getMetadata() {\n    if (!this._nodeClass) {\n      this._getMetadata();\n    }\n\n    return this;\n  }\n\n  /**\n   * The node's class.\n   * @type {node-opcua~NodeClass}\n   */\n  get nodeClass() {\n    if (!this._nodeClass) {\n      this._getMetadata();\n    }\n\n    return this._nodeClass;\n  }\n\n  /**\n   * The file's {@link node-opcua~DataType}.\n   * @type {node-opcua~DataType}\n   */\n  get dataType() {\n    if (!this._dataType) {\n      this._getMetadata();\n    }\n\n    return this._dataType;\n  }\n\n  /**\n   * The file's {@link node-opcua~VariantArrayType}.\n   * @type {node-opcua~VariantArrayType}\n   */\n  get arrayType() {\n    if (!this._arrayType) {\n      this._getMetadata();\n    }\n\n    return this._arrayType;\n  }\n\n  /**\n   * The files's references.\n   * @type {Map<string, NodeId|NodeId[]>}\n   */\n  get references() {\n    if (!this._references) {\n      this._getMetadata();\n    }\n\n    return this._references;\n  }\n\n  /**\n   * The file's type definition.\n   * @type {node-opcua~NodeId}\n   */\n  get typeDefinition() {\n    const refs = this.references;\n\n    if (refs && refs.HasTypeDefinition) {\n      return refs.HasTypeDefinition[0];\n    }\n\n    return new NodeId(NodeId.NodeIdType.NUMERIC, 0, 0);\n  }\n\n  // eslint-disable-next-line jsdoc/require-description-complete-sentence\n  /**\n   * `true` for reference config files (for example `.index.htm.json`).\n   * @type {boolean}\n   */\n  get isReferenceConfig() {\n    return this.stem[0] === '.' && !this.stem.match(ConfigFileRegexp);\n  }\n\n  /**\n   * `true` for files containing atvise displays.\n   * @type {boolean}\n   */\n  get isDisplay() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.Display';\n  }\n\n  /**\n   * `true` for files containing atvise scripts.\n   * @type {boolean}\n   */\n  get isScript() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.ScriptCode';\n  }\n\n  /**\n   * `true` for files containing atvise quick dynamics.\n   * @type {boolean}\n   */\n  get isQuickDynamic() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.QuickDynamic';\n  }\n\n  /**\n   * Sets the node value for the file.\n   * @param {?*} newValue The value to set.\n   */\n  set value(newValue) {\n    /**\n     * The file's contents.\n     * @type {?Buffer}\n     */\n    this.contents = AtviseFile.encodeValue(newValue, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for the file.\n   * @type {?*} The file's decoded value.\n   */\n  get value() {\n    return AtviseFile.decodeValue(this.contents, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for create node serverscript.\n   * @type {?*} The file's decoded value.\n   */\n  get createNodeValue() {\n    const value = this.value;\n\n    if (this.dataType === DataType.DateTime) {\n      return value.valueOf();\n    }\n\n    if (value instanceof Buffer) {\n      return value.toString();\n    }\n\n    return value;\n  }\n\n  /**\n   * Returns the node id associated with the file.\n   * @type {NodeId} The file's node id.\n   */\n  get nodeId() {\n    if (this.nodeClass.value !== NodeClass.Variable.value) {\n      return NodeId.fromFilePath(dirname(this.relative));\n    }\n    const atType = AtviseTypesByValue[this.typeDefinition.value];\n    let idPath = this.relative;\n\n    if (!atType || !atType.keepExtension) {\n      const exts = idPath.match(ExtensionRegExp)[1];\n      idPath = idPath.split(`.${exts}`)[0];\n    }\n\n    return NodeId.fromFilePath(idPath);\n  }\n\n  /**\n   * A file's browse and display name.\n   * @type {string}\n   */\n  get name() {\n    if (!this._name) {\n      this._getMetadata();\n    }\n\n    return this._name;\n  }\n\n  /**\n   * A file's parent's node id.\n   * @type {NodeId}\n   */\n  get parentNodeId() {\n    const name = this.name;\n    const id = this.nodeId;\n\n    if (name) {\n      const parts = this.nodeId.value.split(name);\n\n      if (parts.length > 1) {\n        return new NodeId(id.identifierType, parts[0].slice(0, -1), id.namespaceIndex);\n      }\n    }\n\n    return this.nodeId.parent;\n  }\n\n  /**\n   * Returns a new file with all attributes of the current file.\n   * @param {Object} options See the {@link vinyl~File} docs for all options available.\n   * @return {AtviseFile} The cloned file.\n   * @see https://github.com/gulpjs/vinyl#filecloneoptions\n   */\n  clone(options) {\n    const clonedFile = super.clone(options);\n\n    clonedFile._nodeClass = this._nodeClass;\n    clonedFile._dataType = this._dataType;\n    clonedFile._arrayType = this._arrayType;\n    clonedFile._references = this._references;\n\n    return clonedFile;\n  }\n\n  /**\n   * Creates a new AtviseFile and reads it's contents.\n   * @param {Object} options See {@link vinyl~File} for available options.\n   * @return {Promise} Resolved with the new file of rejected with the error that occured while\n   * trying to read it's path.\n   */\n  static read(options = {}) {\n    return new Promise((resolve, reject) => {\n      if (!options.path) {\n        reject(new Error('options.path is required'));\n      } else {\n        readFile(options.path, (err, contents) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(new AtviseFile(Object.assign(options, { contents })));\n          }\n        });\n      }\n    });\n  }\n\n}\n"]}