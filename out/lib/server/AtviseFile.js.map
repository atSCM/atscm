{"version":3,"sources":["../../../src/lib/server/AtviseFile.js"],"names":["AtviseTypesByValue","reduce","result","type","Object","assign","typeDefinition","value","AtviseTypesByIdentifier","identifier","ExtensionForDataType","Boolean","XmlElement","DataTypeForExtension","types","keys","typeExtensions","map","t","toLowerCase","VariableTypeDefinition","NodeIdType","NUMERIC","PropertyTypeDefinition","ExtensionRegExp","asIs","b","mapPropertyAs","obj","key","dataType","toRawValue","Null","StatusCode","name","QualifiedName","namespaceIndex","LocalizedText","text","locale","DataValue","options","Variant","arrayType","dimensions","getRawValue","DiagnosticInfo","info","decodeAsString","toString","decodeAsInt","parseInt","decodeAsFloat","parseFloat","decodeAsJson","JSON","parse","decodeRawValue","SByte","Byte","Int16","UInt16","Int32","UInt32","Int64","UInt64","Float","Double","String","DateTime","Guid","NodeId","ExpandedNodeId","toNodeValue","s","Date","ByteString","Buffer","from","data","nodeId","defs","split","identifierType","namespace","namespaceUri","serverIndex","opts","def","match","val","slice","Scalar","array","Array","isArray","getNodeValue","rawValue","Error","raw","extensionForDataType","ConfigFileRegexp","AtviseFile","pathForReadResult","readResult","path","filePath","nodeClass","Variable","$dataType","$arrayType","references","HasTypeDefinition","fileExtension","keepExtension","atType","encodeValue","stringify","a","toJSON","stringified","trim","decodeValue","buffer","length","normalizeMtime","date","setMilliseconds","fromReadResult","mtime","contents","_nodeClass","_dataType","_arrayType","_references","stat","undefined","_getMetadata","stem","entries","refs","v","extensions","m","relative","dirnameExts","dirname","unshift","ifLastExtensionMatches","matches","fn","pop","complete","ext","Matrix","includes","indexOf","foundAtType","forEach","getMetadata","isReferenceConfig","isDisplay","isScript","isQuickDynamic","newValue","createNodeValue","valueOf","fromFilePath","idPath","exts","clone","clonedFile","read","Promise","resolve","reject","err"],"mappings":"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","file":"AtviseFile.js","sourcesContent":["import { readFile } from 'fs';\nimport { dirname } from 'path';\nimport { NodeClass, DataType, VariantArrayType, resolveNodeId, Variant, LocalizedText, StatusCodes,\n  QualifiedName, DataValue } from 'node-opcua';\nimport { ExpandedNodeId } from 'node-opcua/lib/datamodel/expanded_nodeid';\nimport { DiagnosticInfo } from 'node-opcua/lib/datamodel/diagnostic_info';\nimport File from 'vinyl';\nimport NodeId from '../model/opcua/NodeId';\nimport { reverse, pick } from '../helpers/Object';\nimport AtviseTypes from './Types';\n\n/**\n * A map of AtviseTypes against their definition id's value.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByValue = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.typeDefinition.value]: type,\n  }), {});\n\n/**\n * A map of AtviseTypes against their identifiers.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByIdentifier = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.identifier]: type,\n  }), {});\n\n/**\n * A map providing shorter extensions for data types\n * @type {Map<node-opcua~DataType, String>}\n */\nexport const ExtensionForDataType = {\n  [DataType.Boolean]: 'bool',\n  [DataType.XmlElement]: 'xml',\n};\n\n/**\n * A map providing data types for shorter extensions (Reverse of {@link DataTypeForExtension}).\n * * @type {Map<String, node-opcua~DataType>}\n */\nexport const DataTypeForExtension = reverse(ExtensionForDataType);\n\n// Cache DataType\n/**\n * OPC-UA data type names.\n * @type {String[]}\n */\nconst types = Object.keys(DataType);\n\n/**\n * OPC-UA data type extensions.\n * @type {String[]}\n */\nconst typeExtensions = types.map(t => t.toLowerCase());\n\n// Cache TypeDefinitions\n/**\n * Variable data type definition node id.\n * @type {NodeId}\n */\nconst VariableTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0);\n/**\n * Property data type definition node id.\n * @type {NodeId}\n */\nconst PropertyTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0);\n\n// Cache Regular expressions\n/**\n * A regular expression picking file extensions from file names.\n * @type {RegExp}\n */\nconst ExtensionRegExp = /\\.([^/\\\\]*)$/;\n\n/**\n * Function that returns the passed argument as is.\n * @param {*} b The input argument.\n * @return {*} The value passed.\n */\nconst asIs = b => b;\n\n/**\n * Maps a single property of an object using the the mapper defined in *map* for the given\n * *dataType*.\n * @param {Map<node-opcua~DataType, function} map The mappings to use.\n * @param {Object} obj The object to process.\n * @param {string} key Name of the property to map.\n * @param {node-opcua~DataType} dataType The data type to map the property to.\n */\nconst mapPropertyAs = (map, obj, key, dataType) => {\n  if (obj[key]) {\n    return Object.assign(obj, {\n      [key]: map[dataType](obj[key]),\n    });\n  }\n\n  return obj;\n};\n\n/**\n * Mapping functions that return serializable values for a node of the given\n * {@link node-opcua~DataType}.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst toRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.StatusCode]: ({ name }) => name,\n  [DataType.QualifiedName]: ({ namespaceIndex, name }) => ({ namespaceIndex, name }),\n  [DataType.LocalizedText]: ({ text, locale }) => ({ text, locale }),\n  [DataType.DataValue]: value => {\n    const options = pick(value, ['value', 'statusCode', 'sourceTimestamp', 'sourcePicoseconds',\n      'serverTimestamp', 'serverPicoseconds']);\n\n    mapPropertyAs(toRawValue, options, 'value', DataType.Variant);\n    mapPropertyAs(toRawValue, options, 'statusCode', DataType.StatusCode);\n    // NOTE: server- and sourceTimstamps get mapped as dates\n\n    return options;\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => ({\n    dataType,\n    arrayType,\n    value: getRawValue(value, dataType, arrayType), // eslint-disable-line no-use-before-define\n    dimensions,\n  }),\n  [DataType.DiagnosticInfo]: info => {\n    const options = pick(info, ['namespaceUri', 'symbolicId', 'locale', 'localizedText',\n      'additionalInfo', 'innerStatusCode', 'innerDiagnosticInfo']);\n\n    mapPropertyAs(toRawValue, options, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toRawValue, options, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n    return options;\n  },\n};\n\n/**\n * Decodes a buffer to a string.\n * @param {Buffer} b The buffer to decode from.\n * @return {string} The buffer's string representation.\n */\nconst decodeAsString = b => b.toString();\n\n/**\n * Decodes a buffer to an integer value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded integer.\n */\nconst decodeAsInt = b => parseInt(b.toString(), 10);\n\n/**\n * Decodes a buffer to a float value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded float.\n */\nconst decodeAsFloat = b => parseFloat(b.toString());\n\n/**\n * Decodes a buffer using JSON.\n * @param {Buffer} b The buffer to decode from.\n * @return {*} The decoded value, most likely an Object.\n */\nconst decodeAsJson = b => JSON.parse(b.toString());\n\n/**\n * Mapping functions that return raw values for a stored value of the given type.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst decodeRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.Boolean]: b => b.toString() === 'true',\n  [DataType.SByte]: decodeAsInt,\n  [DataType.Byte]: decodeAsInt,\n  [DataType.Int16]: decodeAsInt,\n  [DataType.UInt16]: decodeAsInt,\n  [DataType.Int32]: decodeAsInt,\n  [DataType.UInt32]: decodeAsInt,\n  [DataType.Int64]: decodeAsJson,\n  [DataType.UInt64]: decodeAsJson,\n  [DataType.Float]: decodeAsFloat,\n  [DataType.Double]: decodeAsFloat,\n  [DataType.String]: decodeAsString,\n  [DataType.DateTime]: decodeAsString,\n  [DataType.Guid]: decodeAsString,\n  // ByteString maps to Buffer\n  [DataType.XmlElement]: decodeAsString,\n  [DataType.NodeId]: decodeAsString,\n  [DataType.ExpandedNodeId]: decodeAsString,\n  [DataType.StatusCode]: decodeAsString,\n  [DataType.QualifiedName]: decodeAsJson,\n  [DataType.LocalizedText]: decodeAsJson,\n  // FIXME: Add ExtensionObject\n  [DataType.DataValue]: decodeAsJson,\n  [DataType.Variant]: decodeAsJson,\n  [DataType.DiagnosticInfo]: decodeAsJson,\n};\n\n/**\n * Mapping functions that return OPC-UA node values for raw values.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst toNodeValue = {\n  [DataType.DateTime]: s => new Date(s),\n  [DataType.ByteString]: b => {\n    if (b instanceof Buffer) { return b; }\n\n    return Buffer.from(b.data, 'binary');\n  },\n  [DataType.NodeId]: s => resolveNodeId(s),\n\n  // Jep, node-opcua does not provide a resolve function for expanded nodeids\n  [DataType.ExpandedNodeId]: s => {\n    const nodeId = resolveNodeId(s);\n    const [value, ...defs] = nodeId.value.split(';');\n\n    const { identifierType, namespace, namespaceUri, serverIndex } = defs.reduce((opts, def) => {\n      const match = def.match(/^([^:]+):(.*)/);\n      if (!match) { return opts; }\n\n      let [key, val] = match.slice(1); // eslint-disable-line prefer-const\n\n      if (key === 'serverIndex') {\n        val = parseInt(val, 10);\n      }\n\n      return Object.assign(opts, { [key]: val });\n    }, Object.assign({}, nodeId));\n\n    return new ExpandedNodeId(identifierType, value, namespace, namespaceUri, serverIndex);\n  },\n\n  [DataType.StatusCode]: name => StatusCodes[name],\n  [DataType.QualifiedName]: options => new QualifiedName(options),\n  [DataType.LocalizedText]: options => new LocalizedText(options),\n  [DataType.DataValue]: options => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'value', DataType.Variant);\n    mapPropertyAs(toNodeValue, opts, 'statusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'sourceTimestamp', DataType.DateTime);\n    mapPropertyAs(toNodeValue, opts, 'serverTimestamp', DataType.DateTime);\n\n    return new DataValue(opts);\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => new Variant({\n    dataType,\n    arrayType: VariantArrayType[arrayType],\n    value,\n    dimensions,\n  }),\n  [DataType.DiagnosticInfo]: options => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n    return new DiagnosticInfo(opts);\n  },\n};\n\n/**\n * Returns a node's raw value based on it's OPC-UA value and type.\n * @param {*} value A node's OPC-UA value.\n * @param {node-opcua~DataType} dataType The node's data type.\n * @param {node-opcua~VariantArrayType} arrayType The node's array type.\n * @return {*} The raw value of the given node.\n */\nconst getRawValue = (value, dataType, arrayType) => {\n  if (arrayType.value !== VariantArrayType.Scalar.value) {\n    const array = Array.isArray(value) ? value : Array.from(value);\n\n    return array.map(val => getRawValue(val, dataType, VariantArrayType[arrayType.value - 1]));\n  }\n\n  return (toRawValue[dataType] || asIs)(value);\n};\n\n/**\n * Returns a node's OPC-UA value based on it's raw value and type.\n * @param {*} rawValue A node's raw value.\n * @param {node-opcua~DataType} dataType A node's data type.\n * @param {node-opcua~VariantArrayType} arrayType A node's array type.\n */\nconst getNodeValue = (rawValue, dataType, arrayType) => {\n  if (arrayType.value !== VariantArrayType.Scalar.value) {\n    if (!Array.isArray(rawValue)) {\n      throw new Error('Value is not an array');\n    }\n\n    return rawValue.map(raw => getNodeValue(raw, dataType, VariantArrayType[arrayType.value - 1]));\n  }\n\n  return (toNodeValue[dataType] || asIs)(rawValue);\n};\n\n/**\n * Returns the extension for a specific {@link node-opcua~DataType}.\n * Algorithm:\n *   - if the type has a shortened extension defined in {@link ExtensionForDataType}, return it.\n *   - else return the DataType's name, in lowercase letters.\n * @param {node-opcua~DataType} dataType The datatype to get the extension for.\n * @return {string} The resulting extension.\n */\nfunction extensionForDataType(dataType) {\n  return ExtensionForDataType[dataType] || dataType.toString().toLowerCase();\n}\n\n/**\n * A regular expression that maches all reference definition files.\n * @type {RegExp}\n */\nconst ConfigFileRegexp = /^\\.((Object|Variable)(Type)?|Method|View|(Reference|Data)Type)\\.json$/;\n\n/**\n * An extension to {@link vinyl~File} providing some additional, atvise-related properties.\n * @property {node-opcua~DataType} AtviseFile#dataType The {@link node-opcua~DataType} the node is\n * stored against on atvise server.\n * @property {NodeId} typeDefinition The file's type definition on atvise server.\n * FIXME: Additional properties not showing in API docs.\n */\nexport default class AtviseFile extends File {\n\n  /**\n   * Returns a storage path for a {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to get a path for.\n   */\n  static pathForReadResult(readResult) {\n    let path = readResult.nodeId.filePath;\n\n    if (readResult.nodeClass.value !== NodeClass.Variable.value) {\n      return `${path}/.${readResult.nodeClass.key}.json`;\n    }\n\n    const dataType = readResult.value.$dataType;\n    const arrayType = readResult.value.$arrayType;\n    const typeDefinition = readResult.references.HasTypeDefinition[0];\n\n    if (typeDefinition.value === VariableTypeDefinition.value) {\n      // Variable nodes are stored with their lowercase datatype as an extension\n      path += `.${extensionForDataType(dataType)}`;\n    } else if (typeDefinition.value === PropertyTypeDefinition.value) {\n      // Property nodes are stored with \".prop\" and their lowercase datatype as an extension\n      path += `.prop.${extensionForDataType(dataType)}`;\n    } else {\n      // Handle custom types\n      let identifier = 'var';\n      let fileExtension = false;\n      let keepExtension = false;\n\n      const atType = AtviseTypesByValue[typeDefinition.value];\n      if (atType) {\n        identifier = atType.identifier;\n        fileExtension = atType.fileExtension;\n        keepExtension = atType.keepExtension;\n      }\n\n      if (!keepExtension) {\n        path += `.${identifier}.${fileExtension || extensionForDataType(dataType)}`;\n      }\n    }\n\n    // Add \"array\" or \"matrix\" extensions for corresponding array types\n    if (arrayType.value !== VariantArrayType.Scalar.value) {\n      path += `.${arrayType === VariantArrayType.Array ? 'array' : 'matrix'}`;\n    }\n\n    return path;\n  }\n\n  /**\n   * Encodes a node's value to file contents.\n   * @param {*} value The value to encode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to encode the value for.\n   * @param {node-opcua~VariantArrayType} arrayType The files array type.\n   * @return {?Buffer} The encoded file contents or null.\n   */\n  static encodeValue(value, dataType, arrayType) {\n    if (value.value === null) {\n      return Buffer.from('');\n    }\n\n    const rawValue = getRawValue(value.value, dataType, arrayType);\n\n    if (rawValue instanceof Buffer) {\n      return rawValue;\n    }\n\n    const stringify = a => (a.toJSON ? a.toJSON() : JSON.stringify(a, null, '  '));\n    const stringified = (typeof rawValue === 'object') ?\n      stringify(rawValue) :\n      rawValue.toString().trim();\n\n    return Buffer.from(stringified);\n  }\n\n  /**\n   * Decodes a file's contents to a node's value.\n   * @param {Buffer} buffer The file contents to decode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to decode the contents.\n   * @param {node-opcua~VariantArrayType} arrayType The files array type.\n   * @return {?*} The decoded node value or null.\n   */\n  static decodeValue(buffer, dataType, arrayType) {\n    if (buffer === null || buffer.length === 0) {\n      return null;\n    }\n\n    if (dataType === DataType.ByteString && arrayType === VariantArrayType.Scalar) {\n      return buffer;\n    }\n\n    const rawValue = arrayType === VariantArrayType.Scalar ?\n      (decodeRawValue[dataType] || asIs)(buffer) :\n      JSON.parse(buffer.toString());\n\n    return getNodeValue(rawValue, dataType, arrayType);\n  }\n\n  /**\n   * As file mtimes do not support millisecond resolution these must be removed before storing\n   * files.\n   * @param {Date} date The original mtime.\n   * @return {Date} The normalized mtime.\n   */\n  static normalizeMtime(date) {\n    date.setMilliseconds(0);\n\n    return date;\n  }\n\n  /**\n   * Creates a new {@link AtviseFile} for the given {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to create the file for.\n   * @return {AtviseFile} The resulting file.\n   */\n  static fromReadResult(readResult) {\n    const { nodeClass, references, value, mtime } = readResult;\n\n    if (nodeClass.value === NodeClass.Variable.value && !value) {\n      throw new Error('no value');\n    }\n\n    return new AtviseFile({\n      path: AtviseFile.pathForReadResult(readResult),\n      contents: value ?\n        AtviseFile.encodeValue(value, value.$dataType, value.$arrayType) : // Variables\n        Buffer.from(JSON.stringify({ references }, null, '  ')), // Objects, types, ...\n      _nodeClass: nodeClass,\n      _dataType: value && value.$dataType,\n      _arrayType: value && value.$arrayType,\n      _references: references,\n      stat: { mtime: mtime ? this.normalizeMtime(mtime) : undefined },\n    });\n  }\n\n  /**\n   * Recalculates {@link AtviseFile#dataType}, {@link AtviseFile#arrayType} and\n   * {@link AtviseFile#typeDefinition}. **Never call this method directly.**.\n   */\n  _getMetadata() {\n    if (this.stem[0] === '.') { // Got non-variable node\n      /**\n       * The node's class.\n       * @type {node-opcua~NodeClass}\n       */\n      this._nodeClass = NodeClass[this.stem.split('.')[1]];\n\n      const { references = {} } = JSON.parse(this.contents.toString());\n\n      /**\n       * References the node holds: In most cases this will be a single entry for\n       * `'HasTypeDefinition'`.\n       * @type {Map<String, NodeId[]>}\n       */\n      this._references = Object.entries(references)\n        .reduce((result, [type, refs]) => Object.assign(result, {\n          [type]: Array.isArray(refs) ? refs.map(v => new NodeId(v)) : new NodeId(refs),\n        }), {});\n\n      return;\n    }\n\n    this._nodeClass = NodeClass.Variable;\n\n    // Set default metadata\n    /**\n     * The node's stored {@link node-opcua~VariantArrayType}.\n     * @type {?node-opcua~VariantArrayType}\n     */\n    this._arrayType = VariantArrayType.Scalar;\n\n    this._references = {};\n\n    let extensions = [];\n    const m = this.relative.match(ExtensionRegExp);\n    if (m) {\n      extensions = m[1].split('.');\n    }\n\n    // For split files, add the directory name extension\n    const dirnameExts = this.dirname.split('.');\n    if (dirnameExts.length > 1) {\n      extensions.unshift(dirnameExts[dirnameExts.length - 1]);\n    }\n\n    function ifLastExtensionMatches(matches, fn) {\n      if (matches(extensions[extensions.length - 1])) {\n        fn(extensions.pop());\n      }\n    }\n\n    const complete = () => this._dataType !== undefined &&\n      this._references.HasTypeDefinition !== undefined;\n\n    // Handle array types\n    ifLastExtensionMatches(ext => ext === 'array', () => {\n      this._arrayType = VariantArrayType.Array;\n    });\n\n    ifLastExtensionMatches(ext => ext === 'matrix', () => {\n      this._arrayType = VariantArrayType.Matrix;\n    });\n\n    ifLastExtensionMatches(ext => typeExtensions.includes(ext), ext => {\n      /**\n       * The node's stored {@link node-opcua~DataType}.\n       * @type {?node-opcua~DataType}\n       */\n      this._dataType = DataType[types[typeExtensions.indexOf(ext)]];\n    });\n\n    // Handle wrapped data types (e.g. \"bool\" for DataType.Boolean)\n    ifLastExtensionMatches(ext => DataTypeForExtension[ext], ext => {\n      this._dataType = DataType[DataTypeForExtension[ext]];\n    });\n\n    if (extensions.length === 0) { // Got variable\n      /**\n       * The node's stored type definition.\n       * @type {?node-opcua~NodeId}\n       */\n      this._references.HasTypeDefinition = [new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0)];\n    }\n\n    ifLastExtensionMatches(ext => ext === 'prop', () => {\n      this._references.HasTypeDefinition = [new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0)];\n    });\n\n    ifLastExtensionMatches(ext => ext === 'var', () => {\n      this._references.HasTypeDefinition = [new NodeId('Custom.VarResourceType')];\n    });\n\n    if (!complete()) {\n      // Handle atvise types\n      let foundAtType = false;\n\n      Object.keys(AtviseTypesByIdentifier).forEach(identifier => {\n        if (!foundAtType && extensions.includes(identifier)) {\n          foundAtType = true;\n          const type = AtviseTypesByIdentifier[identifier];\n\n          this._references.HasTypeDefinition = [type.typeDefinition];\n          this._dataType = type.dataType;\n        }\n      });\n    }\n\n    if (!complete()) {\n      this._references.HasTypeDefinition = [\n        new NodeId('VariableTypes.ATVISE.Resource.OctetStream'),\n      ];\n      this._dataType = DataType.ByteString;\n    }\n  }\n\n  /**\n   * Computes a file's metadata if needed.\n   * @return {AtviseFile} The file.\n   */\n  getMetadata() {\n    if (!this._nodeClass) {\n      this._getMetadata();\n    }\n\n    return this;\n  }\n\n  /**\n   * The node's class.\n   * @type {node-opcua~NodeClass}\n   */\n  get nodeClass() {\n    if (!this._nodeClass) {\n      this._getMetadata();\n    }\n\n    return this._nodeClass;\n  }\n\n  /**\n   * The file's {@link node-opcua~DataType}.\n   * @type {node-opcua~DataType}\n   */\n  get dataType() {\n    if (!this._dataType) {\n      this._getMetadata();\n    }\n\n    return this._dataType;\n  }\n\n  /**\n   * The file's {@link node-opcua~VariantArrayType}.\n   * @type {node-opcua~VariantArrayType}\n   */\n  get arrayType() {\n    if (!this._arrayType) {\n      this._getMetadata();\n    }\n\n    return this._arrayType;\n  }\n\n  /**\n   * The files's references.\n   * @type {Map<string, NodeId|NodeId[]>}\n   */\n  get references() {\n    if (!this._references) {\n      this._getMetadata();\n    }\n\n    return this._references;\n  }\n\n  /**\n   * The file's type definition.\n   * @type {node-opcua~NodeId}\n   */\n  get typeDefinition() {\n    const refs = this.references;\n\n    if (refs && refs.HasTypeDefinition) {\n      return refs.HasTypeDefinition[0];\n    }\n\n    return new NodeId(NodeId.NodeIdType.NUMERIC, 0, 0);\n  }\n\n  // eslint-disable-next-line jsdoc/require-description-complete-sentence\n  /**\n   * `true` for reference config files (for example `.index.htm.json`).\n   * @type {boolean}\n   */\n  get isReferenceConfig() {\n    return this.stem[0] === '.' && !this.stem.match(ConfigFileRegexp);\n  }\n\n  /**\n   * `true` for files containing atvise displays.\n   * @type {boolean}\n   */\n  get isDisplay() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.Display';\n  }\n\n  /**\n   * `true` for files containing atvise scripts.\n   * @type {boolean}\n   */\n  get isScript() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.ScriptCode';\n  }\n\n  /**\n   * `true` for files containing atvise quick dynamics.\n   * @type {boolean}\n   */\n  get isQuickDynamic() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.QuickDynamic';\n  }\n\n  /**\n   * Sets the node value for the file.\n   * @param {?*} newValue The value to set.\n   */\n  set value(newValue) {\n    /**\n     * The file's contents.\n     * @type {?Buffer}\n     */\n    this.contents = AtviseFile.encodeValue(newValue, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for the file.\n   * @type {?*} The file's decoded value.\n   */\n  get value() {\n    return AtviseFile.decodeValue(this.contents, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for create node serverscript.\n   * @type {?*} The file's decoded value.\n   */\n  get createNodeValue() {\n    const value = this.value;\n\n    if (this.dataType === DataType.DateTime) {\n      return value.valueOf();\n    }\n\n    if (value instanceof Buffer) {\n      return value.toString();\n    }\n\n    return value;\n  }\n\n  /**\n   * Returns the node id associated with the file.\n   * @type {NodeId} The file's node id.\n   */\n  get nodeId() {\n    if (this.nodeClass.value !== NodeClass.Variable.value) {\n      return NodeId.fromFilePath(dirname(this.relative));\n    }\n    const atType = AtviseTypesByValue[this.typeDefinition.value];\n    let idPath = this.relative;\n\n    if (!atType || !atType.keepExtension) {\n      const exts = idPath.match(ExtensionRegExp)[1];\n      idPath = idPath.split(`.${exts}`)[0];\n    }\n\n    return NodeId.fromFilePath(idPath);\n  }\n\n  /**\n   * Returns a new file with all attributes of the current file.\n   * @param {Object} options See the {@link vinyl~File} docs for all options available.\n   * @return {AtviseFile} The cloned file.\n   * @see https://github.com/gulpjs/vinyl#filecloneoptions\n   */\n  clone(options) {\n    const clonedFile = super.clone(options);\n\n    clonedFile._nodeClass = this._nodeClass;\n    clonedFile._dataType = this._dataType;\n    clonedFile._arrayType = this._arrayType;\n    clonedFile._references = this._references;\n\n    return clonedFile;\n  }\n\n  /**\n   * Creates a new AtviseFile and reads it's contents.\n   * @param {Object} options See {@link vinyl~File} for available options.\n   * @return {Promise} Resolved with the new file of rejected with the error that occured while\n   * trying to read it's path.\n   */\n  static read(options = {}) {\n    return new Promise((resolve, reject) => {\n      if (!options.path) {\n        reject(new Error('options.path is required'));\n      } else {\n        readFile(options.path, (err, contents) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(new AtviseFile(Object.assign(options, { contents })));\n          }\n        });\n      }\n    });\n  }\n\n}\n"]}