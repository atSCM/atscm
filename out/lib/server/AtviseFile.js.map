{"version":3,"sources":["../../../src/lib/server/AtviseFile.js"],"names":["AtviseTypesByValue","AtviseTypes","reduce","result","type","Object","assign","typeDefinition","value","AtviseTypesByIdentifier","identifier","ExtensionForDataType","DataType","Boolean","XmlElement","DataTypeForExtension","types","keys","typeExtensions","map","t","toLowerCase","VariableTypeDefinition","NodeId","NodeIdType","NUMERIC","PropertyTypeDefinition","ExtensionRegExp","asIs","b","mapPropertyAs","obj","key","dataType","toRawValue","Null","StatusCode","name","QualifiedName","namespaceIndex","LocalizedText","text","locale","DataValue","options","Variant","arrayType","dimensions","getRawValue","DiagnosticInfo","info","decodeAsString","toString","trim","decodeAsInt","parseInt","decodeAsFloat","parseFloat","decodeAsJson","JSON","parse","decodeRawValue","SByte","Byte","Int16","UInt16","Int32","UInt32","Int64","UInt64","Float","Double","String","DateTime","Guid","ExpandedNodeId","toNodeValue","s","Date","ByteString","Buffer","from","data","nodeId","defs","split","identifierType","namespace","namespaceUri","serverIndex","opts","def","match","val","slice","StatusCodes","VariantArrayType","Scalar","array","Array","isArray","getNodeValue","rawValue","Error","raw","extensionForDataType","ConfigFileRegexp","AtviseFile","File","pathForReadResult","readResult","path","filePath","nodeClass","NodeClass","Variable","$dataType","$arrayType","references","HasTypeDefinition","fileExtension","keepExtension","atType","encodeValue","stringify","a","toJSON","stringified","decodeValue","buffer","length","normalizeMtime","date","setMilliseconds","fromReadResult","mtime","contents","_nodeClass","_dataType","_arrayType","_references","stat","undefined","_getMetadata","stem","entries","refs","v","_name","extensions","m","relative","dirnameExts","dirname","unshift","ifLastExtensionMatches","matches","fn","pop","complete","ext","Matrix","includes","indexOf","toParent","ReferenceTypeIds","HasProperty","foundAtType","forEach","AtviseResourceType","filter","e","join","getMetadata","isReferenceConfig","isDisplay","isScript","isQuickDynamic","newValue","createNodeValue","valueOf","fromFilePath","idPath","exts","parentNodeId","id","parts","parent","clone","clonedFile","read","Promise","resolve","reject","err"],"mappings":"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","sourcesContent":["import { readFile } from 'fs';\nimport { dirname } from 'path';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport { DataType, VariantArrayType, Variant } from 'node-opcua/lib/datamodel/variant';\nimport { resolveNodeId } from 'node-opcua/lib/datamodel/nodeid';\nimport { LocalizedText } from 'node-opcua/lib/datamodel/localized_text';\nimport { StatusCodes } from 'node-opcua/lib/datamodel/opcua_status_code';\nimport { QualifiedName } from 'node-opcua/lib/datamodel/qualified_name';\nimport { DataValue } from 'node-opcua/lib/datamodel/datavalue';\nimport { ReferenceTypeIds } from 'node-opcua/lib/opcua_node_ids';\nimport { ExpandedNodeId } from 'node-opcua/lib/datamodel/expanded_nodeid';\nimport { DiagnosticInfo } from 'node-opcua/lib/datamodel/diagnostic_info';\nimport File from 'vinyl';\nimport NodeId from '../model/opcua/NodeId';\nimport { reverse, pick } from '../helpers/Object';\nimport { sortReferences } from '../helpers/mapping';\nimport AtviseTypes, { AtviseResourceType } from './Types';\n\n/**\n * A map of AtviseTypes against their definition id's value.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByValue = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.typeDefinition.value]: type,\n  }), {});\n\n/**\n * A map of AtviseTypes against their identifiers.\n * @type {Map<String, AtivseType>}\n */\nconst AtviseTypesByIdentifier = AtviseTypes\n  .reduce((result, type) => Object.assign(result, {\n    [type.identifier]: type,\n  }), {});\n\n/**\n * A map providing shorter extensions for data types\n * @type {Map<node-opcua~DataType, String>}\n */\nexport const ExtensionForDataType = {\n  [DataType.Boolean]: 'bool',\n  [DataType.XmlElement]: 'xml',\n};\n\n/**\n * A map providing data types for shorter extensions (Reverse of {@link DataTypeForExtension}).\n * * @type {Map<String, node-opcua~DataType>}\n */\nexport const DataTypeForExtension = reverse(ExtensionForDataType);\n\n// Cache DataType\n/**\n * OPC-UA data type names.\n * @type {String[]}\n */\nconst types = Object.keys(DataType);\n\n/**\n * OPC-UA data type extensions.\n * @type {String[]}\n */\nconst typeExtensions = types.map(t => t.toLowerCase());\n\n// Cache TypeDefinitions\n/**\n * Variable data type definition node id.\n * @type {NodeId}\n */\nconst VariableTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0);\n/**\n * Property data type definition node id.\n * @type {NodeId}\n */\nconst PropertyTypeDefinition = new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0);\n\n// Cache Regular expressions\n/**\n * A regular expression picking file extensions from file names.\n * @type {RegExp}\n */\nconst ExtensionRegExp = /\\.([^/\\\\]*)$/;\n\n/**\n * Function that returns the passed argument as is.\n * @param {*} b The input argument.\n * @return {*} The value passed.\n */\nconst asIs = b => b;\n\n/**\n * Maps a single property of an object using the the mapper defined in *map* for the given\n * *dataType*.\n * @param {Map<node-opcua~DataType, function} map The mappings to use.\n * @param {Object} obj The object to process.\n * @param {string} key Name of the property to map.\n * @param {node-opcua~DataType} dataType The data type to map the property to.\n */\nconst mapPropertyAs = (map, obj, key, dataType) => {\n  if (obj[key]) {\n    return Object.assign(obj, {\n      [key]: map[dataType](obj[key]),\n    });\n  }\n\n  return obj;\n};\n\n/**\n * Mapping functions that return serializable values for a node of the given\n * {@link node-opcua~DataType}.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst toRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.StatusCode]: ({ name }) => name,\n  [DataType.QualifiedName]: ({ namespaceIndex, name }) => ({ namespaceIndex, name }),\n  [DataType.LocalizedText]: ({ text, locale }) => ({ text, locale }),\n  [DataType.DataValue]: value => {\n    const options = pick(value, ['value', 'statusCode', 'sourceTimestamp', 'sourcePicoseconds',\n      'serverTimestamp', 'serverPicoseconds']);\n\n    mapPropertyAs(toRawValue, options, 'value', DataType.Variant);\n    mapPropertyAs(toRawValue, options, 'statusCode', DataType.StatusCode);\n    // NOTE: server- and sourceTimstamps get mapped as dates\n\n    return options;\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => ({\n    dataType,\n    arrayType,\n    // eslint-disable-next-line no-use-before-define\n    value: getRawValue(value, dataType, arrayType),\n    dimensions,\n  }),\n  [DataType.DiagnosticInfo]: info => {\n    const options = pick(info, ['namespaceUri', 'symbolicId', 'locale', 'localizedText',\n      'additionalInfo', 'innerStatusCode', 'innerDiagnosticInfo']);\n\n    mapPropertyAs(toRawValue, options, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toRawValue, options, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n    return options;\n  },\n};\n\n/**\n * Decodes a buffer to a string.\n * @param {Buffer} b The buffer to decode from.\n * @return {string} The buffer's string representation.\n */\nconst decodeAsString = b => b.toString().trim();\n\n/**\n * Decodes a buffer to an integer value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded integer.\n */\nconst decodeAsInt = b => parseInt(decodeAsString(b), 10);\n\n/**\n * Decodes a buffer to a float value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded float.\n */\nconst decodeAsFloat = b => parseFloat(decodeAsString(b));\n\n/**\n * Decodes a buffer using JSON.\n * @param {Buffer} b The buffer to decode from.\n * @return {*} The decoded value, most likely an Object.\n */\nconst decodeAsJson = b => JSON.parse(b.toString());\n\n/**\n * Mapping functions that return raw values for a stored value of the given type.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst decodeRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.Boolean]: b => decodeAsString(b) === 'true',\n  [DataType.SByte]: decodeAsInt,\n  [DataType.Byte]: decodeAsInt,\n  [DataType.Int16]: decodeAsInt,\n  [DataType.UInt16]: decodeAsInt,\n  [DataType.Int32]: decodeAsInt,\n  [DataType.UInt32]: decodeAsInt,\n  [DataType.Int64]: decodeAsJson,\n  [DataType.UInt64]: decodeAsJson,\n  [DataType.Float]: decodeAsFloat,\n  [DataType.Double]: decodeAsFloat,\n  [DataType.String]: decodeAsString,\n  [DataType.DateTime]: decodeAsString,\n  [DataType.Guid]: decodeAsString,\n  // ByteString maps to Buffer\n  [DataType.XmlElement]: decodeAsString,\n  [DataType.NodeId]: decodeAsString,\n  [DataType.ExpandedNodeId]: decodeAsString,\n  [DataType.StatusCode]: decodeAsString,\n  [DataType.QualifiedName]: decodeAsJson,\n  [DataType.LocalizedText]: decodeAsJson,\n  // FIXME: Add ExtensionObject\n  [DataType.DataValue]: decodeAsJson,\n  [DataType.Variant]: decodeAsJson,\n  [DataType.DiagnosticInfo]: decodeAsJson,\n};\n\n/**\n * Mapping functions that return OPC-UA node values for raw values.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst toNodeValue = {\n  [DataType.DateTime]: s => new Date(s),\n  [DataType.ByteString]: b => {\n    if (b instanceof Buffer) { return b; }\n\n    return Buffer.from(b.data, 'binary');\n  },\n  [DataType.NodeId]: s => resolveNodeId(s),\n\n  // Jep, node-opcua does not provide a resolve function for expanded nodeids\n  [DataType.ExpandedNodeId]: s => {\n    const nodeId = resolveNodeId(s);\n    const [value, ...defs] = nodeId.value.split(';');\n\n    const { identifierType, namespace, namespaceUri, serverIndex } = defs.reduce((opts, def) => {\n      const match = def.match(/^([^:]+):(.*)/);\n      if (!match) { return opts; }\n\n      let [key, val] = match.slice(1); // eslint-disable-line prefer-const\n\n      if (key === 'serverIndex') {\n        val = parseInt(val, 10);\n      }\n\n      return Object.assign(opts, { [key]: val });\n    }, Object.assign({}, nodeId));\n\n    return new ExpandedNodeId(identifierType, value, namespace, namespaceUri, serverIndex);\n  },\n\n  [DataType.StatusCode]: name => StatusCodes[name],\n  [DataType.QualifiedName]: options => new QualifiedName(options),\n  [DataType.LocalizedText]: options => new LocalizedText(options),\n  [DataType.DataValue]: options => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'value', DataType.Variant);\n    mapPropertyAs(toNodeValue, opts, 'statusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'sourceTimestamp', DataType.DateTime);\n    mapPropertyAs(toNodeValue, opts, 'serverTimestamp', DataType.DateTime);\n\n    return new DataValue(opts);\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => new Variant({\n    dataType,\n    arrayType: VariantArrayType[arrayType],\n    value,\n    dimensions,\n  }),\n  [DataType.DiagnosticInfo]: options => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n    return new DiagnosticInfo(opts);\n  },\n};\n\n/**\n * Returns a node's raw value based on it's OPC-UA value and type.\n * @param {*} value A node's OPC-UA value.\n * @param {node-opcua~DataType} dataType The node's data type.\n * @param {node-opcua~VariantArrayType} arrayType The node's array type.\n * @return {*} The raw value of the given node.\n */\nconst getRawValue = (value, dataType, arrayType) => {\n  if (arrayType.value !== VariantArrayType.Scalar.value) {\n    const array = Array.isArray(value) ? value : Array.from(value);\n\n    return array.map(val => getRawValue(val, dataType, VariantArrayType[arrayType.value - 1]));\n  }\n\n  return (toRawValue[dataType] || asIs)(value);\n};\n\n/**\n * Returns a node's OPC-UA value based on it's raw value and type.\n * @param {*} rawValue A node's raw value.\n * @param {node-opcua~DataType} dataType A node's data type.\n * @param {node-opcua~VariantArrayType} arrayType A node's array type.\n */\nconst getNodeValue = (rawValue, dataType, arrayType) => {\n  if (arrayType.value !== VariantArrayType.Scalar.value) {\n    if (!Array.isArray(rawValue)) {\n      throw new Error('Value is not an array');\n    }\n\n    return rawValue.map(raw => getNodeValue(raw, dataType, VariantArrayType[arrayType.value - 1]));\n  }\n\n  return (toNodeValue[dataType] || asIs)(rawValue);\n};\n\n/**\n * Returns the extension for a specific {@link node-opcua~DataType}.\n * Algorithm:\n *   - if the type has a shortened extension defined in {@link ExtensionForDataType}, return it.\n *   - else return the DataType's name, in lowercase letters.\n * @param {node-opcua~DataType} dataType The datatype to get the extension for.\n * @return {string} The resulting extension.\n */\nfunction extensionForDataType(dataType) {\n  return ExtensionForDataType[dataType] || dataType.toString().toLowerCase();\n}\n\n/**\n * A regular expression that maches all reference definition files.\n * @type {RegExp}\n */\nconst ConfigFileRegexp = /^\\.((Object|Variable)(Type)?|Method|View|(Reference|Data)Type)\\.json$/;\n\n/**\n * An extension to {@link vinyl~File} providing some additional, atvise-related properties.\n * @property {node-opcua~DataType} AtviseFile#dataType The {@link node-opcua~DataType} the node is\n * stored against on atvise server.\n * @property {NodeId} typeDefinition The file's type definition on atvise server.\n * FIXME: Additional properties not showing in API docs.\n */\nexport default class AtviseFile extends File {\n\n  /**\n   * Returns a storage path for a {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to get a path for.\n   */\n  static pathForReadResult(readResult) {\n    let path = readResult.nodeId.filePath;\n\n    if (readResult.nodeClass.value !== NodeClass.Variable.value) {\n      return `${path}/.${readResult.nodeClass.key}.json`;\n    }\n\n    const dataType = readResult.value.$dataType;\n    const arrayType = readResult.value.$arrayType;\n    const typeDefinition = readResult.references.HasTypeDefinition[0];\n\n    if (typeDefinition.value === VariableTypeDefinition.value) {\n      // Variable nodes are stored with their lowercase datatype as an extension\n      path += `.${extensionForDataType(dataType)}`;\n    } else if (typeDefinition.value === PropertyTypeDefinition.value) {\n      // Property nodes are stored with \".prop\" and their lowercase datatype as an extension\n      path += `.prop.${extensionForDataType(dataType)}`;\n    } else {\n      // Handle custom types\n      let identifier = 'var';\n      let fileExtension = false;\n      let keepExtension = false;\n\n      const atType = AtviseTypesByValue[typeDefinition.value];\n      if (atType) {\n        identifier = atType.identifier;\n        fileExtension = atType.fileExtension;\n        keepExtension = atType.keepExtension;\n      }\n\n      if (!keepExtension) {\n        path += `.${identifier}.${fileExtension || extensionForDataType(dataType)}`;\n      }\n    }\n\n    // Add \"array\" or \"matrix\" extensions for corresponding array types\n    if (arrayType.value !== VariantArrayType.Scalar.value) {\n      path += `.${arrayType === VariantArrayType.Array ? 'array' : 'matrix'}`;\n    }\n\n    return path;\n  }\n\n  /**\n   * Encodes a node's value to file contents.\n   * @param {*} value The value to encode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to encode the value for.\n   * @param {node-opcua~VariantArrayType} arrayType The files array type.\n   * @return {?Buffer} The encoded file contents or null.\n   */\n  static encodeValue(value, dataType, arrayType) {\n    if (value.value === null) {\n      return Buffer.from('');\n    }\n\n    const rawValue = getRawValue(value.value, dataType, arrayType);\n\n    if (rawValue instanceof Buffer) {\n      return rawValue;\n    }\n\n    const stringify = a => (a.toJSON ? a.toJSON() : JSON.stringify(a, null, '  '));\n    const stringified = (typeof rawValue === 'object') ?\n      stringify(rawValue) :\n      rawValue.toString().trim();\n\n    return Buffer.from(stringified);\n  }\n\n  /**\n   * Decodes a file's contents to a node's value.\n   * @param {Buffer} buffer The file contents to decode.\n   * @param {node-opcua~DataType} dataType The {@link node-opcua~DataType} to decode the contents.\n   * @param {node-opcua~VariantArrayType} arrayType The files array type.\n   * @return {?*} The decoded node value or null.\n   */\n  static decodeValue(buffer, dataType, arrayType) {\n    if (buffer === null || buffer.length === 0) {\n      return null;\n    }\n\n    if (dataType === DataType.ByteString && arrayType === VariantArrayType.Scalar) {\n      return buffer;\n    }\n\n    const rawValue = arrayType === VariantArrayType.Scalar ?\n      (decodeRawValue[dataType] || asIs)(buffer) :\n      JSON.parse(buffer.toString());\n\n    return getNodeValue(rawValue, dataType, arrayType);\n  }\n\n  /**\n   * As file mtimes do not support millisecond resolution these must be removed before storing\n   * files.\n   * @param {Date} date The original mtime.\n   * @return {Date} The normalized mtime.\n   */\n  static normalizeMtime(date) {\n    date.setMilliseconds(0);\n\n    return date;\n  }\n\n  /**\n   * Creates a new {@link AtviseFile} for the given {@link ReadStream.ReadResult}.\n   * @param {ReadStream.ReadResult} readResult The read result to create the file for.\n   * @return {AtviseFile} The resulting file.\n   */\n  static fromReadResult(readResult) {\n    const { nodeClass, references, value, mtime } = readResult;\n\n    if (nodeClass.value === NodeClass.Variable.value && !value) {\n      throw new Error('no value');\n    }\n\n    return new AtviseFile({\n      path: AtviseFile.pathForReadResult(readResult),\n      contents: value ?\n        AtviseFile.encodeValue(value, value.$dataType, value.$arrayType) : // Variables\n        Buffer.from(JSON.stringify({\n          references: sortReferences(references),\n        }, null, '  ')), // Objects, types, ...\n      _nodeClass: nodeClass,\n      _dataType: value && value.$dataType,\n      _arrayType: value && value.$arrayType,\n      _references: references,\n      stat: { mtime: mtime ? this.normalizeMtime(mtime) : undefined },\n    });\n  }\n\n  /**\n   * Recalculates {@link AtviseFile#dataType}, {@link AtviseFile#arrayType} and\n   * {@link AtviseFile#typeDefinition}. **Never call this method directly.**.\n   */\n  _getMetadata() {\n    if (this.stem[0] === '.') { // Got non-variable node\n      /**\n       * The node's class.\n       * @type {node-opcua~NodeClass}\n       */\n      this._nodeClass = NodeClass[this.stem.split('.')[1]];\n\n      const { references = {} } = JSON.parse(this.contents.toString());\n\n      /**\n       * References the node holds: In most cases this will be a single entry for\n       * `'HasTypeDefinition'`.\n       * @type {Map<String, NodeId[]>}\n       */\n      this._references = Object.entries(references)\n        .reduce((result, [type, refs]) => Object.assign(result, {\n          [type]: Array.isArray(refs) ? refs.map(v => new NodeId(v)) : new NodeId(refs),\n        }), {});\n\n      return;\n    }\n\n    this._nodeClass = NodeClass.Variable;\n\n    // Set default metadata\n    /**\n     * The node's stored {@link node-opcua~VariantArrayType}.\n     * @type {?node-opcua~VariantArrayType}\n     */\n    this._arrayType = VariantArrayType.Scalar;\n\n    this._references = {};\n\n    /**\n     * A node's browse- and display name.\n     * @type {?string}\n     */\n    this._name = this.stem.split('.')[0];\n\n    let extensions = [];\n    const m = this.relative.match(ExtensionRegExp);\n    if (m) {\n      extensions = m[1].split('.');\n    }\n\n    // For split files, add the directory name extension\n    const dirnameExts = this.dirname.split('.');\n    if (dirnameExts.length > 1) {\n      extensions.unshift(dirnameExts[dirnameExts.length - 1]);\n    }\n\n    function ifLastExtensionMatches(matches, fn) {\n      if (matches(extensions[extensions.length - 1])) {\n        fn(extensions.pop());\n      }\n    }\n\n    const complete = () => this._dataType !== undefined &&\n      this._references.HasTypeDefinition !== undefined;\n\n    // Handle array types\n    ifLastExtensionMatches(ext => ext === 'array', () => {\n      this._arrayType = VariantArrayType.Array;\n    });\n\n    ifLastExtensionMatches(ext => ext === 'matrix', () => {\n      this._arrayType = VariantArrayType.Matrix;\n    });\n\n    ifLastExtensionMatches(ext => typeExtensions.includes(ext), ext => {\n      /**\n       * The node's stored {@link node-opcua~DataType}.\n       * @type {?node-opcua~DataType}\n       */\n      this._dataType = DataType[types[typeExtensions.indexOf(ext)]];\n    });\n\n    // Handle wrapped data types (e.g. \"bool\" for DataType.Boolean)\n    ifLastExtensionMatches(ext => DataTypeForExtension[ext], ext => {\n      this._dataType = DataType[DataTypeForExtension[ext]];\n    });\n\n    if (extensions.length === 0) { // Got variable\n      /**\n       * The node's stored type definition.\n       * @type {?node-opcua~NodeId}\n       */\n      this._references.HasTypeDefinition = [new NodeId(NodeId.NodeIdType.NUMERIC, 62, 0)];\n    }\n\n    ifLastExtensionMatches(ext => ext === 'prop', () => {\n      this._references.HasTypeDefinition = [new NodeId(NodeId.NodeIdType.NUMERIC, 68, 0)];\n      this._references.toParent = ReferenceTypeIds.HasProperty;\n    });\n\n    ifLastExtensionMatches(ext => ext === 'var', () => {\n      this._references.HasTypeDefinition = [new NodeId('Custom.VarResourceType')];\n    });\n\n    if (!complete()) {\n      // Handle atvise types\n      let foundAtType = false;\n\n      Object.entries(AtviseTypesByIdentifier).forEach(([identifier, type]) => {\n        if (!foundAtType && extensions.includes(identifier)) {\n          foundAtType = true;\n\n          if (!(type instanceof AtviseResourceType)) {\n            extensions = extensions.filter(e => e !== identifier);\n          }\n\n          this._references.HasTypeDefinition = [type.typeDefinition];\n          this._dataType = type.dataType;\n        }\n      });\n    }\n\n    if (!complete()) {\n      this._references.HasTypeDefinition = [\n        new NodeId('VariableTypes.ATVISE.Resource.OctetStream'),\n      ];\n      this._dataType = DataType.ByteString;\n    }\n\n    this._name = [this._name, ...extensions.filter(e => !dirnameExts.includes(e))].join('.');\n  }\n\n  /**\n   * Computes a file's metadata if needed.\n   * @return {AtviseFile} The file.\n   */\n  getMetadata() {\n    if (!this._nodeClass) {\n      this._getMetadata();\n    }\n\n    return this;\n  }\n\n  /**\n   * The node's class.\n   * @type {node-opcua~NodeClass}\n   */\n  get nodeClass() {\n    if (!this._nodeClass) {\n      this._getMetadata();\n    }\n\n    return this._nodeClass;\n  }\n\n  /**\n   * The file's {@link node-opcua~DataType}.\n   * @type {node-opcua~DataType}\n   */\n  get dataType() {\n    if (!this._dataType) {\n      this._getMetadata();\n    }\n\n    return this._dataType;\n  }\n\n  /**\n   * The file's {@link node-opcua~VariantArrayType}.\n   * @type {node-opcua~VariantArrayType}\n   */\n  get arrayType() {\n    if (!this._arrayType) {\n      this._getMetadata();\n    }\n\n    return this._arrayType;\n  }\n\n  /**\n   * The files's references.\n   * @type {Map<string, NodeId|NodeId[]>}\n   */\n  get references() {\n    if (!this._references) {\n      this._getMetadata();\n    }\n\n    return this._references;\n  }\n\n  /**\n   * The file's type definition.\n   * @type {node-opcua~NodeId}\n   */\n  get typeDefinition() {\n    const refs = this.references;\n\n    if (refs && refs.HasTypeDefinition) {\n      return refs.HasTypeDefinition[0];\n    }\n\n    return new NodeId(NodeId.NodeIdType.NUMERIC, 0, 0);\n  }\n\n  // eslint-disable-next-line jsdoc/require-description-complete-sentence\n  /**\n   * `true` for reference config files (for example `.index.htm.json`).\n   * @type {boolean}\n   */\n  get isReferenceConfig() {\n    return this.stem[0] === '.' && !this.stem.match(ConfigFileRegexp);\n  }\n\n  /**\n   * `true` for files containing atvise displays.\n   * @type {boolean}\n   */\n  get isDisplay() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.Display';\n  }\n\n  /**\n   * `true` for files containing atvise scripts.\n   * @type {boolean}\n   */\n  get isScript() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.ScriptCode';\n  }\n\n  /**\n   * `true` for files containing atvise quick dynamics.\n   * @type {boolean}\n   */\n  get isQuickDynamic() {\n    return this.typeDefinition.value === 'VariableTypes.ATVISE.QuickDynamic';\n  }\n\n  /**\n   * Sets the node value for the file.\n   * @param {?*} newValue The value to set.\n   */\n  set value(newValue) {\n    /**\n     * The file's contents.\n     * @type {?Buffer}\n     */\n    this.contents = AtviseFile.encodeValue(newValue, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for the file.\n   * @type {?*} The file's decoded value.\n   */\n  get value() {\n    return AtviseFile.decodeValue(this.contents, this.dataType, this.arrayType);\n  }\n\n  /**\n   * Returns the decoded node value for create node serverscript.\n   * @type {?*} The file's decoded value.\n   */\n  get createNodeValue() {\n    const value = this.value;\n\n    if (this.dataType === DataType.DateTime) {\n      return value.valueOf();\n    }\n\n    if (value instanceof Buffer) {\n      return value.toString();\n    }\n\n    return value;\n  }\n\n  /**\n   * Returns the node id associated with the file.\n   * @type {NodeId} The file's node id.\n   */\n  get nodeId() {\n    if (this.nodeClass.value !== NodeClass.Variable.value) {\n      return NodeId.fromFilePath(dirname(this.relative));\n    }\n    const atType = AtviseTypesByValue[this.typeDefinition.value];\n    let idPath = this.relative;\n\n    if (!atType || !atType.keepExtension) {\n      const exts = idPath.match(ExtensionRegExp)[1];\n      idPath = idPath.split(`.${exts}`)[0];\n    }\n\n    return NodeId.fromFilePath(idPath);\n  }\n\n  /**\n   * A file's browse and display name.\n   * @type {string}\n   */\n  get name() {\n    if (!this._name) {\n      this._getMetadata();\n    }\n\n    return this._name;\n  }\n\n  /**\n   * A file's parent's node id.\n   * @type {NodeId}\n   */\n  get parentNodeId() {\n    const name = this.name;\n    const id = this.nodeId;\n\n    if (name) {\n      const parts = this.nodeId.value.split(name);\n\n      if (parts.length > 1) {\n        return new NodeId(id.identifierType, parts[0].slice(0, -1), id.namespaceIndex);\n      }\n    }\n\n    return this.nodeId.parent;\n  }\n\n  /**\n   * Returns a new file with all attributes of the current file.\n   * @param {Object} options See the {@link vinyl~File} docs for all options available.\n   * @return {AtviseFile} The cloned file.\n   * @see https://github.com/gulpjs/vinyl#filecloneoptions\n   */\n  clone(options) {\n    const clonedFile = super.clone(options);\n\n    clonedFile._nodeClass = this._nodeClass;\n    clonedFile._dataType = this._dataType;\n    clonedFile._arrayType = this._arrayType;\n    clonedFile._references = this._references;\n\n    return clonedFile;\n  }\n\n  /**\n   * Creates a new AtviseFile and reads it's contents.\n   * @param {Object} options See {@link vinyl~File} for available options.\n   * @return {Promise} Resolved with the new file of rejected with the error that occured while\n   * trying to read it's path.\n   */\n  static read(options = {}) {\n    return new Promise((resolve, reject) => {\n      if (!options.path) {\n        reject(new Error('options.path is required'));\n      } else {\n        readFile(options.path, (err, contents) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(new AtviseFile(Object.assign(options, { contents })));\n          }\n        });\n      }\n    });\n  }\n\n}\n"],"file":"AtviseFile.js"}