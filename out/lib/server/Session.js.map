{"version":3,"sources":["../../../src/lib/server/Session.js"],"names":["openSessions","Set","openingSessions","Session","_create","client","OPCUAClient","requestedSessionTimeout","keepSessionAlive","certificateFile","__dirname","privateKeyFile","endpoint","ProjectConfig","host","port","opc","Promise","resolve","reject","timer","setTimeout","Error","connect","err","clearTimeout","createSession","userName","login","username","password","session","includes","message","response","responseHeader","serviceResult","StatusCodes","BadUserAccessDenied","Object","assign","_emitter","Emitter","add","create","c","then","s","delete","_pool","_createShared","pool","_close","close","_client","disconnect","ClientSession","open","Array","from","closeOpen","all","map"],"mappings":"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","sourcesContent":["import { join } from 'path';\nimport Emitter from 'events';\nimport { StatusCodes } from 'node-opcua/lib/datamodel/opcua_status_code';\nimport { OPCUAClient, ClientSession } from 'node-opcua/lib/client/opcua_client';\nimport ProjectConfig from '../../config/ProjectConfig';\n\n/**\n * The currently open sessions.\n * @type {Set<node-opcua~ClientSession>}\n */\nconst openSessions = new Set();\n\n/**\n * The sessions currentyl being opened.\n * @type {Set<node-opcua~ClientSession>}\n */\nconst openingSessions = new Set();\n\n/**\n * A wrapper around {@link node-opcua~ClientSession} used to connect to atvise server.\n * The sessions currentyl being opened.\n * @type {Set<node-opcua~ClientSession>}\n */\nexport default class Session {\n\n  /**\n   * Creates an {@link node-opcuaOPCUAClient} and opens a new  {@link node-opcua~ClientSession}.\n   * @return {Promise<node-opcua~ClientSession, Error>} Fulfilled with an already opened\n   * {@link node-opcua~ClientSession}.\n   */\n  static async _create() {\n    const client = new OPCUAClient({\n      requestedSessionTimeout: 600000,\n      keepSessionAlive: true,\n      certificateFile: join(__dirname, '../../../res/certificates/certificate.pem'),\n      privateKeyFile: join(__dirname, '../../../res/certificates/key.pem'),\n    });\n\n    const endpoint = `opc.tcp://${ProjectConfig.host}:${ProjectConfig.port.opc}`;\n\n    await new Promise((resolve, reject) => {\n      const timer = setTimeout(() => reject(\n        new Error(`Unable to connect to ${endpoint}: Connection timed out`)\n      ), 5000);\n\n      client.connect(endpoint, err => {\n        clearTimeout(timer);\n        return err ? reject(err) : resolve();\n      });\n    });\n\n    return new Promise((resolve, reject) => {\n      client.createSession({\n        userName: ProjectConfig.login.username,\n        password: ProjectConfig.login.password,\n      }, (err, session) => {\n        if (err) {\n          if (\n            [\n              'userName === null || typeof userName === \"string\"',\n              'password === null || typeof password === \"string\"',\n            ].includes(err.message) ||\n            (err.response &&\n            err.response.responseHeader.serviceResult === StatusCodes.BadUserAccessDenied)\n          ) {\n            reject(new Error('Unable to create session: Invalid login'));\n          } else {\n            reject(err);\n          }\n        } else {\n          Object.assign(session, { _emitter: new Emitter() });\n\n          openSessions.add(session);\n\n          resolve(session);\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates an {@link node-opcuaOPCUAClient} and opens a new  {@link node-opcua~ClientSession}. If\n   * pooling is active, the shared session will be reused.\n   * @return {Promise<node-opcua~ClientSession, Error>} Fulfilled with an already opened\n   * {@link node-opcua~ClientSession}.\n   */\n  static create() {\n    const create = () => {\n      const c = this._create();\n      openingSessions.add(c);\n\n      return c.then(s => openingSessions.delete(c) && s);\n    };\n\n    if (!this._pool) {\n      return create();\n    }\n\n    if (!this._createShared) {\n      /**\n       * A promise that resolves once the shared session is created.\n       * @type {Promise<node-opcua~ClientSession}\n       */\n      this._createShared = create();\n    }\n\n    return this._createShared;\n  }\n\n  // eslint-disable-next-line jsdoc/require-description-complete-sentence\n  /**\n   * Starts pooling (reusing) sessions. Note that you'll have to manually close sessions using\n   * {@link Session.closeOpen}.\n   */\n  static pool() {\n    /**\n     * If sessions should be reused.\n     * @type {boolean}\n     */\n    this._pool = true;\n  }\n\n  /**\n   * Closes the given session. Waits for currently opening sessions to open.\n   * @param {node-opcua~ClientSession} session The session to close.\n   * @return {Promise<node-opcua~ClientSession, Error>} Fulfilled with the (now closed!) session or\n   * rejected with the error that occured while closing.\n   */\n  static async _close(session) {\n    openSessions.delete(session);\n\n    await new Promise(resolve => session.close(true, () => resolve()));\n    await new Promise(resolve => session._client && session._client.disconnect(() => resolve()));\n\n    return session;\n  }\n\n  /**\n   * Closes the given session. When session pooling is active the session won't actually be closed\n   * and the returned Promise will resolve immediately.\n   * @param {node-opcua~ClientSession} session The session to close.\n   * @return {Promise<node-opcua~ClientSession, Error>} Fulfilled with the (maybe closed) session or\n   * rejected with the error that occured while closing.\n   */\n  static close(session) {\n    if (!session || !(session instanceof ClientSession)) {\n      return Promise.reject(new Error('session is required'));\n    }\n\n    if (this._pool) { return Promise.resolve(); }\n\n    return this._close(session);\n  }\n\n  /**\n   * The sessions currently open. Starting with version 1.0.0-beta.25 there will be one at most.\n   * @type {Session[]}\n   */\n  static get open() {\n    return Array.from(openSessions);\n  }\n\n  /**\n   * Closes all open sessions.\n   * @return {Promise<Error, Session[]>} Rejected with the error that occurred while closing the\n   * sessions or fulfilled with the (now closed) sessions affected.\n   */\n  static async closeOpen() {\n    await Promise.all(openingSessions);\n\n    return Promise.all(\n      Array.from(openSessions).map(session => this._close(session))\n    );\n  }\n\n}\n"],"file":"Session.js"}