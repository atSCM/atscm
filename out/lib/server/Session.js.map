{"version":3,"sources":["../../../src/lib/server/Session.js"],"names":["emitter","Emitter","openSessions","openingSessions","Session","create","Client","then","client","Promise","resolve","reject","createSession","userName","ProjectConfig","login","username","password","err","session","includes","message","response","responseHeader","serviceResult","StatusCodes","BadUserAccessDenied","Error","Object","assign","_emitter","push","emit","close","deleteSubscriptions","ClientSession","_closed","_closing","on","markAsClosed","splice","indexOf","BadSessionIdInvalid","Logger","debug","_client","disconnect","clientErr","open","closeOpen","closeSessions","sessions","all","map","length","once"],"mappings":"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","sourcesContent":["import Emitter from 'events';\nimport { StatusCodes } from 'node-opcua/lib/datamodel/opcua_status_code';\nimport { ClientSession } from 'node-opcua/lib/client/opcua_client';\nimport Logger from 'gulplog';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport Client from './Client';\n\n/**\n * The global EventEmitter used to emit events.\n * @type {events~Emitter}\n */\nconst emitter = new Emitter();\n\n/**\n * The currently open sessions.\n * @type {node-opcua~ClientSession[]}\n */\nconst openSessions = [];\n\n/**\n * The number of session currently being opened.\n * @type {Number}\n */\nlet openingSessions = 0;\n\n/**\n * A wrapper around {@link node-opcua~ClientSession} used to connect to atvise server.\n */\nexport default class Session {\n\n  /**\n   * An {@link events~Emitter} that emits events when creating / closing sessions.\n   * @type {events~Emitter}\n   */\n  static get emitter() {\n    return emitter;\n  }\n\n  /**\n   * Creates and opens a new {@link node-opcua~ClientSession}.\n   * @return {Promise<node-opcua~ClientSession, Error>} Fulfilled with an already opened\n   * {@link node-opcua~ClientSession}.\n   * @emits {undefined} Emits an `all-open` event once all opening sessions are open.\n   */\n  static create() {\n    openingSessions++;\n\n    return Client.create()\n      .then(client => new Promise((resolve, reject) => {\n        client.createSession({\n          userName: ProjectConfig.login.username,\n          password: ProjectConfig.login.password,\n        }, (err, session) => {\n          if (err) {\n            if (\n              [\n                'userName === null || typeof userName === \"string\"',\n                'password === null || typeof password === \"string\"',\n              ].includes(err.message) ||\n              (err.response &&\n              err.response.responseHeader.serviceResult === StatusCodes.BadUserAccessDenied)\n            ) {\n              reject(new Error('Unable to create session: Invalid login'));\n            } else {\n              reject(new Error(`Unable to create session: ${err.message}`));\n            }\n          } else {\n            Object.assign(session, { _emitter: new Emitter() });\n\n            openSessions.push(session);\n            resolve(session);\n          }\n\n          openingSessions--;\n          if (openingSessions === 0) {\n            emitter.emit('all-open');\n          }\n        });\n      }));\n  }\n\n  /**\n   * Closes the given session.\n   * @param {node-opcua~ClientSession} session The session to close.\n   * @param {boolean} [deleteSubscriptions=true] If active subscriptions should be closed as well.\n   * @return {Promise<node-opcua~ClientSession, Error>} Fulfilled with the (now closed!) session or\n   * rejected with the error that occured while closing.\n   */\n  static close(session, deleteSubscriptions = true) {\n    if (!session || !(session instanceof ClientSession)) {\n      return Promise.reject(new Error('session is required'));\n    }\n\n    if (session._closed) {\n      return Promise.resolve();\n    }\n\n    if (session._closing) {\n      return new Promise(resolve => {\n        session._emitter.on('fully-closed', () => resolve(session));\n      });\n    }\n\n    Object.assign(session, { _closing: true });\n\n    return new Promise((resolve, reject) => {\n      function markAsClosed() {\n        openSessions.splice(openSessions.indexOf(session), 1);\n        Object.assign(session, { _closed: true });\n\n        resolve(session);\n        session._emitter.emit('fully-closed');\n      }\n\n      session.close(deleteSubscriptions, err => {\n        if (err) {\n          if (err.response &&\n            err.response.responseHeader.serviceResult === StatusCodes.BadSessionIdInvalid\n          ) {\n            Logger.debug('Attempted to close a session that does not exist');\n            markAsClosed(session);\n          } else if (err.message === 'no channel') {\n            // Client already disconnected\n            markAsClosed(session);\n          } else {\n            reject(new Error(`Unable to close session: ${err.message}`));\n          }\n        } else {\n          session._client.disconnect(clientErr => {\n            if (clientErr) {\n              reject(new Error(`Unable to disconnect client: ${clientErr.message}`));\n            } else {\n              markAsClosed(session);\n            }\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * The sessions currently open.\n   * @type {Session[]}\n   */\n  static get open() {\n    return openSessions;\n  }\n\n  /**\n   * Closes all open sessions.\n   * @return {Promise<Error, Session[]>} Rejected with the error that occurred while closing the\n   * sessions or fulfilled with the (now closed) sessions affected.\n   */\n  static closeOpen() {\n    function closeSessions(sessions) {\n      return Promise.all(\n        sessions.map(session => Session.close(session))\n      );\n    }\n\n    if (openingSessions === 0) {\n      if (openSessions.length === 0) {\n        return Promise.resolve([]);\n      }\n\n      return closeSessions(openSessions);\n    }\n\n    return new Promise((resolve, reject) => {\n      emitter.once('all-open', () => {\n        closeSessions(openSessions)\n          .then(resolve, reject);\n      });\n    });\n  }\n\n}\n"],"file":"Session.js"}