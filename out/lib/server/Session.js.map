{"version":3,"sources":["../../../src/lib/server/Session.js"],"names":["openSessions","Set","openingSessions","Session","_create","client","OPCUAClient","requestedSessionTimeout","keepSessionAlive","certificateFile","__dirname","privateKeyFile","endpoint","ProjectConfig","host","port","opc","timer","setTimeout","Logger","warn","timeout","cb","connect","debug","clearTimeout","session","createSession","userName","login","username","password","catch","err","includes","message","response","responseHeader","serviceResult","StatusCodes","BadUserAccessDenied","Error","add","Object","assign","_emitter","Emitter","create","c","then","s","delete","_pool","_createShared","pool","_close","Promise","resolve","close","_client","disconnect","ClientSession","reject","open","Array","from","closeOpen","all","map"],"mappings":"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","sourcesContent":["import { join } from 'path';\nimport Emitter from 'events';\nimport { StatusCodes } from 'node-opcua/lib/datamodel/opcua_status_code';\nimport { OPCUAClient, ClientSession } from 'node-opcua/lib/client/opcua_client';\nimport Logger from 'gulplog';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport { promisified } from '../helpers/async';\n\n/**\n * The currently open sessions.\n * @type {Set<node-opcua~ClientSession>}\n */\nconst openSessions = new Set();\n\n/**\n * The sessions currentyl being opened.\n * @type {Set<node-opcua~ClientSession>}\n */\nconst openingSessions = new Set();\n\n/**\n * A wrapper around {@link node-opcua~ClientSession} used to connect to atvise server.\n * The sessions currentyl being opened.\n * @type {Set<node-opcua~ClientSession>}\n */\nexport default class Session {\n  /**\n   * Creates an {@link node-opcuaOPCUAClient} and opens a new  {@link node-opcua~ClientSession}.\n   * @return {Promise<node-opcua~ClientSession, Error>} Fulfilled with an already opened\n   * {@link node-opcua~ClientSession}.\n   */\n  static async _create() {\n    const client = new OPCUAClient({\n      requestedSessionTimeout: 600000,\n      keepSessionAlive: true,\n      certificateFile: join(__dirname, '../../../res/certificates/certificate.pem'),\n      privateKeyFile: join(__dirname, '../../../res/certificates/key.pem'),\n    });\n\n    const endpoint = `opc.tcp://${ProjectConfig.host}:${ProjectConfig.port.opc}`;\n\n    const timer = setTimeout(() => {\n      Logger.warn(`It takes unusually long to connect to the atvise server at ${endpoint}.\n - Are you sure it is running?`);\n    }, ProjectConfig.timeout);\n\n    await promisified(cb => client.connect(endpoint, cb));\n    Logger.debug(`Connected to ${endpoint}`);\n    clearTimeout(timer);\n\n    const session = await promisified(cb =>\n      client.createSession(\n        {\n          userName: ProjectConfig.login.username,\n          password: ProjectConfig.login.password,\n        },\n        cb\n      )\n    ).catch(err => {\n      if (\n        [\n          'userName === null || typeof userName === \"string\"',\n          'password === null || typeof password === \"string\"',\n        ].includes(err.message) ||\n        (err.response &&\n          err.response.responseHeader.serviceResult === StatusCodes.BadUserAccessDenied)\n      ) {\n        throw new Error('Unable to create session: Invalid login');\n      }\n\n      throw err;\n    });\n\n    openSessions.add(session);\n    return Object.assign(session, { _emitter: new Emitter() });\n  }\n\n  /**\n   * Creates an {@link node-opcuaOPCUAClient} and opens a new  {@link node-opcua~ClientSession}. If\n   * pooling is active, the shared session will be reused.\n   * @return {Promise<node-opcua~ClientSession, Error>} Fulfilled with an already opened\n   * {@link node-opcua~ClientSession}.\n   */\n  static create() {\n    const create = () => {\n      const c = this._create();\n      openingSessions.add(c);\n\n      return c.then(s => openingSessions.delete(c) && s);\n    };\n\n    if (!this._pool) {\n      return create();\n    }\n\n    if (!this._createShared) {\n      /**\n       * A promise that resolves once the shared session is created.\n       * @type {Promise<node-opcua~ClientSession}\n       */\n      this._createShared = create();\n    }\n\n    return this._createShared;\n  }\n\n  // eslint-disable-next-line jsdoc/require-description-complete-sentence\n  /**\n   * Starts pooling (reusing) sessions. Note that you'll have to manually close sessions using\n   * {@link Session.closeOpen}.\n   */\n  static pool() {\n    /**\n     * If sessions should be reused.\n     * @type {boolean}\n     */\n    this._pool = true;\n  }\n\n  /**\n   * Closes the given session. Waits for currently opening sessions to open.\n   * @param {node-opcua~ClientSession} session The session to close.\n   * @return {Promise<node-opcua~ClientSession, Error>} Fulfilled with the (now closed!) session or\n   * rejected with the error that occured while closing.\n   */\n  static async _close(session) {\n    openSessions.delete(session);\n\n    await new Promise(resolve => session.close(true, () => resolve()));\n    await new Promise(resolve => session._client && session._client.disconnect(() => resolve()));\n\n    return session;\n  }\n\n  /**\n   * Closes the given session. When session pooling is active the session won't actually be closed\n   * and the returned Promise will resolve immediately.\n   * @param {node-opcua~ClientSession} session The session to close.\n   * @return {Promise<node-opcua~ClientSession, Error>} Fulfilled with the (maybe closed) session or\n   * rejected with the error that occured while closing.\n   */\n  static close(session) {\n    if (!session || !(session instanceof ClientSession)) {\n      return Promise.reject(new Error('session is required'));\n    }\n\n    if (this._pool) {\n      return Promise.resolve();\n    }\n\n    return this._close(session);\n  }\n\n  /**\n   * The sessions currently open. Starting with version 1.0.0-beta.25 there will be one at most.\n   * @type {Session[]}\n   */\n  static get open() {\n    return Array.from(openSessions);\n  }\n\n  /**\n   * Closes all open sessions.\n   * @return {Promise<Error, Session[]>} Rejected with the error that occurred while closing the\n   * sessions or fulfilled with the (now closed) sessions affected.\n   */\n  static async closeOpen() {\n    await Promise.all(openingSessions);\n\n    return Promise.all(Array.from(openSessions).map(session => this._close(session)));\n  }\n}\n"],"file":"Session.js"}