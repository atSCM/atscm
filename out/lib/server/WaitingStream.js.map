{"version":3,"sources":["../../../src/lib/server/WaitingStream.js"],"names":["waitForDependencies","Stream","Waiting","constructor","options","_dependencies","_waitingFor","_finishedProcessing","on","file","key","nodeId","toString","dependents","forEach","d","k","_enqueueChunk","emit","dependenciesFor","Error","dependencies","filter","id","namespace","value","ProjectConfig","nodes","includes","match","map","length","needToWait","reduce","wait","dependency","name","concat","_flush","callback","checkProcessing","_processing","hasPending","once","Object","keys","first","Logger","debug","WaitingStream","QueueStream"],"mappings":"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","sourcesContent":["import Logger from 'gulplog';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport QueueStream from './QueueStream';\n\n/**\n * A mixin that transforms a regular stream into a {@link WaitingStream}, which makes it wait for a\n * node's dependencies to be transformed.\n * @param {QueueStream} Stream The node stream to inherit from.\n * @return {Class<WaitingStream>} The resulting stream class.\n * @example <caption>Basic usage</caption>\n * import QueueStream from 'atscm/src/lib/server/QueueStream';\n * import { waitForDependencies } from 'atscm/src/lib/server/WaitingStream';\n *\n * class MyWaitingStream extends waitForDependencies(QueueStream) {\n *\n *   dependenciesFor(file) {\n *     return [\n *       // An array of node ids\n *     ];\n *   }\n *\n * }\n */\nexport const waitForDependencies = Stream => class Waiting extends Stream {\n\n  /**\n   * Creates a new WaitingStream.\n   * @param {Object} options Options passed to the underlying {@link Stream} subclass.\n   */\n  constructor(options = {}) {\n    super(options);\n\n    this._dependencies = {};\n    this._waitingFor = {};\n    this._finishedProcessing = {};\n\n    this.on('processed-chunk', file => {\n      const key = file.nodeId.toString();\n      const dependents = this._waitingFor[key];\n      delete this._waitingFor[key];\n      this._finishedProcessing[key] = true;\n\n      if (dependents) {\n        dependents.forEach(d => {\n          const k = d.nodeId.toString();\n          this._dependencies[k] -= 1;\n\n          if (this._dependencies[k] === 0) {\n            super._enqueueChunk(d);\n            delete this._dependencies[k];\n          }\n        });\n      }\n\n      this.emit('finished-chunk');\n    });\n  }\n\n  /**\n   * **Must be implemented by all subclasses:** Returns the dependencies for a given file.\n   * @typedef {function(file: AtviseFile): NodeId[]} WWaiting#dependenciesFor\n   * @param {AtviseFile} file The file to get the dependencies for.\n   * @return {NodeId[]} The file's dependencies.\n   * @abstract\n   */\n  dependenciesFor(file) { // eslint-disable-line @typescript-eslint/no-unused-vars\n    throw new Error('#dependenciesFor must be implemented by all subclasses');\n  }\n\n  /**\n   * Enqueues a file after it's dependencies.\n   * @param {AtviseFile} file The file to process.\n   */\n  _enqueueChunk(file) {\n    const dependencies = this.dependenciesFor(file)\n      .filter(id => {\n        if (id.namespace === 0 || !id.value || ProjectConfig.nodes.includes(id)) { return false; }\n\n        return !id.value.match(/^(Object|Variable)Types$/) &&\n          !id.value.match(/^(Object|Variable)Types\\.ATVISE/) &&\n          !id.value.match(/^SYSTEM\\.LIBRARY\\.ATVISE/);\n      })\n      .map(id => id.toString());\n\n    if (dependencies && dependencies.length) {\n      const needToWait = dependencies.reduce((wait, dependency) => {\n        if (!this._finishedProcessing[dependency]) {\n          const name = file.nodeId.toString();\n\n          this._waitingFor[dependency] = (this._waitingFor[dependency] || []).concat(file);\n          this._dependencies[name] = (this._dependencies[name] || 0) + 1;\n\n          return true;\n        }\n        return wait;\n      }, false);\n\n      if (needToWait) { return; }\n    }\n\n    super._enqueueChunk(file);\n  }\n\n  /**\n   * Delays the streams end until all chunks have been processed.\n   * @param {function(err: Error)} callback Called once all chunks have been processed.\n   */\n  _flush(callback) {\n    const checkProcessing = () => {\n      if (this._processing || this.hasPending) {\n        this.once('finished-chunk', () => checkProcessing());\n      } else if (Object.keys(this._waitingFor).length > 0) {\n        const first = Object.keys(this._waitingFor)[0];\n\n        Logger.debug(`Missing dependency. Trying to process dependents of ${first}`);\n\n        this.once('finished-chunk', () => checkProcessing());\n        this.emit('processed-chunk', { nodeId: first });\n      } else {\n        super._flush(callback);\n      }\n    };\n\n    checkProcessing();\n  }\n\n};\n\n/**\n * A {@link QueueStream} that waits for a file's dependencies to be processed before the file is\n * processed itself.\n * @abstract\n */\nexport default class WaitingStream extends waitForDependencies(QueueStream) {}\n"],"file":"WaitingStream.js"}