{"version":3,"sources":["../../../src/lib/server/NodeStream.js"],"names":["BrowseReferenceTypes","HasComponent","HasProperty","HasSubtype","HasEventSource","HasNotifier","AtviseReferenceTypes","HasHistoricalConfiguration","TypeDefinitionReferenceTypes","HasTypeDefinition","HasModellingRule","ValidReferenceTypes","Set","NodeStream","constructor","nodesToBrowse","options","Array","length","Error","ignoreNodes","recursive","undefined","_resultMask","makeResultMask","ignoredRegExp","RegExp","map","n","toString","join","nodes","filter","nodeId","ignored","isIgnored","warn","info","once","_writeNodesToBrowse","session","read","attributeId","NodeClass","err","_","results","emit","hasReadError","reduce","error","statusCode","i","Good","description","forEach","value","write","nodeClass","debug","_processed","end","processErrorMessage","isValidReference","ref","has","referenceTypeId","refNodeId","match","shouldBeProcessed","shouldBeBrowsed","includes","isChildOf","handleResult","toParent","result","done","references","Promise","all","bind","promise","resolve","Object","setPrototypeOf","prototype","addToReferences","push","$nodeClass","referenceType","then","catch","processChunk","handleErrors","browse","browseDirection","BrowseDirection","Forward","includeSubtypes","resultMask"],"mappings":"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","file":"NodeStream.js","sourcesContent":["/* Needed as long as https://github.com/gajus/eslint-plugin-jsdoc/issues/56 is open */\n/* eslint-disable jsdoc/check-param-names */\n\nimport {\n  browse_service as BrowseService,\n  NodeClass,\n  ReferenceTypeIds,\n  AttributeIds,\n  StatusCodes,\n} from 'node-opcua';\nimport Logger from 'gulplog';\nimport Project from '../../config/ProjectConfig';\nimport NodeId from '../model/opcua/NodeId';\nimport ReverseReferenceTypeIds from '../model/opcua/ReverseReferenceTypeIds';\nimport QueueStream from './QueueStream';\n\n/**\n * List of reference types that should be browsed.\n * @see https://github.com/node-opcua/node-opcua/blob/608771099fbfaa42195e150bdf36956affbb53e9/packages/node-opcua-constants/src/opcua_node_ids.js\n * @type {node-opcua~ReferenceTypeId[]}\n */\nconst BrowseReferenceTypes = [\n  ReferenceTypeIds.HasComponent,\n  ReferenceTypeIds.HasProperty,\n  ReferenceTypeIds.HasSubtype,\n  ReferenceTypeIds.HasEventSource,\n  ReferenceTypeIds.HasNotifier,\n];\n\n/**\n * List of reference types that are used for node metadata.\n * @type {node-opcua~ReferenceTypeId[]}\n * @see https://github.com/node-opcua/node-opcua/blob/608771099fbfaa42195e150bdf36956affbb53e9/packages/node-opcua-constants/src/opcua_node_ids.js\n */\nconst AtviseReferenceTypes = [\n  ReferenceTypeIds.HasEventSource,\n  ReferenceTypeIds.HasNotifier,\n  ReferenceTypeIds.HasHistoricalConfiguration,\n];\n\n/**\n * List of reference types that are used for node metadata\n * @type {node-opcua~ReferenceTypeId[]}\n * @see https://github.com/node-opcua/node-opcua/blob/608771099fbfaa42195e150bdf36956affbb53e9/packages/node-opcua-constants/src/opcua_node_ids.js\n */\nconst TypeDefinitionReferenceTypes = [\n  ReferenceTypeIds.HasTypeDefinition,\n  ReferenceTypeIds.HasModellingRule,\n];\n\n/**\n * List of valid reference types\n * @type {Set<node-opcua~ReferenceTypeId>}\n * @see https://github.com/node-opcua/node-opcua/blob/608771099fbfaa42195e150bdf36956affbb53e9/packages/node-opcua-constants/src/opcua_node_ids.js\n */\nconst ValidReferenceTypes = new Set([\n  ...BrowseReferenceTypes,\n  ...AtviseReferenceTypes,\n  ...TypeDefinitionReferenceTypes,\n]);\n\n/**\n * A stream that browses the nodes specified and (if *recursive* option is set) it's child nodes.\n * Pushes {@link NodeStream.BrowseResult}s to piped streams.\n */\nexport default class NodeStream extends QueueStream {\n\n  /**\n   * Creates a new NodeStream based on the nodes to start browsing with and some options.\n   * @param {NodeId[]} nodesToBrowse The nodes to start browsing with.\n   * @param {Object} [options] The options to use.\n   * @param {boolean} [options.recursive=true] If the discovered nodes should be browsed as well.\n   * @param {NodeId[]} [options.ignoreNodes=ProjectConfig.ignoreNodes] An array of {@link NodeId}s\n   * to ignore.\n   */\n  constructor(nodesToBrowse, options = {}) {\n    if (!nodesToBrowse || !(nodesToBrowse instanceof Array) || nodesToBrowse.length === 0) {\n      throw new Error('nodesToBrowse is required');\n    }\n\n    if (options && options.ignoreNodes && !(options.ignoreNodes instanceof Array)) {\n      throw new Error('ignoreNodes must be an array of node ids');\n    }\n\n    super(options);\n\n    // Handle options\n    /**\n     * If the discovered nodes should be browsed as well.\n     * @type {Boolean}\n     */\n    this.recursive = true;\n    if (options.recursive !== undefined) {\n      this.recursive = options.recursive;\n    }\n\n    let ignoreNodes = Project.ignoreNodes;\n    if (options.ignoreNodes !== undefined) {\n      ignoreNodes = options.ignoreNodes;\n    }\n\n    /**\n     * The result mask to use.\n     * @type {UInt32}\n     */\n    this._resultMask = BrowseService.makeResultMask('ReferenceType | NodeClass | TypeDefinition');\n\n    /**\n     * A regular expression matching all node ids specified in {@link NodeStream#ignoreNodes}\n     * @type {RegExp}\n     */\n    this.ignoredRegExp = new RegExp(`^(${ignoreNodes.map(n => n.toString()).join('|')})`);\n\n    const nodes = nodesToBrowse.filter(nodeId => {\n      const ignored = this.isIgnored({ nodeId });\n\n      if (ignored) {\n        Logger.warn(`${nodeId} is set to be browsed, but ignored.`);\n        Logger.info(` - Remove ${nodeId} from Atviseproject#nodes if this is intentionally.`);\n      }\n\n      return !ignored;\n    });\n\n    if (!nodes.length) {\n      throw new Error('Nothing to browse');\n    }\n\n    // Write nodes to read\n    this.once('session-open', () => {\n      this._writeNodesToBrowse(nodesToBrowse);\n    });\n  }\n\n  /**\n   * Once the stream's session is open it reads the {@link node-opcua~NodeClass}es of\n   * *nodesToBrowse* (passed to the constructor) from atvise server. After that it writes the\n   * read results to itself and starts browsing.\n   * @param {NodeId[]} nodes The nodes passed to the constructor.\n   */\n  _writeNodesToBrowse(nodes) {\n    this.session.read(nodes.map(nodeId => ({\n      nodeId,\n      attributeId: AttributeIds.NodeClass,\n    })), (err, _, results) => {\n      if (err) {\n        this.emit('error', err);\n        return;\n      }\n\n      const hasReadError = results.reduce((error, { statusCode }, i) => {\n        if (error) { return error; }\n\n        if (statusCode !== StatusCodes.Good) {\n          this.emit('error', new Error(`Error reading ${nodes[i]}: ${statusCode.description}`));\n          return true;\n        }\n\n        return false;\n      }, false);\n\n      if (hasReadError) {\n        return;\n      }\n\n      results.forEach(({ value }, i) => this.write({\n        nodeClass: NodeClass[value.value],\n        nodeId: nodes[i],\n      }));\n\n      // End once drained\n      this.once('drained', () => {\n        Logger.debug(`Discovered ${this._processed} nodes`);\n        this.end();\n      });\n\n      this.emit('initial-read-complete', {});\n    });\n  }\n\n  /**\n   * Returns an error message specifically for the given nodeId.\n   * @param {NodeId} nodeId The node id to get the error message for.\n   * @return {string} The specific error message.\n   */\n  processErrorMessage(nodeId) {\n    return `Error browsing ${nodeId.toString()}`;\n  }\n\n  /**\n   * Checks if the given reference is a valid browse stream reference or not.\n   * @param {node-opcua~ReferenceDescription} ref The reference description to check.\n   * @return {boolean} reference is valid(=true) or not(=false)\n   */\n  isValidReference(ref) {\n    return ValidReferenceTypes.has(ref.referenceTypeId.value);\n  }\n\n  /**\n   * Checks if the given reference description is ignored.\n   * @param {node-opcua~ReferenceDescription} ref The reference description to check.\n   * @return {boolean} The given reference description should be ignored(=true) or not(=false)\n   */\n  isIgnored(ref) {\n    const refNodeId = ref.nodeId.toString();\n\n    if (refNodeId.match(this.ignoredRegExp)) {\n      Logger.debug(`Ignored node: ${refNodeId}`);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks if the given reference matches the defined browse Filters.\n   * @param {node-opcua~ReferenceDescription} ref The reference description to check.\n   * @return {boolean} reference matches browse filters(=true) or not(=false)\n   */\n  shouldBeProcessed(ref) {\n    return this.isValidReference(ref) && !this.isIgnored(ref);\n  }\n\n  /**\n   * Checks if the given reference should be pushed to NodeStream input or not.\n   * @param {node-opcua~ReferenceDescription} ref The reference description to check.\n   * @param {node-opcua~NodeId} nodeId The browsed nodeId.\n   * @return {boolean} reference should be pushed(=true) or not(=false)\n   */\n  shouldBeBrowsed(ref, nodeId) {\n    return BrowseReferenceTypes.includes(ref.referenceTypeId.value) && ref.nodeId.isChildOf(nodeId);\n  }\n\n  /**\n   * Handles a browse result of a single node. All child references are written to the stream, other\n   * references and the browsed node itself are pusched to piped streams.\n   * @param {Object} browsedNode The id and class of the currently browsed node.\n   * @param {Object} result The result of the browsing the node.\n   * @param  {function(err: Error)} done Called once the node has been processed.\n   */\n  handleResult({ nodeId, nodeClass, toParent }, result, done) {\n    const nodesToBrowse = [];\n\n    const references = { toParent };\n\n    Promise.all(\n      result.references\n        // Ignore specified nodes\n        .filter(this.shouldBeProcessed.bind(this))\n        // Push variable nodes, recurse\n        .map(ref => {\n          let promise = Promise.resolve();\n\n          // \"Cast\" ref.nodeId to NodeId\n          Object.setPrototypeOf(ref.nodeId, NodeId.prototype);\n\n          let addToReferences = true;\n\n          if (this.recursive && this.shouldBeBrowsed(ref, nodeId) &&\n            !nodesToBrowse.includes(ref.nodeId.toString())) {\n            nodesToBrowse.push(ref.nodeId.toString());\n            addToReferences = false;\n\n            promise = new Promise((resolve) => {\n              this.write({\n                nodeId: ref.nodeId,\n                nodeClass: ref.$nodeClass,\n                toParent: ReverseReferenceTypeIds[ref.referenceTypeId.value],\n              }, null, resolve);\n            });\n          }\n\n          if (addToReferences) {\n            const referenceType = ReverseReferenceTypeIds[ref.referenceTypeId.value];\n\n            if (!references[referenceType]) {\n              references[referenceType] = [];\n            }\n\n            references[referenceType].push(ref.nodeId);\n          }\n\n          return promise;\n        })\n    )\n      .then(() => {\n        this.push({ nodeClass, nodeId, references });\n\n        done();\n      })\n      .catch(done);\n  }\n\n  /**\n   * Returns a {ReadStream.ReadResult} for the given reference description.\n   * @param {NodeId} nodeId The node id to browse.\n   * @param {function(err: Error, statusCode: node-opcua~StatusCodes, onSuccess: function)}\n   * handleErrors The error handler to call. See {@link QueueStream#processChunk} for details.\n   */\n  processChunk({ nodeId, nodeClass, toParent }, handleErrors) {\n    this.session.browse({\n      nodeId,\n      browseDirection: BrowseService.BrowseDirection.Forward,\n      includeSubtypes: true,\n      resultMask: this._resultMask,\n    }, (err, results) => {\n      if (!err && (!results || results.length === 0)) {\n        handleErrors(new Error('No results'));\n      } else {\n        handleErrors(err, results && results.length > 0 ? results[0].statusCode : null, done => {\n          this.handleResult({ nodeId, nodeClass, toParent }, results[0], done);\n        });\n      }\n    });\n  }\n\n}\n"]}