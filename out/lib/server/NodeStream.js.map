{"version":3,"sources":["../../../src/lib/server/NodeStream.js"],"names":["BrowseReferenceTypes","HasComponent","HasProperty","HasSubtype","HasEventSource","HasNotifier","AtviseReferenceTypes","HasHistoricalConfiguration","TypeDefinitionReferenceTypes","HasTypeDefinition","HasModellingRule","InverseReferenceTypes","Organizes","ValidReferenceTypes","Set","NodeStream","constructor","nodesToBrowse","options","Array","length","Error","ignoreNodes","recursive","undefined","_resultMask","makeResultMask","ignoredRegExp","RegExp","map","n","toString","join","nodes","filter","nodeId","ignored","isIgnored","warn","info","once","_writeNodesToBrowse","checkResultsStatus","results","failing","reduce","f","statusCode","i","Good","concat","getParentRefs","Promise","resolve","reject","session","browse","browseDirection","BrowseDirection","Inverse","includeSubtypes","resultMask","err","res","references","toParent","reference","referenceTypeId","value","find","includes","getNodeClasses","read","attributeId","NodeClass","_","nodeClass","all","then","parents","classes","forEach","write","Object","assign","debug","_processed","end","emit","catch","processErrorMessage","isValidReference","ref","has","refNodeId","match","shouldBeProcessed","shouldBeBrowsed","isChildOf","handleResult","parent","result","done","bind","promise","setPrototypeOf","prototype","addToReferences","push","$nodeClass","referenceType","processChunk","handleErrors","Forward"],"mappings":"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","file":"NodeStream.js","sourcesContent":["/* Needed as long as https://github.com/gajus/eslint-plugin-jsdoc/issues/56 is open */\n/* eslint-disable jsdoc/check-param-names */\n\nimport {\n  browse_service as BrowseService,\n  NodeClass,\n  ReferenceTypeIds,\n  AttributeIds,\n  StatusCodes,\n} from 'node-opcua';\nimport Logger from 'gulplog';\nimport Project from '../../config/ProjectConfig';\nimport NodeId from '../model/opcua/NodeId';\nimport ReverseReferenceTypeIds from '../model/opcua/ReverseReferenceTypeIds';\nimport QueueStream from './QueueStream';\n\n/**\n * List of reference types that should be browsed.\n * @see https://github.com/node-opcua/node-opcua/blob/608771099fbfaa42195e150bdf36956affbb53e9/packages/node-opcua-constants/src/opcua_node_ids.js\n * @type {node-opcua~ReferenceTypeId[]}\n */\nconst BrowseReferenceTypes = [\n  ReferenceTypeIds.HasComponent,\n  ReferenceTypeIds.HasProperty,\n  ReferenceTypeIds.HasSubtype,\n  ReferenceTypeIds.HasEventSource,\n  ReferenceTypeIds.HasNotifier,\n];\n\n/**\n * List of reference types that are used for node metadata.\n * @type {node-opcua~ReferenceTypeId[]}\n * @see https://github.com/node-opcua/node-opcua/blob/608771099fbfaa42195e150bdf36956affbb53e9/packages/node-opcua-constants/src/opcua_node_ids.js\n */\nconst AtviseReferenceTypes = [\n  ReferenceTypeIds.HasEventSource,\n  ReferenceTypeIds.HasNotifier,\n  ReferenceTypeIds.HasHistoricalConfiguration,\n];\n\n/**\n * List of reference types that are used for node metadata.\n * @type {node-opcua~ReferenceTypeId[]}\n * @see https://github.com/node-opcua/node-opcua/blob/608771099fbfaa42195e150bdf36956affbb53e9/packages/node-opcua-constants/src/opcua_node_ids.js\n */\nconst TypeDefinitionReferenceTypes = [\n  ReferenceTypeIds.HasTypeDefinition,\n  ReferenceTypeIds.HasModellingRule,\n];\n\n/**\n * List of reference types that are used for node metadata.\n * @type {node-opcua~ReferenceTypeId[]}\n * @see https://github.com/node-opcua/node-opcua/blob/608771099fbfaa42195e150bdf36956affbb53e9/packages/node-opcua-constants/src/opcua_node_ids.js\n */\nconst InverseReferenceTypes = [\n  ReferenceTypeIds.Organizes,\n];\n\n/**\n * List of valid reference types\n * @type {Set<node-opcua~ReferenceTypeId>}\n * @see https://github.com/node-opcua/node-opcua/blob/608771099fbfaa42195e150bdf36956affbb53e9/packages/node-opcua-constants/src/opcua_node_ids.js\n */\nconst ValidReferenceTypes = new Set([\n  ...BrowseReferenceTypes,\n  ...AtviseReferenceTypes,\n  ...TypeDefinitionReferenceTypes,\n  ...InverseReferenceTypes,\n]);\n\n/**\n * A stream that browses the nodes specified and (if *recursive* option is set) it's child nodes.\n * Pushes {@link NodeStream.BrowseResult}s to piped streams.\n */\nexport default class NodeStream extends QueueStream {\n\n  /**\n   * Creates a new NodeStream based on the nodes to start browsing with and some options.\n   * @param {NodeId[]} nodesToBrowse The nodes to start browsing with.\n   * @param {Object} [options] The options to use.\n   * @param {boolean} [options.recursive=true] If the discovered nodes should be browsed as well.\n   * @param {NodeId[]} [options.ignoreNodes=ProjectConfig.ignoreNodes] An array of {@link NodeId}s\n   * to ignore.\n   */\n  constructor(nodesToBrowse, options = {}) {\n    if (!nodesToBrowse || !(nodesToBrowse instanceof Array) || nodesToBrowse.length === 0) {\n      throw new Error('nodesToBrowse is required');\n    }\n\n    if (options && options.ignoreNodes && !(options.ignoreNodes instanceof Array)) {\n      throw new Error('ignoreNodes must be an array of node ids');\n    }\n\n    super(options);\n\n    // Handle options\n    /**\n     * If the discovered nodes should be browsed as well.\n     * @type {Boolean}\n     */\n    this.recursive = true;\n    if (options.recursive !== undefined) {\n      this.recursive = options.recursive;\n    }\n\n    let ignoreNodes = Project.ignoreNodes;\n    if (options.ignoreNodes !== undefined) {\n      ignoreNodes = options.ignoreNodes;\n    }\n\n    /**\n     * The result mask to use.\n     * @type {UInt32}\n     */\n    this._resultMask = BrowseService.makeResultMask('ReferenceType | NodeClass | TypeDefinition');\n\n    /**\n     * A regular expression matching all node ids specified in {@link NodeStream#ignoreNodes}\n     * @type {RegExp}\n     */\n    this.ignoredRegExp = new RegExp(`^(${ignoreNodes.map(n => n.toString()).join('|')})`);\n\n    const nodes = nodesToBrowse.filter(nodeId => {\n      const ignored = this.isIgnored({ nodeId });\n\n      if (ignored) {\n        Logger.warn(`${nodeId} is set to be browsed, but ignored.`);\n        Logger.info(` - Remove ${nodeId} from Atviseproject#nodes if this is intentionally.`);\n      }\n\n      return !ignored;\n    });\n\n    if (!nodes.length) {\n      throw new Error('Nothing to browse');\n    }\n\n    // Write nodes to read\n    this.once('session-open', () => {\n      this._writeNodesToBrowse(nodes);\n    });\n  }\n\n  /**\n   * Once the stream's session is open it reads the {@link node-opcua~NodeClass}es of\n   * *nodesToBrowse* (passed to the constructor) from atvise server. After that it writes the\n   * read results to itself and starts browsing.\n   * @param {NodeId[]} nodes The nodes passed to the constructor.\n   */\n  _writeNodesToBrowse(nodes) {\n    function checkResultsStatus(results) {\n      if (!results || !results.length) {\n        throw new Error('No results');\n      }\n\n      const failing = results.reduce((f, { statusCode }, i) => {\n        if (statusCode !== StatusCodes.Good) {\n          return f.concat(nodes[i]);\n        }\n\n        return f;\n      }, []);\n\n      if (failing.length) {\n        const info = failing.join(', ');\n\n        throw new Error(`Error reading ${info}`);\n      }\n    }\n\n    const getParentRefs = async () => {\n      const results = await new Promise((resolve, reject) => {\n        this.session.browse(nodes.map(nodeId => ({\n          nodeId,\n          browseDirection: BrowseService.BrowseDirection.Inverse,\n          includeSubtypes: true,\n          resultMask: this._resultMask,\n        })), (err, res) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(res);\n          }\n        });\n      });\n\n      checkResultsStatus(results);\n\n      return results.map(({ references }) => ({\n        toParent: ReverseReferenceTypeIds[\n          references\n            .map(reference => reference.referenceTypeId.value)\n            .find(value => BrowseReferenceTypes.includes(value))\n        ],\n      }));\n    };\n\n    const getNodeClasses = async () => {\n      const results = await new Promise((resolve, reject) => {\n        this.session.read(nodes.map(nodeId => ({\n          nodeId,\n          attributeId: AttributeIds.NodeClass,\n        })), (err, _, res) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(res);\n          }\n        });\n      });\n\n      checkResultsStatus(results);\n\n      return results.map(({ value }) => ({\n        nodeClass: NodeClass[value.value],\n      }));\n    };\n\n    Promise.all([getParentRefs(), getNodeClasses()])\n      .then(([parents, classes]) => {\n        nodes.forEach((nodeId, i) => {\n          this.write(Object.assign({ nodeId }, parents[i], classes[i]));\n        });\n\n        // End once drained\n        this.once('drained', () => {\n          Logger.debug(`Discovered ${this._processed} nodes`);\n          this.end();\n        });\n\n        this.emit('initial-read-complete', {});\n      })\n      .catch(err => this.emit('error', err));\n  }\n\n  /**\n   * Returns an error message specifically for the given nodeId.\n   * @param {Object} chunk The chunk to get the error message for.\n   * @param {NodeId} chunk.nodeId The browsed nodeId.\n   * @return {string} The specific error message.\n   */\n  processErrorMessage({ nodeId }) {\n    return `Error browsing ${nodeId.toString()}`;\n  }\n\n  /**\n   * Checks if the given reference is a valid browse stream reference or not.\n   * @param {node-opcua~ReferenceDescription} ref The reference description to check.\n   * @return {boolean} reference is valid(=true) or not(=false)\n   */\n  isValidReference(ref) {\n    return ValidReferenceTypes.has(ref.referenceTypeId.value);\n  }\n\n  /**\n   * Checks if the given reference description is ignored.\n   * @param {node-opcua~ReferenceDescription} ref The reference description to check.\n   * @return {boolean} The given reference description should be ignored(=true) or not(=false)\n   */\n  isIgnored(ref) {\n    const refNodeId = ref.nodeId.toString();\n\n    if (refNodeId.match(this.ignoredRegExp)) {\n      Logger.debug(`Ignored node: ${refNodeId}`);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Checks if the given reference matches the defined browse Filters.\n   * @param {node-opcua~ReferenceDescription} ref The reference description to check.\n   * @return {boolean} reference matches browse filters(=true) or not(=false)\n   */\n  shouldBeProcessed(ref) {\n    return this.isValidReference(ref) && !this.isIgnored(ref);\n  }\n\n  /**\n   * Checks if the given reference should be pushed to NodeStream input or not.\n   * @param {node-opcua~ReferenceDescription} ref The reference description to check.\n   * @param {node-opcua~NodeId} nodeId The browsed nodeId.\n   * @return {boolean} reference should be pushed(=true) or not(=false)\n   */\n  shouldBeBrowsed(ref, nodeId) {\n    return BrowseReferenceTypes.includes(ref.referenceTypeId.value) && ref.nodeId.isChildOf(nodeId);\n  }\n\n  /**\n   * Handles a browse result of a single node. All child references are written to the stream, other\n   * references and the browsed node itself are pusched to piped streams.\n   * @param {Object} browsedNode The id and class of the currently browsed node.\n   * @param {Object} result The result of the browsing the node.\n   * @param  {function(err: Error)} done Called once the node has been processed.\n   */\n  handleResult({ nodeId, nodeClass, toParent, parent }, result, done) {\n    const nodesToBrowse = [];\n\n    const references = { toParent };\n\n    Promise.all(\n      result.references\n        // Ignore specified nodes\n        .filter(this.shouldBeProcessed.bind(this))\n        // Push variable nodes, recurse\n        .map(ref => {\n          let promise = Promise.resolve();\n\n          // \"Cast\" ref.nodeId to NodeId\n          Object.setPrototypeOf(ref.nodeId, NodeId.prototype);\n\n          let addToReferences = true;\n\n          if (this.recursive && this.shouldBeBrowsed(ref, nodeId) &&\n            !nodesToBrowse.includes(ref.nodeId.toString())) {\n            nodesToBrowse.push(ref.nodeId.toString());\n            addToReferences = false;\n\n            promise = new Promise((resolve) => {\n              this.write({\n                nodeId: ref.nodeId,\n                nodeClass: ref.$nodeClass,\n                toParent: ReverseReferenceTypeIds[ref.referenceTypeId.value],\n                parent: nodeId,\n              }, null, resolve);\n            });\n          }\n\n          if (addToReferences) {\n            const referenceType = ReverseReferenceTypeIds[ref.referenceTypeId.value];\n\n            if (!references[referenceType]) {\n              references[referenceType] = [];\n            }\n\n            references[referenceType].push(ref.nodeId);\n          }\n\n          return promise;\n        })\n    )\n      .then(() => {\n        this.push({ nodeClass, nodeId, references, parent });\n\n        done();\n      })\n      .catch(done);\n  }\n\n  /**\n   * Returns a {ReadStream.ReadResult} for the given reference description.\n   * @param {NodeId} nodeId The node id to browse.\n   * @param {function(err: Error, statusCode: node-opcua~StatusCodes, onSuccess: function)}\n   * handleErrors The error handler to call. See {@link QueueStream#processChunk} for details.\n   */\n  processChunk({ nodeId, nodeClass, toParent, parent }, handleErrors) {\n    this.session.browse({\n      nodeId,\n      browseDirection: BrowseService.BrowseDirection.Forward,\n      includeSubtypes: true,\n      resultMask: this._resultMask,\n    }, (err, results) => {\n      if (!err && (!results || results.length === 0)) {\n        handleErrors(new Error('No results'));\n      } else {\n        handleErrors(err, results && results.length > 0 ? results[0].statusCode : null, done => {\n          this.handleResult({ nodeId, nodeClass, toParent, parent }, results[0], done);\n        });\n      }\n    });\n  }\n\n}\n"]}