{"version":3,"sources":["../../../src/lib/server/NodeStream.js"],"names":["NodeStream","constructor","nodesToBrowse","options","Array","length","Error","ignoreNodes","recursive","undefined","_resultMask","makeResultMask","ignoredRegExp","RegExp","map","n","toString","join","forEach","nodeId","write","once","end","processErrorMessage","processChunk","handleErrors","session","browse","browseDirection","BrowseDirection","Forward","includeSubtypes","resultMask","err","results","statusCode","done","Promise","all","references","filter","ref","value","split","match","nodeClass","Variable","Object","setPrototypeOf","prototype","push","resolve","then"],"mappings":"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","file":"NodeStream.js","sourcesContent":["import { browse_service as BrowseService, NodeClass } from 'node-opcua';\nimport QueueStream from './QueueStream';\nimport NodeId from './NodeId';\nimport Project from '../../config/ProjectConfig';\n\n/**\n * A stream that browses the nodes specified and (if *recursive* option is set) it's child nodes.\n */\nexport default class NodeStream extends QueueStream {\n\n  /**\n   * Creates a new NodeStream based on the nodes to start browsing with and some options.\n   * @param {NodeId[]} nodesToBrowse The nodes to start browsing with.\n   * @param {Object} [options] The options to use.\n   * @param {Boolean} [options.recursive=true] If the discovered nodes should be browsed as well.\n   * @param {NodeId[]} [options.ignoreNodes=ProjectConfig.ignoreNodes] An array of {@link NodeId}s\n   * to ignore.\n   */\n  constructor(nodesToBrowse, options = {}) {\n    if (!nodesToBrowse || !(nodesToBrowse instanceof Array) || nodesToBrowse.length === 0) {\n      throw new Error('nodesToBrowse is required');\n    }\n\n    if (options && options.ignoreNodes && !(options.ignoreNodes instanceof Array)) {\n      throw new Error('ignoreNodes must be an array of node ids');\n    }\n\n    super(options);\n\n    // Handle options\n    /**\n     * If the discovered nodes should be browsed as well.\n     * @type {Boolean}\n     */\n    this.recursive = true;\n    if (options.recursive !== undefined) {\n      this.recursive = options.recursive;\n    }\n\n    let ignoreNodes = Project.ignoreNodes;\n    if (options.ignoreNodes !== undefined) {\n      ignoreNodes = options.ignoreNodes;\n    }\n\n    /**\n     * The result mask to use.\n     * @type {UInt32}\n     */\n    this._resultMask = BrowseService.makeResultMask('ReferenceType | NodeClass | TypeDefinition');\n\n    /**\n     * A regular expression matching all node ids specified in {@link NodeStream#ignoreNodes}\n     * @type {RegExp}\n     */\n    this.ignoredRegExp = new RegExp(`^(${ignoreNodes.map(n => n.toString()).join('|')})`);\n\n    // Write nodes to read\n    nodesToBrowse.forEach(nodeId => this.write(nodeId));\n\n    // End once drained\n    this.once('drained', () => {\n      this.end();\n    });\n  }\n\n  /**\n   * Returns an error message specifically for the given nodeId.\n   * @param {NodeId} nodeId The node id to get the error message for.\n   * @return {String} The specific error message.\n   */\n  processErrorMessage(nodeId) {\n    return `Error browsing ${nodeId.toString()}`;\n  }\n\n  /**\n   * Returns a {ReadStream.ReadResult} for the given reference description.\n   * @param {NodeId} nodeId The node id to browse.\n   * @param {function(err: Error, statusCode: node-opcua~StatusCodes, onSuccess: function)}\n   * handleErrors The error handler to call. See {@link QueueStream#processChunk} for details.\n   */\n  processChunk(nodeId, handleErrors) {\n    this.session.browse({\n      nodeId,\n      browseDirection: BrowseService.BrowseDirection.Forward,\n      includeSubtypes: true,\n      resultMask: this._resultMask,\n    }, (err, results) => {\n      if (!err && (!results || results.length === 0)) {\n        handleErrors(new Error('No results'));\n      } else {\n        handleErrors(err, results && results.length > 0 ? results[0].statusCode : null, done => {\n          Promise.all(\n            results[0].references\n            // Remove parent nodes\n              .filter(ref => ref.nodeId.value.toString().split(nodeId.value).length > 1)\n              // Ignore specified nodes\n              // TODO: Print ignored nodes (debug level)\n              .filter(ref => !(ref.nodeId.toString().match(this.ignoredRegExp)))\n              // Push variable nodes, recurse\n              .map(ref => {\n                // Push all variable ids\n                if (ref.nodeClass.value === NodeClass.Variable.value) {\n                  // \"Cast\" ref.nodeId to NodeId\n                  Object.setPrototypeOf(ref.nodeId, NodeId.prototype);\n\n                  this.push(ref);\n                }\n\n                if (this.recursive) {\n                  return new Promise((resolve) => {\n                    this.write(ref.nodeId, null, resolve);\n                  });\n                }\n\n                return Promise.resolve();\n              })\n          )\n            .then(done);\n        });\n      }\n    });\n  }\n\n}\n"]}