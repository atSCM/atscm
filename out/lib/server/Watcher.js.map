{"version":3,"sources":["../../../src/lib/server/Watcher.js"],"names":["SubscribeStream","QueueStream","constructor","options","Object","assign","keepSessionAlive","_trackChanges","once","createSubscription","subscription","ClientSubscription","session","requestedPublishingInterval","requestedLifetimeCount","requestedMaxKeepAliveCount","maxNotificationsPerPublish","publishingEnabled","priority","on","emit","err","processErrorMessage","referenceDescription","nodeId","toString","processChunk","handleErrors","id","item","monitor","attributeId","AttributeIds","Value","clientHandle","samplingInterval","queueSize","discardOldest","SubscriptionService","TimestampsToReturn","Both","dataValue","StatusCodes","Good","done","value","nodeClass","references","mtime","serverTimestamp","Error","_transform","desc","enc","callback","NodeClass","Variable","_enqueueChunk","_flush","Watcher","Emitter","nodes","ProjectConfig","nodesToWatch","_nodeStream","NodeStream","_subscribeStream","pipe","event","close","Session","catch"],"mappings":"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","sourcesContent":["/* eslint-plugin-jsdoc does not recognize the \"emits\" tag */\n/* eslint-disable jsdoc/check-tag-names */\n\n/* Needed as long as https://github.com/gajus/eslint-plugin-jsdoc/issues/56 is open */\n/* eslint-disable jsdoc/check-param-names */\n\nimport Emitter from 'events';\nimport { ClientSubscription } from 'node-opcua/lib/client/client_subscription';\nimport { AttributeIds } from 'node-opcua/lib/services/read_service';\nimport SubscriptionService from 'node-opcua/lib/services/subscription_service';\nimport { StatusCodes } from 'node-opcua/lib/datamodel/opcua_status_code';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport NodeStream from './NodeStream';\nimport QueueStream from './QueueStream';\nimport Session from './Session';\n\n/**\n * A stream that monitors changes in the read nodes.\n */\nexport class SubscribeStream extends QueueStream {\n\n  /**\n   * Creates a new SubscribeStream based on some options.\n   * @param {Object} options The stream options to apply.\n   */\n  constructor(options = {}) {\n    super(Object.assign(options, { keepSessionAlive: true })); // FIXME: Option not handled.\n\n    /**\n     * Set to true once all nodes are monitored.\n     * @type {Boolean}\n     */\n    this._trackChanges = false;\n\n    this.once('session-open', () => this.createSubscription());\n  }\n\n  /**\n   * Creates the server subscription to monitor nodes with.\n   * @emit {node-opcua~ClientSubscription} Emits a `subscription-started` event once the\n   * subscription started.\n   */\n  createSubscription() {\n    const subscription = new ClientSubscription(this.session, {\n      requestedPublishingInterval: 100,\n      requestedLifetimeCount: 1000,\n      requestedMaxKeepAliveCount: 12,\n      maxNotificationsPerPublish: 10,\n      publishingEnabled: true,\n      priority: 10,\n    });\n\n    subscription.on('started', () => {\n      /**\n       * The {@link node-opcua~ClientSubscription} to use to monitor nodes.\n       * @type {node-opcua~ClientSubscription}\n       */\n      this.subscription = subscription;\n      this.emit('subscription-started', subscription);\n    });\n\n    subscription.on('failure', err => this.emit('error', err));\n  }\n\n  /**\n   * Returns an error message specifically for the given reference description.\n   * @param {node-opcua~ReferenceDescription} referenceDescription The reference description to get\n   * the error message for.\n   * @return {string} The specific error message.\n   */\n  processErrorMessage(referenceDescription) {\n    return `Error reading node ${referenceDescription.nodeId.toString()}`;\n  }\n\n  /**\n   * Monitors the nodes specified by a {@link node-opcua~ReferenceDescription}.\n   * @param {node-opcua~ReferenceDescription} referenceDescription The refernce description to use.\n   * @param {function(err: Error, statusCode: node-opcua~StatusCodes, onSuccess: function)}\n   * handleErrors The error handler to call. See {@link QueueStream#processChunk} for details.\n   */\n  processChunk(referenceDescription, handleErrors) {\n    const nodeId = referenceDescription.id;\n\n    const item = this.subscription.monitor({\n      nodeId,\n      attributeId: AttributeIds.Value,\n    }, {\n      clientHandle: 13,\n      samplingInterval: 250,\n      queueSize: 1,\n      discardOldest: true,\n    }, SubscriptionService.TimestampsToReturn.Both);\n\n    item.on('changed', dataValue => {\n      if (!this._trackChanges) {\n        handleErrors(null, StatusCodes.Good, done => done()); // Ignore first notification\n      } else {\n        this.emit(dataValue.value ? 'change' : 'delete', {\n          nodeClass: referenceDescription.nodeClass,\n          nodeId,\n          value: dataValue.value,\n          references: referenceDescription.references,\n          mtime: dataValue.serverTimestamp,\n        });\n      }\n    });\n\n    item.on('err', err => {\n      /*\n       This works around a bug in node-opcua:\n       Instead of a error a string is emitted\n       FIXME: Remove once bug is fixed\n       */\n      if (err instanceof Error) {\n        handleErrors(err);\n      } else {\n        handleErrors(new Error(err));\n      }\n    });\n  }\n\n  /**\n   * Buffers all read node descriptions until the subscription started, then calls\n   * {@link QueueStream#_enqueueChunk} with them.\n   * @param {node-opcua~ReferenceDescription} desc Reference description of the node to transform.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error)} callback Called with the error that occured while trying to\n   * monitor the given node.\n   */\n  _transform(desc, enc, callback) {\n    if (desc.nodeClass !== NodeClass.Variable) {\n      callback();\n      return;\n    }\n\n    if (this.subscription) {\n      this._enqueueChunk(desc);\n      callback();\n    } else {\n      this.once('subscription-started', () => {\n        this._enqueueChunk(desc);\n        callback();\n      });\n    }\n  }\n\n  /**\n   * Starts tracking node changes.\n   * @param {function(err: ?Error)} callback Called once flushing is complete.\n   */\n  _flush(callback) {\n    super._flush(err => {\n      this._trackChanges = true;\n      callback(err);\n    });\n  }\n\n}\n\n/**\n * Watches the given nodes for value changes.\n * @emit {ReadStream.ReadResult} Emits `change` events when a watched node changes.\n */\nexport default class Watcher extends Emitter {\n\n  /**\n   * Creates a new Watcher with the given nodes.\n   * @param {NodeId[]} nodes The nodes to watch (recursively).\n   */\n  constructor(nodes = ProjectConfig.nodesToWatch) {\n    super();\n\n    /**\n     * The node stream that discovers the nodes to watch.\n     * @type {NodeStream}\n     */\n    this._nodeStream = new NodeStream(nodes)\n      .on('error', err => this.emit('error', err));\n\n    /**\n     * The stream that starts monitoring the nodes to watch.\n     * @type {SubscribeStream}\n     */\n    this._subscribeStream = new SubscribeStream()\n      .on('error', err => this.emit('error', err));\n\n    this._nodeStream.pipe(this._subscribeStream);\n\n    // \"pipe\" subscribe stream\n    this._subscribeStream.on('data', () => {});\n    this._subscribeStream.on('end', () => this.emit('ready'));\n\n    this._subscribeStream.on('change', event => this.emit('change', event));\n    this._subscribeStream.on('delete', event => this.emit('delete', event));\n  }\n\n  /**\n   * Ends monitoring nodes.\n   */\n  close() {\n    if (this._subscribeStream.session) {\n      Session.close(this._subscribeStream.session)\n        .catch(err => this.emit('error', err));\n    }\n  }\n\n}\n"],"file":"Watcher.js"}