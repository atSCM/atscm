{"version":3,"sources":["../../../src/lib/server/Watcher.js"],"names":["SubscribeStream","constructor","options","Object","assign","keepSessionAlive","_trackChanges","once","createSubscription","subscription","session","requestedPublishingInterval","requestedLifetimeCount","requestedMaxKeepAliveCount","maxNotificationsPerPublish","publishingEnabled","priority","on","emit","err","processErrorMessage","referenceDescription","nodeId","toString","processChunk","handleErrors","item","monitor","attributeId","Value","clientHandle","samplingInterval","queueSize","discardOldest","TimestampsToReturn","Both","dataValue","Good","done","nodeClass","value","references","mtime","serverTimestamp","Error","_transform","desc","enc","callback","Variable","_enqueueChunk","_flush","Watcher","nodes","nodesToWatch","_nodeStream","_subscribeStream","pipe","event","close","catch"],"mappings":"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","file":"Watcher.js","sourcesContent":["/* eslint-plugin-jsdoc does not recognize the \"emits\" tag */\n/* eslint-disable jsdoc/check-tag-names */\n\n/* Needed as long as https://github.com/gajus/eslint-plugin-jsdoc/issues/56 is open */\n/* eslint-disable jsdoc/check-param-names */\n\nimport Emitter from 'events';\nimport {\n  ClientSubscription,\n  AttributeIds,\n  subscription_service as SubscriptionService,\n  StatusCodes,\n  NodeClass,\n} from 'node-opcua';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport NodeStream from './NodeStream';\nimport QueueStream from './QueueStream';\nimport Session from './Session';\n\n/**\n * A stream that monitors changes in the read nodes.\n */\nexport class SubscribeStream extends QueueStream {\n\n  /**\n   * Creates a new SubscribeStream based on some options.\n   * @param {Object} options The stream options to apply.\n   */\n  constructor(options = {}) {\n    super(Object.assign(options, { keepSessionAlive: true })); // FIXME: Option not handled.\n\n    /**\n     * Set to true once all nodes are monitored.\n     * @type {Boolean}\n     */\n    this._trackChanges = false;\n\n    this.once('session-open', () => this.createSubscription());\n  }\n\n  /**\n   * Creates the server subscription to monitor nodes with.\n   * @emit {node-opcua~ClientSubscription} Emits a `subscription-started` event once the\n   * subscription started.\n   */\n  createSubscription() {\n    const subscription = new ClientSubscription(this.session, {\n      requestedPublishingInterval: 100,\n      requestedLifetimeCount: 1000,\n      requestedMaxKeepAliveCount: 12,\n      maxNotificationsPerPublish: 10,\n      publishingEnabled: true,\n      priority: 10,\n    });\n\n    subscription.on('started', () => {\n      /**\n       * The {@link node-opcua~ClientSubscription} to use to monitor nodes.\n       * @type {node-opcua~ClientSubscription}\n       */\n      this.subscription = subscription;\n      this.emit('subscription-started', subscription);\n    });\n\n    subscription.on('failure', err => this.emit('error', err));\n  }\n\n  /**\n   * Returns an error message specifically for the given reference description.\n   * @param {node-opcua~ReferenceDescription} referenceDescription The reference description to get\n   * the error message for.\n   * @return {string} The specific error message.\n   */\n  processErrorMessage(referenceDescription) {\n    return `Error reading node ${referenceDescription.nodeId.toString()}`;\n  }\n\n  /**\n   * Monitors the nodes specified by a {@link node-opcua~ReferenceDescription}.\n   * @param {node-opcua~ReferenceDescription} referenceDescription The refernce description to use.\n   * @param {function(err: Error, statusCode: node-opcua~StatusCodes, onSuccess: function)}\n   * handleErrors The error handler to call. See {@link QueueStream#processChunk} for details.\n   */\n  processChunk(referenceDescription, handleErrors) {\n    const nodeId = referenceDescription.nodeId;\n\n    const item = this.subscription.monitor({\n      nodeId,\n      attributeId: AttributeIds.Value,\n    }, {\n      clientHandle: 13,\n      samplingInterval: 250,\n      queueSize: 1,\n      discardOldest: true,\n    }, SubscriptionService.TimestampsToReturn.Both);\n\n    item.on('changed', dataValue => {\n      if (!this._trackChanges) {\n        handleErrors(null, StatusCodes.Good, done => done()); // Ignore first notification\n      } else {\n        this.emit('change', {\n          nodeClass: referenceDescription.nodeClass,\n          nodeId,\n          value: dataValue.value,\n          references: referenceDescription.references,\n          mtime: dataValue.serverTimestamp,\n        });\n      }\n    });\n\n    item.on('err', err => {\n      /*\n       This works around a bug in node-opcua:\n       Instead of a error a string is emitted\n       FIXME: Remove once bug is fixed\n       */\n      if (err instanceof Error) {\n        handleErrors(err);\n      } else {\n        handleErrors(new Error(err));\n      }\n    });\n  }\n\n  /**\n   * Buffers all read node descriptions until the subscription started, then calls\n   * {@link QueueStream#_enqueueChunk} with them.\n   * @param {node-opcua~ReferenceDescription} desc Reference description of the node to transform.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error)} callback Called with the error that occured while trying to\n   * monitor the given node.\n   */\n  _transform(desc, enc, callback) {\n    if (desc.nodeClass !== NodeClass.Variable) {\n      callback();\n      return;\n    }\n\n    if (this.subscription) {\n      this._enqueueChunk(desc);\n      callback();\n    } else {\n      this.once('subscription-started', () => {\n        this._enqueueChunk(desc);\n        callback();\n      });\n    }\n  }\n\n  /**\n   * Starts tracking node changes.\n   * @param {function(err: ?Error)} callback Called once flushing is complete.\n   */\n  _flush(callback) {\n    super._flush(err => {\n      this._trackChanges = true;\n      callback(err);\n    });\n  }\n\n}\n\n/**\n * Watches the given nodes for value changes.\n * @emit {ReadStream.ReadResult} Emits `change` events when a watched node changes.\n */\nexport default class Watcher extends Emitter {\n\n  /**\n   * Creates a new Watcher with the given nodes.\n   * @param {NodeId[]} nodes The nodes to watch (recursively).\n   */\n  constructor(nodes = ProjectConfig.nodesToWatch) {\n    super();\n\n    /**\n     * The node stream that discovers the nodes to watch.\n     * @type {NodeStream}\n     */\n    this._nodeStream = new NodeStream(nodes)\n      .on('error', err => this.emit('error', err));\n\n    /**\n     * The stream that starts monitoring the nodes to watch.\n     * @type {SubscribeStream}\n     */\n    this._subscribeStream = new SubscribeStream()\n      .on('error', err => this.emit('error', err));\n\n    this._nodeStream.pipe(this._subscribeStream);\n\n    this._subscribeStream.on('finish', () => this.emit('ready'));\n    this._subscribeStream.on('change', event => this.emit('change', event));\n  }\n\n  /**\n   * Ends monitoring nodes.\n   */\n  close() {\n    if (this._subscribeStream.session) {\n      Session.close(this._subscribeStream.session)\n        .catch(err => this.emit('error', err));\n    }\n  }\n\n}\n"]}