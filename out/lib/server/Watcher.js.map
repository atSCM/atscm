{"version":3,"sources":["../../../src/lib/server/Watcher.js"],"names":["SubscribeStream","constructor","options","Object","assign","keepSessionAlive","_trackChanges","once","createSubscription","subscription","session","requestedPublishingInterval","requestedLifetimeCount","requestedMaxKeepAliveCount","maxNotificationsPerPublish","publishingEnabled","priority","on","emit","err","processErrorMessage","referenceDescription","nodeId","toString","processChunk","handleErrors","id","item","monitor","attributeId","Value","clientHandle","samplingInterval","queueSize","discardOldest","TimestampsToReturn","Both","dataValue","Good","done","value","nodeClass","references","mtime","serverTimestamp","Error","_transform","desc","enc","callback","Variable","_enqueueChunk","_flush","Watcher","nodes","nodesToWatch","_nodeStream","_subscribeStream","pipe","event","close","catch"],"mappings":"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","file":"Watcher.js","sourcesContent":["/* eslint-plugin-jsdoc does not recognize the \"emits\" tag */\n/* eslint-disable jsdoc/check-tag-names */\n\n/* Needed as long as https://github.com/gajus/eslint-plugin-jsdoc/issues/56 is open */\n/* eslint-disable jsdoc/check-param-names */\n\nimport Emitter from 'events';\nimport { ClientSubscription } from 'node-opcua/lib/client/client_subscription';\nimport { AttributeIds } from 'node-opcua/lib/services/read_service';\nimport SubscriptionService from 'node-opcua/lib/services/subscription_service';\nimport { StatusCodes } from 'node-opcua/lib/datamodel/opcua_status_code';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport NodeStream from './NodeStream';\nimport QueueStream from './QueueStream';\nimport Session from './Session';\n\n/**\n * A stream that monitors changes in the read nodes.\n */\nexport class SubscribeStream extends QueueStream {\n\n  /**\n   * Creates a new SubscribeStream based on some options.\n   * @param {Object} options The stream options to apply.\n   */\n  constructor(options = {}) {\n    super(Object.assign(options, { keepSessionAlive: true })); // FIXME: Option not handled.\n\n    /**\n     * Set to true once all nodes are monitored.\n     * @type {Boolean}\n     */\n    this._trackChanges = false;\n\n    this.once('session-open', () => this.createSubscription());\n  }\n\n  /**\n   * Creates the server subscription to monitor nodes with.\n   * @emit {node-opcua~ClientSubscription} Emits a `subscription-started` event once the\n   * subscription started.\n   */\n  createSubscription() {\n    const subscription = new ClientSubscription(this.session, {\n      requestedPublishingInterval: 100,\n      requestedLifetimeCount: 1000,\n      requestedMaxKeepAliveCount: 12,\n      maxNotificationsPerPublish: 10,\n      publishingEnabled: true,\n      priority: 10,\n    });\n\n    subscription.on('started', () => {\n      /**\n       * The {@link node-opcua~ClientSubscription} to use to monitor nodes.\n       * @type {node-opcua~ClientSubscription}\n       */\n      this.subscription = subscription;\n      this.emit('subscription-started', subscription);\n    });\n\n    subscription.on('failure', err => this.emit('error', err));\n  }\n\n  /**\n   * Returns an error message specifically for the given reference description.\n   * @param {node-opcua~ReferenceDescription} referenceDescription The reference description to get\n   * the error message for.\n   * @return {string} The specific error message.\n   */\n  processErrorMessage(referenceDescription) {\n    return `Error reading node ${referenceDescription.nodeId.toString()}`;\n  }\n\n  /**\n   * Monitors the nodes specified by a {@link node-opcua~ReferenceDescription}.\n   * @param {node-opcua~ReferenceDescription} referenceDescription The refernce description to use.\n   * @param {function(err: Error, statusCode: node-opcua~StatusCodes, onSuccess: function)}\n   * handleErrors The error handler to call. See {@link QueueStream#processChunk} for details.\n   */\n  processChunk(referenceDescription, handleErrors) {\n    const nodeId = referenceDescription.id;\n\n    const item = this.subscription.monitor({\n      nodeId,\n      attributeId: AttributeIds.Value,\n    }, {\n      clientHandle: 13,\n      samplingInterval: 250,\n      queueSize: 1,\n      discardOldest: true,\n    }, SubscriptionService.TimestampsToReturn.Both);\n\n    item.on('changed', dataValue => {\n      if (!this._trackChanges) {\n        handleErrors(null, StatusCodes.Good, done => done()); // Ignore first notification\n      } else {\n        this.emit(dataValue.value ? 'change' : 'delete', {\n          nodeClass: referenceDescription.nodeClass,\n          nodeId,\n          value: dataValue.value,\n          references: referenceDescription.references,\n          mtime: dataValue.serverTimestamp,\n        });\n      }\n    });\n\n    item.on('err', err => {\n      /*\n       This works around a bug in node-opcua:\n       Instead of a error a string is emitted\n       FIXME: Remove once bug is fixed\n       */\n      if (err instanceof Error) {\n        handleErrors(err);\n      } else {\n        handleErrors(new Error(err));\n      }\n    });\n  }\n\n  /**\n   * Buffers all read node descriptions until the subscription started, then calls\n   * {@link QueueStream#_enqueueChunk} with them.\n   * @param {node-opcua~ReferenceDescription} desc Reference description of the node to transform.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error)} callback Called with the error that occured while trying to\n   * monitor the given node.\n   */\n  _transform(desc, enc, callback) {\n    if (desc.nodeClass !== NodeClass.Variable) {\n      callback();\n      return;\n    }\n\n    if (this.subscription) {\n      this._enqueueChunk(desc);\n      callback();\n    } else {\n      this.once('subscription-started', () => {\n        this._enqueueChunk(desc);\n        callback();\n      });\n    }\n  }\n\n  /**\n   * Starts tracking node changes.\n   * @param {function(err: ?Error)} callback Called once flushing is complete.\n   */\n  _flush(callback) {\n    super._flush(err => {\n      this._trackChanges = true;\n      callback(err);\n    });\n  }\n\n}\n\n/**\n * Watches the given nodes for value changes.\n * @emit {ReadStream.ReadResult} Emits `change` events when a watched node changes.\n */\nexport default class Watcher extends Emitter {\n\n  /**\n   * Creates a new Watcher with the given nodes.\n   * @param {NodeId[]} nodes The nodes to watch (recursively).\n   */\n  constructor(nodes = ProjectConfig.nodesToWatch) {\n    super();\n\n    /**\n     * The node stream that discovers the nodes to watch.\n     * @type {NodeStream}\n     */\n    this._nodeStream = new NodeStream(nodes)\n      .on('error', err => this.emit('error', err));\n\n    /**\n     * The stream that starts monitoring the nodes to watch.\n     * @type {SubscribeStream}\n     */\n    this._subscribeStream = new SubscribeStream()\n      .on('error', err => this.emit('error', err));\n\n    this._nodeStream.pipe(this._subscribeStream);\n\n    // \"pipe\" subscribe stream\n    this._subscribeStream.on('data', () => {});\n    this._subscribeStream.on('end', () => this.emit('ready'));\n\n    this._subscribeStream.on('change', event => this.emit('change', event));\n    this._subscribeStream.on('delete', event => this.emit('delete', event));\n  }\n\n  /**\n   * Ends monitoring nodes.\n   */\n  close() {\n    if (this._subscribeStream.session) {\n      Session.close(this._subscribeStream.session)\n        .catch(err => this.emit('error', err));\n    }\n  }\n\n}\n"]}