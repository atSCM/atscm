{"version":3,"sources":["../../../src/lib/watch/Watcher.js"],"names":["SubscribeStream","constructor","options","Object","assign","keepSessionAlive","_trackChanges","once","createSubscription","subscription","session","requestedPublishingInterval","requestedLifetimeCount","requestedMaxKeepAliveCount","maxNotificationsPerPublish","publishingEnabled","priority","on","emit","err","processErrorMessage","mappingItem","sourceNodeId","toString","processChunk","handleErrors","nodeId","shouldBeRead","Good","done","item","monitor","attributeId","Value","clientHandle","samplingInterval","queueSize","discardOldest","TimestampsToReturn","Both","dataValue","createConfigItemFromDataValue","Error","_transform","desc","enc","callback","_enqueueChunk","_flush","Watcher","nodes","_browseStream","_subscribeStream","pipe","event","close","catch"],"mappings":"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","file":"Watcher.js","sourcesContent":["/* eslint-plugin-jsdoc does not recognize the \"emits\" tag */\n/* eslint-disable jsdoc/check-tag-names */\n\n/* Needed as long as https://github.com/gajus/eslint-plugin-jsdoc/issues/56 is open */\n/* eslint-disable jsdoc/check-param-names */\n\nimport Emitter from 'events';\nimport {\n  ClientSubscription,\n  AttributeIds,\n  subscription_service as SubscriptionService,\n  StatusCodes,\n} from 'node-opcua';\nimport ProjectConfig from '../../config/ProjectConfig';\nimport BrowseStream from '../pull/BrowseStream';\nimport QueueStream from '../stream/QueueStream';\nimport { Session } from '../ua/Session';\n\n/**\n * A stream that monitors changes in the read nodes.\n */\nexport class SubscribeStream extends QueueStream {\n\n  /**\n   * Creates a new SubscribeStream based on some options.\n   * @param {Object} options The stream options to apply.\n   */\n  constructor(options = {}) {\n    super(Object.assign(options, { keepSessionAlive: true })); // FIXME: Option not handled.\n\n    /**\n     * Set to true once all nodes are monitored.\n     * @type {Boolean}\n     */\n    this._trackChanges = false;\n\n    this.once('session-open', () => this.createSubscription());\n  }\n\n  /**\n   * Creates the server subscription to monitor nodes with.\n   * @emit {node-opcua~ClientSubscription} Emits a `subscription-started` event once the\n   * subscription started.\n   */\n  createSubscription() {\n    const subscription = new ClientSubscription(this.session, {\n      requestedPublishingInterval: 100,\n      requestedLifetimeCount: 1000,\n      requestedMaxKeepAliveCount: 12,\n      maxNotificationsPerPublish: 10,\n      publishingEnabled: true,\n      priority: 10,\n    });\n\n    subscription.on('started', () => {\n      /**\n       * The {@link node-opcua~ClientSubscription} to use to monitor nodes.\n       * @type {node-opcua~ClientSubscription}\n       */\n      this.subscription = subscription;\n      this.emit('subscription-started', subscription);\n    });\n\n    subscription.on('failure', err => this.emit('error', err));\n  }\n\n  /**\n   * Returns an error message specifically for the given reference description.\n   * @param {MappingItem} mappingItem The mappingItem to process\n   * the error message for.\n   * @return {string} The specific error message.\n   */\n  processErrorMessage(mappingItem) {\n    return `Error reading node ${mappingItem.sourceNodeId.toString()}`;\n  }\n\n  /**\n   * Monitors the nodes specified by the given {MappingItem}s.\n   * @param {MappingItem} mappingItem The mappingItem to process\n   * @param {function(err: Error, statusCode: node-opcua~StatusCodes, onSuccess: function)}\n   * handleErrors The error handler to call. See {@link QueueStream#processChunk} for details.\n   */\n  processChunk(mappingItem, handleErrors) {\n    const nodeId = mappingItem.nodeId;\n\n    if (!mappingItem.shouldBeRead) {\n      handleErrors(null, StatusCodes.Good, done => done());\n      return;\n    }\n\n    const item = this.subscription.monitor({\n      nodeId,\n      attributeId: AttributeIds.Value,\n    }, {\n      clientHandle: 13,\n      samplingInterval: 250,\n      queueSize: 1,\n      discardOldest: true,\n    }, SubscriptionService.TimestampsToReturn.Both);\n\n    item.on('changed', dataValue => {\n      if (!this._trackChanges) {\n        handleErrors(null, StatusCodes.Good, done => done()); // Ignore first notification\n      } else {\n        mappingItem.createConfigItemFromDataValue(dataValue);\n        this.emit('change', mappingItem);\n      }\n    });\n\n    item.on('err', err => {\n      /*\n       This works around a bug in node-opcua:\n       Instead of a error a string is emitted\n       FIXME: Remove once bug is fixed\n       */\n      if (err instanceof Error) {\n        handleErrors(err);\n      } else {\n        handleErrors(new Error(err));\n      }\n    });\n  }\n\n  /**\n   * Buffers all read node descriptions until the subscription started, then calls\n   * {@link QueueStream#_enqueueChunk} with them.\n   * @param {node-opcua~ReferenceDescription} desc Reference description of the node to transform.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error)} callback Called with the error that occured while trying to\n   * monitor the given node.\n   */\n  _transform(desc, enc, callback) {\n    if (this.subscription) {\n      this._enqueueChunk(desc);\n      callback();\n    } else {\n      this.once('subscription-started', () => {\n        this._enqueueChunk(desc);\n        callback();\n      });\n    }\n  }\n\n  /**\n   * Starts tracking node changes.\n   * @param {function(err: ?Error)} callback Called once flushing is complete.\n   */\n  _flush(callback) {\n    super._flush(err => {\n      this._trackChanges = true;\n      callback(err);\n    });\n  }\n\n}\n\n/**\n * Watches the given nodes for value changes.\n * @emit {ReadStream.ReadResult} Emits `change` events when a watched node changes.\n */\nexport default class Watcher extends Emitter {\n\n  /**\n   * Creates a new Watcher with the given nodes.\n   * @param {NodeId[]} nodes The nodes to watch (recursively).\n   */\n  constructor(nodes = ProjectConfig.nodes) {\n    super();\n\n    /**\n     * The browse stream that discovers the nodes to watch.\n     * @type {BrowseStream}\n     */\n    this._browseStream = new BrowseStream(nodes)\n      .on('error', err => this.emit('error', err));\n\n    /**\n     * The stream that starts monitoring the nodes to watch.\n     * @type {SubscribeStream}\n     */\n    this._subscribeStream = new SubscribeStream()\n      .on('error', err => this.emit('error', err));\n\n    this._browseStream.pipe(this._subscribeStream);\n\n    this._subscribeStream.on('finish', () => this.emit('ready'));\n    this._subscribeStream.on('change', event => this.emit('change', event));\n  }\n\n  /**\n   * Ends monitoring nodes.\n   */\n  close() {\n    if (this._subscribeStream.session) {\n      Session.close(this._subscribeStream.session)\n        .catch(err => this.emit('error', err));\n    }\n  }\n\n}\n"]}