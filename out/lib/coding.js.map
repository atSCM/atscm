{"version":3,"sources":["../../src/lib/coding.js"],"names":["encodeVariant","decodeVariant","asIs","b","mapPropertyAs","map","obj","key","dataType","Object","assign","toRawValue","Null","StatusCode","name","QualifiedName","namespaceIndex","LocalizedText","text","locale","DataValue","value","options","Variant","arrayType","dimensions","getRawValue","DiagnosticInfo","info","Scalar","Array","isArray","from","val","Buffer","rawValue","stringify","a","toJSON","JSON","stringified","toString","trim","decodeAsString","decodeAsInt","parseInt","decodeAsFloat","parseFloat","decodeAsJson","parse","decodeRawValue","Boolean","SByte","Byte","Int16","UInt16","Int32","UInt32","Int64","UInt64","Float","Double","String","DateTime","Guid","XmlElement","NodeId","ExpandedNodeId","toNodeValue","s","Date","ByteString","data","nodeId","defs","split","identifierType","namespace","namespaceUri","serverIndex","reduce","opts","def","match","slice","getNodeValue","Error","raw","buffer","length"],"mappings":"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","file":"coding.js","sourcesContent":["import { DataType, VariantArrayType, Variant } from 'node-opcua/lib/datamodel/variant';\nimport { resolveNodeId } from 'node-opcua/lib/datamodel/nodeid';\nimport { LocalizedText } from 'node-opcua/lib/datamodel/localized_text';\nimport { StatusCodes } from 'node-opcua/lib/datamodel/opcua_status_code';\nimport { QualifiedName } from 'node-opcua/lib/datamodel/qualified_name';\nimport { DataValue } from 'node-opcua/lib/datamodel/datavalue';\nimport { ExpandedNodeId } from 'node-opcua/lib/datamodel/expanded_nodeid';\nimport { DiagnosticInfo } from 'node-opcua/lib/datamodel/diagnostic_info';\nimport { pick } from './helpers/Object';\n\n/**\n * Function that returns the passed argument as is.\n * @param {*} b The input argument.\n * @return {*} The value passed.\n */\nconst asIs = b => b;\n\n/**\n * Maps a single property of an object using the the mapper defined in *map* for the given\n * *dataType*.\n * @param {Map<node-opcua~DataType, function} map The mappings to use.\n * @param {Object} obj The object to process.\n * @param {string} key Name of the property to map.\n * @param {node-opcua~DataType} dataType The data type to map the property to.\n */\nconst mapPropertyAs = (map, obj, key, dataType) => {\n  if (obj[key]) {\n    return Object.assign(obj, {\n      [key]: map[dataType](obj[key]),\n    });\n  }\n\n  return obj;\n};\n\n/**\n * A set of functions that return raw values from {@link node-opcua~Variant} for specific\n * {@link node-opcua~DataType}s.\n * @type {Map<node-opcua~DataType, function(value: any): any>}\n */\nconst toRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.StatusCode]: ({ name }) => name,\n  [DataType.QualifiedName]: ({ namespaceIndex, name }) => ({ namespaceIndex, name }),\n  [DataType.LocalizedText]: ({ text, locale }) => ({ text, locale }),\n  [DataType.DataValue]: value => {\n    const options = pick(value, ['value', 'statusCode', 'sourceTimestamp', 'sourcePicoseconds',\n      'serverTimestamp', 'serverPicoseconds']);\n\n    mapPropertyAs(toRawValue, options, 'value', DataType.Variant);\n    mapPropertyAs(toRawValue, options, 'statusCode', DataType.StatusCode);\n    // NOTE: server- and sourceTimstamps get mapped as dates\n\n    return options;\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => ({\n    dataType,\n    arrayType,\n    value: getRawValue({ value, dataType, arrayType }), // eslint-disable-line no-use-before-define\n    dimensions,\n  }),\n  [DataType.DiagnosticInfo]: info => {\n    const options = pick(info, ['namespaceUri', 'symbolicId', 'locale', 'localizedText',\n      'additionalInfo', 'innerStatusCode', 'innerDiagnosticInfo']);\n\n    mapPropertyAs(toRawValue, options, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toRawValue, options, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n    return options;\n  },\n};\n\n/**\n * Returns the raw value for a {@link node-opcua~Variant}.\n * @param {node-opcua~Variant} variant The variant to convert.\n */\nfunction getRawValue({ value, dataType, arrayType }) {\n  if (arrayType !== VariantArrayType.Scalar) {\n    return (Array.isArray(value) ? value : Array.from(value))\n      .map(val => getRawValue({\n        value: val,\n        dataType,\n        arrayType: VariantArrayType[arrayType.value - 1],\n      }));\n  }\n\n  return (toRawValue[dataType] || asIs)(value);\n}\n\n/**\n * Returns a buffer containing a {@link node-opcua~Variant}s encoded value.\n * @param {node-opcua~Variant} variant The variant to encode.\n * @return {Buffer} A buffer containing the encoded value.\n */\nexport function encodeVariant({ value, dataType, arrayType }) {\n  if (value === null) { return Buffer.from([]); }\n\n  const rawValue = getRawValue({ value, dataType, arrayType });\n\n  if (rawValue instanceof Buffer) {\n    return rawValue;\n  }\n\n  const stringify = a => (a.toJSON ? a.toJSON() : JSON.stringify(a, null, '  '));\n\n  const stringified = (typeof rawValue === 'object') ?\n    stringify(rawValue) :\n    rawValue.toString().trim();\n\n  return Buffer.from(stringified);\n}\n\n/**\n * Decodes a buffer to a string.\n * @param {Buffer} b The buffer to decode from.\n * @return {string} The buffer's string representation.\n */\nconst decodeAsString = b => b.toString().trim();\n\n/**\n * Decodes a buffer to an integer value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded integer.\n */\nconst decodeAsInt = b => parseInt(decodeAsString(b), 10);\n\n/**\n * Decodes a buffer to a float value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded float.\n */\nconst decodeAsFloat = b => parseFloat(decodeAsString(b));\n\n/**\n * Decodes a buffer using JSON.\n * @param {Buffer} b The buffer to decode from.\n * @return {*} The decoded value, most likely an Object.\n */\nconst decodeAsJson = b => JSON.parse(b.toString());\n\n/**\n * Mapping functions that return raw values for a stored value of the given type.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst decodeRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.Boolean]: b => decodeAsString(b) === 'true',\n  [DataType.SByte]: decodeAsInt,\n  [DataType.Byte]: decodeAsInt,\n  [DataType.Int16]: decodeAsInt,\n  [DataType.UInt16]: decodeAsInt,\n  [DataType.Int32]: decodeAsInt,\n  [DataType.UInt32]: decodeAsInt,\n  [DataType.Int64]: decodeAsJson,\n  [DataType.UInt64]: decodeAsJson,\n  [DataType.Float]: decodeAsFloat,\n  [DataType.Double]: decodeAsFloat,\n  [DataType.String]: decodeAsString,\n  [DataType.DateTime]: decodeAsString,\n  [DataType.Guid]: decodeAsString,\n  // ByteString maps to Buffer\n  [DataType.XmlElement]: decodeAsString,\n  [DataType.NodeId]: decodeAsString,\n  [DataType.ExpandedNodeId]: decodeAsString,\n  [DataType.StatusCode]: decodeAsString,\n  [DataType.QualifiedName]: decodeAsJson,\n  [DataType.LocalizedText]: decodeAsJson,\n  // FIXME: Add ExtensionObject\n  [DataType.DataValue]: decodeAsJson,\n  [DataType.Variant]: decodeAsJson,\n  [DataType.DiagnosticInfo]: decodeAsJson,\n};\n\n/**\n * Mapping functions that return OPC-UA node values for raw values.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst toNodeValue = {\n  [DataType.DateTime]: s => new Date(s),\n  [DataType.ByteString]: b => {\n    if (b instanceof Buffer) { return b; }\n\n    return Buffer.from(b.data, 'binary');\n  },\n  [DataType.NodeId]: s => resolveNodeId(s),\n\n  // Jep, node-opcua does not provide a resolve function for expanded nodeids\n  [DataType.ExpandedNodeId]: s => {\n    const nodeId = resolveNodeId(s);\n    const [value, ...defs] = nodeId.value.split(';');\n\n    const { identifierType, namespace, namespaceUri, serverIndex } = defs.reduce((opts, def) => {\n      const match = def.match(/^([^:]+):(.*)/);\n      if (!match) { return opts; }\n\n      let [key, val] = match.slice(1); // eslint-disable-line prefer-const\n\n      if (key === 'serverIndex') {\n        val = parseInt(val, 10);\n      }\n\n      return Object.assign(opts, { [key]: val });\n    }, Object.assign({}, nodeId));\n\n    return new ExpandedNodeId(identifierType, value, namespace, namespaceUri, serverIndex);\n  },\n\n  [DataType.StatusCode]: name => StatusCodes[name],\n  [DataType.QualifiedName]: options => new QualifiedName(options),\n  [DataType.LocalizedText]: options => new LocalizedText(options),\n  [DataType.DataValue]: options => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'value', DataType.Variant);\n    mapPropertyAs(toNodeValue, opts, 'statusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'sourceTimestamp', DataType.DateTime);\n    mapPropertyAs(toNodeValue, opts, 'serverTimestamp', DataType.DateTime);\n\n    return new DataValue(opts);\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => new Variant({\n    dataType,\n    arrayType: VariantArrayType[arrayType],\n    value,\n    dimensions,\n  }),\n  [DataType.DiagnosticInfo]: options => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n    return new DiagnosticInfo(opts);\n  },\n};\n\n/**\n * Returns a node's OPC-UA value based on it's raw value and type.\n * @param {*} rawValue A node's raw value.\n * @param {node-opcua~DataType} dataType A node's data type.\n * @param {node-opcua~VariantArrayType} arrayType A node's array type.\n */\nconst getNodeValue = (rawValue, dataType, arrayType) => {\n  if (arrayType.value !== VariantArrayType.Scalar.value) {\n    if (!Array.isArray(rawValue)) {\n      throw new Error('Value is not an array');\n    }\n\n    return rawValue.map(raw => getNodeValue(raw, dataType, VariantArrayType[arrayType.value - 1]));\n  }\n\n  return (toNodeValue[dataType] || asIs)(rawValue);\n};\n\n/**\n * Returns a {@link node-opcua~Variant} from a Buffer with the given *dataType* and *arrayType*.\n * @param {Buffer} buffer The buffer to decode from.\n * @param {Object} options The options to use.\n * @param {node-opcua~DataType} options.dataType The data type to decode to.\n * @param {node-opcua~VariantArrayType} options.arrayType The array type to decode to.\n */\nexport function decodeVariant(buffer, { dataType, arrayType }) {\n  if (buffer === null || buffer.length === 0) {\n    return null;\n  }\n\n  if (dataType === DataType.ByteString && arrayType === VariantArrayType.Scalar) {\n    return buffer;\n  }\n\n  const rawValue = arrayType === VariantArrayType.Scalar ?\n    (decodeRawValue[dataType] || asIs)(buffer) :\n    JSON.parse(buffer.toString());\n\n  return getNodeValue(rawValue, dataType, arrayType);\n}\n"]}