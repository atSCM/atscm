{"version":3,"sources":["../../src/lib/coding.js"],"names":["asIs","b","mapPropertyAs","map","obj","key","dataType","Object","assign","toRawValue","DataType","Null","StatusCode","name","QualifiedName","namespaceIndex","LocalizedText","text","locale","DataValue","value","options","Variant","arrayType","dimensions","getRawValue","DiagnosticInfo","info","VariantArrayType","Scalar","Array","isArray","from","val","encodeVariant","Buffer","rawValue","stringify","a","toJSON","JSON","stringified","toString","trim","decodeAsString","decodeAsInt","parseInt","decodeAsFloat","parseFloat","decodeAsJson","parse","decodeRawValue","Boolean","SByte","Byte","Int16","UInt16","Int32","UInt32","Int64","UInt64","Float","Double","String","DateTime","Guid","XmlElement","NodeId","ExpandedNodeId","toNodeValue","s","Date","ByteString","data","nodeId","defs","split","identifierType","namespace","namespaceUri","serverIndex","reduce","opts","def","match","slice","StatusCodes","getNodeValue","Error","raw","decodeVariant","buffer","length"],"mappings":"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","sourcesContent":["import { DataType, VariantArrayType, Variant } from 'node-opcua/lib/datamodel/variant';\nimport { resolveNodeId } from 'node-opcua/lib/datamodel/nodeid';\nimport { LocalizedText } from 'node-opcua/lib/datamodel/localized_text';\nimport { StatusCodes } from 'node-opcua/lib/datamodel/opcua_status_code';\nimport { QualifiedName } from 'node-opcua/lib/datamodel/qualified_name';\nimport { DataValue } from 'node-opcua/lib/datamodel/datavalue';\nimport { ExpandedNodeId } from 'node-opcua/lib/datamodel/expanded_nodeid';\nimport { DiagnosticInfo } from 'node-opcua/lib/datamodel/diagnostic_info';\nimport { pick } from './helpers/Object';\n\n/**\n * Function that returns the passed argument as is.\n * @param {*} b The input argument.\n * @return {*} The value passed.\n */\nconst asIs = b => b;\n\n/**\n * Maps a single property of an object using the the mapper defined in *map* for the given\n * *dataType*.\n * @param {Map<node-opcua~DataType, function} map The mappings to use.\n * @param {Object} obj The object to process.\n * @param {string} key Name of the property to map.\n * @param {node-opcua~DataType} dataType The data type to map the property to.\n */\nconst mapPropertyAs = (map, obj, key, dataType) => {\n  if (obj[key]) {\n    return Object.assign(obj, {\n      [key]: map[dataType](obj[key]),\n    });\n  }\n\n  return obj;\n};\n\n/**\n * A set of functions that return raw values from {@link node-opcua~Variant} for specific\n * {@link node-opcua~DataType}s.\n * @type {Map<node-opcua~DataType, function(value: any): any>}\n */\nconst toRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.StatusCode]: ({ name }) => name,\n  [DataType.QualifiedName]: ({ namespaceIndex, name }) => ({ namespaceIndex, name }),\n  [DataType.LocalizedText]: ({ text, locale }) => ({ text: text || null, locale }),\n  [DataType.DataValue]: value => {\n    const options = pick(value, ['value', 'statusCode', 'sourceTimestamp', 'sourcePicoseconds',\n      'serverTimestamp', 'serverPicoseconds']);\n\n    mapPropertyAs(toRawValue, options, 'value', DataType.Variant);\n    mapPropertyAs(toRawValue, options, 'statusCode', DataType.StatusCode);\n    // NOTE: server- and sourceTimstamps get mapped as dates\n\n    return options;\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => ({\n    dataType,\n    arrayType,\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    value: getRawValue({ value, dataType, arrayType }),\n    dimensions,\n  }),\n  [DataType.DiagnosticInfo]: info => {\n    const options = pick(info, ['namespaceUri', 'symbolicId', 'locale', 'localizedText',\n      'additionalInfo', 'innerStatusCode', 'innerDiagnosticInfo']);\n\n    mapPropertyAs(toRawValue, options, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toRawValue, options, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n    return options;\n  },\n};\n\n/**\n * Returns the raw value for a {@link node-opcua~Variant}.\n * @param {node-opcua~Variant} variant The variant to convert.\n */\nfunction getRawValue({ value, dataType, arrayType }) {\n  if (arrayType !== VariantArrayType.Scalar) {\n    return (Array.isArray(value) ? value : Array.from(value))\n      .map(val => getRawValue({\n        value: val,\n        dataType,\n        arrayType: VariantArrayType[arrayType.value - 1],\n      }));\n  }\n\n  return (toRawValue[dataType] || asIs)(value);\n}\n\n/**\n * Returns a buffer containing a {@link node-opcua~Variant}s encoded value.\n * @param {node-opcua~Variant} variant The variant to encode.\n * @return {Buffer} A buffer containing the encoded value.\n */\nexport function encodeVariant({ value, dataType, arrayType }) {\n  if (value === null) { return Buffer.from([]); }\n\n  const rawValue = getRawValue({ value, dataType, arrayType });\n\n  if (rawValue instanceof Buffer) {\n    return rawValue;\n  }\n\n  const stringify = a => (a.toJSON ? a.toJSON() : JSON.stringify(a, null, '  '));\n\n  const stringified = (typeof rawValue === 'object') ?\n    stringify(rawValue) :\n    rawValue.toString().trim();\n\n  return Buffer.from(stringified);\n}\n\n/**\n * Decodes a buffer to a string.\n * @param {Buffer} b The buffer to decode from.\n * @return {string} The buffer's string representation.\n */\nconst decodeAsString = b => b.toString().trim();\n\n/**\n * Decodes a buffer to an integer value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded integer.\n */\nconst decodeAsInt = b => parseInt(decodeAsString(b), 10);\n\n/**\n * Decodes a buffer to a float value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded float.\n */\nconst decodeAsFloat = b => parseFloat(decodeAsString(b));\n\n/**\n * Decodes a buffer using JSON.\n * @param {Buffer} b The buffer to decode from.\n * @return {*} The decoded value, most likely an Object.\n */\nconst decodeAsJson = b => JSON.parse(b.toString());\n\n/**\n * Mapping functions that return raw values for a stored value of the given type.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst decodeRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.Boolean]: b => decodeAsString(b) === 'true',\n  [DataType.SByte]: decodeAsInt,\n  [DataType.Byte]: decodeAsInt,\n  [DataType.Int16]: decodeAsInt,\n  [DataType.UInt16]: decodeAsInt,\n  [DataType.Int32]: decodeAsInt,\n  [DataType.UInt32]: decodeAsInt,\n  [DataType.Int64]: decodeAsJson,\n  [DataType.UInt64]: decodeAsJson,\n  [DataType.Float]: decodeAsFloat,\n  [DataType.Double]: decodeAsFloat,\n  [DataType.String]: decodeAsString,\n  [DataType.DateTime]: decodeAsString,\n  [DataType.Guid]: decodeAsString,\n  // ByteString maps to Buffer\n  [DataType.XmlElement]: decodeAsString,\n  [DataType.NodeId]: decodeAsString,\n  [DataType.ExpandedNodeId]: decodeAsString,\n  [DataType.StatusCode]: decodeAsString,\n  [DataType.QualifiedName]: decodeAsJson,\n  [DataType.LocalizedText]: decodeAsJson,\n  // FIXME: Add ExtensionObject\n  [DataType.DataValue]: decodeAsJson,\n  [DataType.Variant]: decodeAsJson,\n  [DataType.DiagnosticInfo]: decodeAsJson,\n};\n\n/**\n * Mapping functions that return OPC-UA node values for raw values.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst toNodeValue = {\n  [DataType.DateTime]: s => new Date(s),\n  [DataType.ByteString]: b => {\n    if (b instanceof Buffer) { return b; }\n\n    return Buffer.from(b.data, 'binary');\n  },\n  [DataType.NodeId]: s => resolveNodeId(s),\n\n  // Jep, node-opcua does not provide a resolve function for expanded nodeids\n  [DataType.ExpandedNodeId]: s => {\n    const nodeId = resolveNodeId(s);\n    const [value, ...defs] = nodeId.value.split(';');\n\n    const { identifierType, namespace, namespaceUri, serverIndex } = defs.reduce((opts, def) => {\n      const match = def.match(/^([^:]+):(.*)/);\n      if (!match) { return opts; }\n\n      let [key, val] = match.slice(1); // eslint-disable-line prefer-const\n\n      if (key === 'serverIndex') {\n        val = parseInt(val, 10);\n      }\n\n      return Object.assign(opts, { [key]: val });\n    }, Object.assign({}, nodeId));\n\n    return new ExpandedNodeId(identifierType, value, namespace, namespaceUri, serverIndex);\n  },\n\n  [DataType.StatusCode]: name => StatusCodes[name],\n  [DataType.QualifiedName]: options => new QualifiedName(options),\n  [DataType.LocalizedText]: options => new LocalizedText(options),\n  [DataType.DataValue]: options => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'value', DataType.Variant);\n    mapPropertyAs(toNodeValue, opts, 'statusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'sourceTimestamp', DataType.DateTime);\n    mapPropertyAs(toNodeValue, opts, 'serverTimestamp', DataType.DateTime);\n\n    return new DataValue(opts);\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => new Variant({\n    dataType,\n    arrayType: VariantArrayType[arrayType],\n    value,\n    dimensions,\n  }),\n  [DataType.DiagnosticInfo]: options => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n    return new DiagnosticInfo(opts);\n  },\n};\n\n/**\n * Returns a node's OPC-UA value based on it's raw value and type.\n * @param {*} rawValue A node's raw value.\n * @param {node-opcua~DataType} dataType A node's data type.\n * @param {node-opcua~VariantArrayType} arrayType A node's array type.\n */\nconst getNodeValue = (rawValue, dataType, arrayType) => {\n  if (arrayType.value !== VariantArrayType.Scalar.value) {\n    if (!Array.isArray(rawValue)) {\n      throw new Error('Value is not an array');\n    }\n\n    return rawValue.map(raw => getNodeValue(raw, dataType, VariantArrayType[arrayType.value - 1]));\n  }\n\n  return (toNodeValue[dataType] || asIs)(rawValue);\n};\n\n/**\n * Returns a {@link node-opcua~Variant} from a Buffer with the given *dataType* and *arrayType*.\n * @param {Buffer} buffer The buffer to decode from.\n * @param {Object} options The options to use.\n * @param {node-opcua~DataType} options.dataType The data type to decode to.\n * @param {node-opcua~VariantArrayType} options.arrayType The array type to decode to.\n */\nexport function decodeVariant(buffer, { dataType, arrayType }) {\n  if (buffer === null || buffer.length === 0) {\n    return null;\n  }\n\n  if (dataType === DataType.ByteString && arrayType === VariantArrayType.Scalar) {\n    return buffer;\n  }\n\n  const rawValue = arrayType === VariantArrayType.Scalar ?\n    (decodeRawValue[dataType] || asIs)(buffer) :\n    JSON.parse(buffer.toString());\n\n  return getNodeValue(rawValue, dataType, arrayType);\n}\n"],"file":"coding.js"}