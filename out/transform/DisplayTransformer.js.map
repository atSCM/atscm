{"version":3,"sources":["../../src/transform/DisplayTransformer.js"],"names":["tagsBeforeMetadata","Set","metadataIndex","elements","index","length","has","name","DisplayTransformer","XMLTransformer","shouldBeTransformed","node","hasTypeDefinition","transformFromDB","enc","callback","arrayType","VariantArrayType","Scalar","Error","markAsResolved","markReferenceAsResolved","decodeContents","err","results","xml","document","config","scriptTags","inlineScript","forEach","script","attributes","src","dependencies","push","Logger","warn","id","value","contentNode","scriptFile","splitFile","scriptText","type","dataType","DataType","String","metaTag","paramTags","parameters","configFile","JSON","stringify","svgFile","encodeContents","encodeErr","stringValue","renameTo","createCombinedFile","sources","nodeClass","NodeClass","Variable","XmlElement","setReferences","ReferenceTypeIds","HasTypeDefinition","markAllReferencesAsResolved","parse","e","relative","message","path","result","svg","undefined","i","unshift","splice","xmlString"],"mappings":"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","sourcesContent":["import { basename } from 'path';\nimport { NodeClass } from 'node-opcua/lib/datamodel/nodeclass';\nimport { DataType, VariantArrayType } from 'node-opcua/lib/datamodel/variant';\nimport Logger from 'gulplog';\nimport XMLTransformer from '../lib/transform/XMLTransformer';\nimport {\n  findChild, removeChild,\n  removeChildren,\n  createTextNode, createCDataNode, createElement,\n} from '../lib/helpers/xml';\nimport { ReferenceTypeIds } from '../lib/model/Node';\n\n/**\n * Names of the tags to come before <metadata> in output files.\n * @type {Set<string>}\n */\nconst tagsBeforeMetadata = new Set(['defs', 'desc', 'title']);\n\n/**\n * Returns the index at which the <metadata> section should be inserted in the resulting xml.\n * @param {Object[]} elements The elements to look at.\n * @return {number} The insertion index.\n */\nfunction metadataIndex(elements) {\n  let index = 0;\n\n  while (elements.length > index && tagsBeforeMetadata.has(elements[index].name)) {\n    index += 1;\n  }\n\n  return index;\n}\n\n/**\n * Splits read atvise display XML nodes into their SVG and JavaScript sources,\n * alongside with a .json file containing the display's parameters.\n */\nexport default class DisplayTransformer extends XMLTransformer {\n\n  /**\n   * Returns true for all nodes containing atvise displays.\n   * @param {Node} node The node to check.\n   * @return {boolean} `true` for all atvise display nodes.\n   */\n  shouldBeTransformed(node) {\n    return node.hasTypeDefinition('VariableTypes.ATVISE.Display') ||\n      super.shouldBeTransformed(node);\n  }\n\n  /**\n   * Splits any read files containing atvise displays into their SVG and JavaScript sources,\n   * alongside with a json file containing the display's parameters.\n   * @param {Node} node The display node to split.\n   * @param {string} enc The encoding used.\n   * @param {function(err: Error, node: Node)} callback Called with the error that occured\n   * while transforming the display, or the node passed through.\n   */\n  transformFromDB(node, enc, callback) {\n    if (node.arrayType !== VariantArrayType.Scalar) {\n      // FIXME: Instead of throwing we could simply pass the original node to the callback\n      throw new Error('Array of displays not supported');\n    }\n    node.markAsResolved('nodeClass');\n    node.markAsResolved('dataType');\n    node.markAsResolved('arrayType');\n    node.markReferenceAsResolved('HasTypeDefinition', 'VariableTypes.ATVISE.Display');\n\n    this.decodeContents(node, (err, results) => {\n      if (err) {\n        callback(err);\n      } else if (!results) {\n        callback(new Error('Error parsing display: No `svg` tag'));\n      } else {\n        const xml = results;\n        const document = findChild(xml, 'svg');\n\n        if (!document) {\n          callback(new Error('Error parsing display: No `svg` tag'));\n          return;\n        }\n\n        const config = {};\n        const scriptTags = removeChildren(document, 'script');\n        let inlineScript = false;\n\n        // Extract JavaScript\n        if (scriptTags.length) {\n          scriptTags.forEach(script => {\n            if (script.attributes && (script.attributes.src || script.attributes['xlink:href'])) {\n              if (!config.dependencies) {\n                config.dependencies = [];\n              }\n\n              config.dependencies.push(script.attributes.src || script.attributes['xlink:href']);\n            } else {\n              // Warn on multiple inline scripts\n              if (inlineScript) {\n                Logger.warn(`'${node.id.value}' contains multiple inline scripts.`);\n                document.elements.push(inlineScript);\n              }\n              inlineScript = script;\n            }\n          });\n        }\n        if (inlineScript) {\n          const contentNode = inlineScript.elements ? inlineScript.elements[0] : createTextNode();\n          const scriptFile = DisplayTransformer.splitFile(node, '.js');\n          const scriptText = contentNode[contentNode.type] || '';\n\n          scriptFile.value = {\n            dataType: DataType.String,\n            arrayType: VariantArrayType.Scalar,\n            value: scriptText,\n          };\n          this.push(scriptFile);\n        }\n\n        // Extract metadata\n        const metaTag = findChild(document, 'metadata');\n        if (metaTag && metaTag.elements) {\n          // TODO: Warn on multiple metadata tags\n\n          // - Parameters\n          const paramTags = removeChildren(metaTag, 'atv:parameter');\n          if (paramTags.length) {\n            config.parameters = [];\n\n            paramTags.forEach(({ attributes }) => config.parameters.push(attributes));\n          }\n        }\n\n        const configFile = DisplayTransformer.splitFile(node, '.json');\n\n        configFile.value = {\n          dataType: DataType.String,\n          arrayType: VariantArrayType.Scalar,\n          value: JSON.stringify(config, null, '  '),\n        };\n        this.push(configFile);\n\n        const svgFile = DisplayTransformer.splitFile(node, '.svg');\n\n        this.encodeContents(xml, (encodeErr, stringValue) => {\n          if (encodeErr) {\n            callback(encodeErr);\n          } else {\n            svgFile.value = {\n              dataType: DataType.String,\n              arrayType: VariantArrayType.Scalar,\n              value: stringValue,\n            };\n            this.push(svgFile);\n\n            node.renameTo(`${node.name}.display`);\n\n            callback(null, node);\n          }\n        });\n      }\n    });\n  }\n\n  /**\n   * Creates a display from the collected source nodes.\n   * @param {Node} node The node to map to.\n   * @param {Map<String, Node>} sources The collected files, stored against their extension.\n   * @param {function(err: ?Error, data: Node)} callback Called with the error that occured\n   * while creating the display or the resulting file.\n   */\n  createCombinedFile(node, sources, callback) {\n    /* eslint-disable no-param-reassign */\n\n    // FIXME: Set nodeClass to NodeClass.Variable\n    node.nodeClass = NodeClass.Variable;\n    node.markAsResolved('nodeClass');\n\n    // Set dataType to DataType.XmlElement\n    node.value.dataType = DataType.XmlElement;\n    node.markAsResolved('dataType');\n\n    // Set arrayType to 'Scalar'\n    node.value.arrayType = VariantArrayType.Scalar;\n    node.markAsResolved('arrayType');\n\n    // Set type definition reference to 'VariableTypes.ATVISE.Display'\n    node.setReferences(ReferenceTypeIds.HasTypeDefinition, ['VariableTypes.ATVISE.Display']);\n    node.markAllReferencesAsResolved('HasTypeDefinition');\n\n    /* eslint-enable no-param-reassign */\n\n    node.renameTo(basename(node.name, '.display'));\n\n    const configFile = sources['.json'];\n    let config = {};\n\n    if (configFile) {\n      try {\n        config = JSON.parse(configFile.stringValue);\n      } catch (e) {\n        callback(new Error(`Error parsing JSON in ${configFile.relative}: ${e.message}`));\n        return;\n      }\n    }\n\n    const svgFile = sources['.svg'];\n    if (!svgFile) {\n      callback(new Error(`No display SVG in ${svgFile.path}`));\n      return;\n    }\n\n    const scriptFile = sources['.js'];\n    let inlineScript = '';\n    if (scriptFile) {\n      inlineScript = scriptFile.stringValue;\n    }\n\n    this.decodeContents(svgFile, (err, xml) => {\n      if (err) {\n        callback(err);\n      } else {\n        const result = xml;\n        const svg = findChild(result, 'svg');\n\n        if (!svg) {\n          callback(new Error('Error parsing display SVG: No `svg` tag'));\n          return;\n        }\n\n        // Handle empty svg tag\n        if (!svg.elements) {\n          svg.elements = [];\n        }\n\n        // Insert dependencies\n        if (config.dependencies) {\n          config.dependencies.forEach(src => {\n            svg.elements.push(createElement('script', undefined, { 'xlink:href': src }));\n          });\n        }\n\n        // Insert script\n        // FIXME: Import order is not preserved!\n        if (scriptFile) {\n          svg.elements.push(createElement('script', [createCDataNode(inlineScript)], {\n            type: 'text/ecmascript',\n          }));\n        }\n\n        // Insert metadata\n        // - Parameters\n        if (config.parameters && config.parameters.length > 0) {\n          let metaTag = removeChild(svg, 'metadata');\n\n          if (!metaTag) {\n            metaTag = createElement('metadata');\n          }\n\n          if (!metaTag.elements) {\n            metaTag.elements = [];\n          }\n\n          // Parameters should come before other atv attributes, e.g. `atv:gridconfig`\n          for (let i = config.parameters.length - 1; i >= 0; i--) {\n            metaTag.elements.unshift(\n              createElement('atv:parameter', undefined, config.parameters[i])\n            );\n          }\n\n          // Insert <metadata> as first element in the resulting svg, after <defs>, <desc> and\n          // <title> if defined\n          svg.elements.splice(metadataIndex(svg.elements), 0, metaTag);\n        }\n\n        this.encodeContents(result, (encodeErr, xmlString) => {\n          if (encodeErr) {\n            callback(encodeErr);\n          } else {\n            // eslint-disable-next-line no-param-reassign\n            node.value.value = xmlString;\n\n            callback(null, node);\n          }\n        });\n      }\n    });\n  }\n\n}\n"],"file":"DisplayTransformer.js"}