{"version":3,"sources":["../../src/transform/DisplayTransformer.js"],"names":["DisplayTransformer","shouldBeTransformed","file","isDisplay","transformFromDB","enc","callback","decodeContents","err","xmlObj","error","nodeId","children","length","name","scriptFileAdded","config","parameters","dependencies","displayContent","scriptFile","splitFile","configFile","svgFile","scripts","filter","tag","index","metadata","find","map","script","attributes","attrs","src","push","warn","contents","from","toString","meta","nonParameterTags","splice","forEach","JSON","stringify","encodeContents","encodeError","xmlString","e","createCombinedFile","files","lastFile","inlineScript","Error","dirname","parse","relative","message","reverse","display","combineFiles","Object","keys","ext","param","unshift","createTag","dependency","type","append","createCData"],"mappings":"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","file":"DisplayTransformer.js","sourcesContent":["import { Buffer } from 'buffer';\nimport Logger from 'gulplog';\nimport XMLTransformer from '../lib/transform/XMLTransformer';\n\n/**\n * Splits read atvise display XML nodes into their SVG and JavaScript sources,\n * alongside with a .json file containing the display's parameters.\n */\nexport default class DisplayTransformer extends XMLTransformer {\n\n  /**\n   * Returns true for all files containing atvise displays.\n   * @param {AtviseFile} file The file to check.\n   * @return {Boolean} `true` for all atvise display files.\n   */\n  shouldBeTransformed(file) {\n    return file.isDisplay;\n  }\n\n  /**\n   * Splits any read files containing atvise displays into their SVG and JavaScript sources,\n   * alongside with a .json file containing the display's parameters.\n   * @param {AtviseFile} file The display file to split.\n   * @param {String} enc The encoding used.\n   * @param {function(err: Error, file: AtviseFile)} callback Called with the error that occured\n   * while transforming the display, or the file passed through.\n   */\n  transformFromDB(file, enc, callback) {\n    this.decodeContents(file, (err, xmlObj) => {\n      if (err) {\n        Logger.error(`Display ${file.nodeId}: Error parsing display content.`,\n          'Check if display content is broken');\n        callback(null);\n      } else if (xmlObj.children.length === 0 || xmlObj.children[0].name !== 'svg') {\n        Logger.error(`Display ${file.nodeId}: Can not decode display. Missing 'svg' tag`);\n        callback(null);\n      } else {\n        try {\n          let scriptFileAdded = false;\n          const config = { parameters: [], dependencies: [] };\n          const displayContent = xmlObj.children[0].children;\n\n          const scriptFile = DisplayTransformer.splitFile(file, '.js');\n          const configFile = DisplayTransformer.splitFile(file, '.json');\n          const svgFile = DisplayTransformer.splitFile(file, '.svg');\n\n          // Filter for script tags in display\n          const scripts = displayContent.filter((tag, index) => {\n            if (tag.name === 'script') {\n              delete displayContent[index];\n              return true;\n            }\n            return false;\n          });\n\n          // Filter for metadata tags in display\n          const metadata = xmlObj.find('*/metadata').children;\n\n          // Extract JavaScript\n          scripts.map((script) => {\n            const attributes = script.attrs;\n\n            if (attributes.src || attributes['xlink:href']) {\n              config.dependencies.push(attributes.src || attributes['xlink:href']);\n            } else if (scriptFileAdded) {\n              Logger.warn(`Display ${file.nodeId}:`,\n                'atscm only supports one inline script per display');\n            } else {\n              scriptFileAdded = true;\n              scriptFile.contents = Buffer.from(script.toString());\n            }\n\n            return false;\n          });\n\n\n          // Extract display parameters\n          if (metadata.length > 0) {\n            const meta = metadata[0].children;\n            const nonParameterTags = [];\n\n            if (metadata.length > 1) {\n              Logger.warn(`Display ${file.nodeId}:`,\n                'atscm only supports one metadata tag per display');\n              metadata.splice(1, metadata.length);\n            }\n\n            meta.forEach(tag => {\n              if (tag.name === 'atv:parameter') {\n                config.parameters.push(tag.attrs);\n              } else {\n                nonParameterTags.push(tag);\n              }\n            });\n\n            // overwrite meta data tag items, deleting items directly in metadata\n            // tag made serialize function ignore\n            // the remaining entries\n            metadata[0].children = nonParameterTags;\n          }\n\n          configFile.contents = Buffer.from(JSON.stringify(config, null, '  '));\n\n          this.encodeContents(xmlObj, (encodeError, xmlString) => {\n            if (encodeError) {\n              Logger.error(`Display ${file.nodeId}: Could not encode svg file`);\n            } else {\n              svgFile.contents = Buffer.from(xmlString);\n              this.push(svgFile);\n              this.push(configFile);\n              this.push(scriptFile);\n            }\n\n            callback(null);\n          });\n        } catch (e) {\n          callback(e);\n        }\n      }\n    });\n  }\n\n  /**\n   * Creates a display from the collected files.\n   * @param {Map<String, vinyl~File>} files The collected files, stored against their extension.\n   * @param {vinyl~File} lastFile The last file read. *Used for error messages only*.\n   * @param {function(err: ?Error, data: vinyl~File)} callback Called with the error that occured\n   * while creating the display or the resulting file.\n   */\n  createCombinedFile(files, lastFile, callback) {\n    const svgFile = files['.svg'];\n    const configFile = files['.json'];\n    const scriptFile = files['.js'];\n\n    let config = {};\n    let inlineScript = '';\n\n    if (!svgFile) {\n      callback(new Error(`No display SVG in ${lastFile.dirname}`));\n      return;\n    }\n\n    if (configFile) {\n      try {\n        config = JSON.parse(configFile.contents.toString());\n      } catch (e) {\n        callback(new Error(`Error parsing JSON in ${configFile.relative}: ${e.message}`));\n        return;\n      }\n    }\n\n    if (scriptFile) {\n      inlineScript = scriptFile.contents.toString();\n    }\n\n    this.decodeContents(svgFile, (err, xmlObj) => {\n      if (err) {\n        Logger.error(`Display ${svgFile.nodeId}: Error parsing display content.\n          Message: ${err.message}`);\n        callback(null);\n      } else {\n        try {\n          const displayContent = xmlObj.children[0];\n          const metadata = xmlObj.find('*/metadata');\n          const parameters = config.parameters.reverse();\n          const dependencies = config.dependencies.reverse();\n          const display = DisplayTransformer.combineFiles(\n            Object.keys(files).map(ext => files[ext]),\n            '.xml'\n          );\n\n          // Insert parameters\n          if (parameters && parameters.length > 0) {\n            const meta = metadata.children[0].children;\n\n            parameters.forEach(param => meta.unshift(this.createTag('atv:parameter',\n              param, metadata)));\n          }\n\n          // Insert dependencies\n          if (dependencies && dependencies.length > 0) {\n            dependencies.forEach(dependency => displayContent.children\n              .push(this.createTag('script', { 'xlink:href': dependency, type: 'text/ecmascript' },\n                metadata)));\n          }\n\n          // Insert script\n          if (scriptFile) {\n            const script = this.createTag('script', { type: 'text/ecmascript' }, displayContent);\n\n            script.append(this.createCData(inlineScript));\n            displayContent.children.push(script);\n          }\n\n          this.encodeContents(xmlObj, (encodeError, xmlString) => {\n            if (encodeError) {\n              Logger.error(`Display ${svgFile.nodeId}: Could not encode svg file`);\n              callback(null);\n            } else {\n              display.contents = Buffer.from(xmlString);\n              callback(null, display);\n            }\n          });\n        } catch (e) {\n          callback(e);\n        }\n      }\n    });\n  }\n\n}\n"]}