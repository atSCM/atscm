{"version":3,"sources":["../../src/transform/DisplayTransformer.js"],"names":["DisplayTransformer","shouldBeTransformed","file","isDisplay","transformFromDB","enc","callback","decodeContents","err","xmlObj","error","nodeId","children","length","rootSVG","find","scriptFileAdded","config","parameters","dependencies","displayContent","scriptFile","splitFile","configFile","svgFile","scripts","filter","tag","index","name","metadata","map","script","attributes","attrs","src","push","warn","contents","from","toString","meta","nonParameterTags","splice","forEach","JSON","stringify","encodeContents","encodeError","xmlString","e","createCombinedFile","files","lastFile","inlineScript","Error","dirname","parse","relative","message","reverse","display","combineFiles","Object","keys","ext","param","unshift","createTag","dependency","type","append","createCData"],"mappings":"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","file":"DisplayTransformer.js","sourcesContent":["import { Buffer } from 'buffer';\nimport Logger from 'gulplog';\nimport sortJSON from 'sort-json';\nimport XMLTransformer from '../lib/transform/XMLTransformer';\n\n/**\n * Splits read atvise display XML nodes into their SVG and JavaScript sources,\n * alongside with a .json file containing the display's parameters.\n */\nexport default class DisplayTransformer extends XMLTransformer {\n\n  /**\n   * Returns true for all files containing atvise displays.\n   * @param {AtviseFile} file The file to check.\n   * @return {Boolean} `true` for all atvise display files.\n   */\n  shouldBeTransformed(file) {\n    return file.isDisplay;\n  }\n\n  /**\n   * Splits any read files containing atvise displays into their SVG and JavaScript sources,\n   * alongside with a .json file containing the display's parameters.\n   * @param {AtviseFile} file The display file to split.\n   * @param {String} enc The encoding used.\n   * @param {function(err: Error, file: AtviseFile)} callback Called with the error that occured\n   * while transforming the display, or the file passed through.\n   */\n  transformFromDB(file, enc, callback) {\n    this.decodeContents(file, (err, xmlObj) => {\n      if (err) {\n        Logger.error(`Display ${file.nodeId}: Error parsing display content.`,\n          'Check if display content is broken');\n        callback(null);\n      } else if (xmlObj.children.length === 0) {\n        Logger.error(`Display ${file.nodeId}: Xml object is empty`);\n        callback(null);\n      } else {\n        const rootSVG = xmlObj.find('svg').children[0];\n\n        if (rootSVG) {\n          try {\n            let scriptFileAdded = false;\n            const config = { parameters: [], dependencies: [] };\n            const displayContent = rootSVG.children;\n\n            const scriptFile = DisplayTransformer.splitFile(file, '.js');\n            const configFile = DisplayTransformer.splitFile(file, '.json');\n            const svgFile = DisplayTransformer.splitFile(file, '.svg');\n\n            // Filter for script tags in display\n            const scripts = displayContent.filter((tag, index) => {\n              if (tag.name === 'script') {\n                delete displayContent[index];\n                return true;\n              }\n              return false;\n            });\n\n            // Filter for metadata tags in display\n            const metadata = rootSVG.find('metadata').children;\n\n            // Extract JavaScript\n            scripts.map((script) => {\n              const attributes = script.attrs;\n\n              if (attributes.src || attributes['xlink:href']) {\n                config.dependencies.push(attributes.src || attributes['xlink:href']);\n              } else if (scriptFileAdded) {\n                Logger.warn(`Display ${file.nodeId}:`,\n                  'atscm only supports one inline script per display');\n              } else {\n                scriptFileAdded = true;\n                scriptFile.contents = Buffer.from(script.toString());\n              }\n\n              return false;\n            });\n\n\n            // Extract display parameters\n            if (metadata.length > 0) {\n              const meta = metadata[0].children;\n              const nonParameterTags = [];\n\n              if (metadata.length > 1) {\n                Logger.warn(`Display ${file.nodeId}:`,\n                  'atscm only supports one metadata tag per display');\n                metadata.splice(1, metadata.length);\n              }\n\n              meta.forEach(tag => {\n                if (tag.name === 'atv:parameter') {\n                  config.parameters.push(tag.attrs);\n                } else {\n                  nonParameterTags.push(tag);\n                }\n              });\n\n              // overwrite meta data tag items, deleting items directly in metadata\n              // tag made serialize function ignore\n              // the remaining entries\n              metadata[0].children = nonParameterTags;\n            }\n\n            configFile.contents = Buffer.from(\n              JSON.stringify(sortJSON(config), null, '  ')\n            );\n\n            this.encodeContents(xmlObj, (encodeError, xmlString) => {\n              if (encodeError) {\n                Logger.error(`Display ${file.nodeId}: Could not encode svg file`);\n              } else {\n                svgFile.contents = Buffer.from(xmlString);\n                this.push(svgFile);\n                this.push(configFile);\n                this.push(scriptFile);\n              }\n\n              callback(null);\n            });\n          } catch (e) {\n            callback(e);\n          }\n        } else {\n          Logger.error(`Display ${file.nodeId}: Can not decode display. Missing 'svg' tag`);\n          callback(null);\n        }\n      }\n    });\n  }\n\n  /**\n   * Creates a display from the collected files.\n   * @param {Map<String, vinyl~File>} files The collected files, stored against their extension.\n   * @param {vinyl~File} lastFile The last file read. *Used for error messages only*.\n   * @param {function(err: ?Error, data: vinyl~File)} callback Called with the error that occured\n   * while creating the display or the resulting file.\n   */\n  createCombinedFile(files, lastFile, callback) {\n    const svgFile = files['.svg'];\n    const configFile = files['.json'];\n    const scriptFile = files['.js'];\n\n    let config = {};\n    let inlineScript = '';\n\n    if (!svgFile) {\n      callback(new Error(`No display SVG in ${lastFile.dirname}`));\n      return;\n    }\n\n    if (configFile) {\n      try {\n        config = JSON.parse(configFile.contents.toString());\n      } catch (e) {\n        callback(new Error(`Error parsing JSON in ${configFile.relative}: ${e.message}`));\n        return;\n      }\n    }\n\n    if (scriptFile) {\n      inlineScript = scriptFile.contents.toString();\n    }\n\n    this.decodeContents(svgFile, (err, xmlObj) => {\n      if (err) {\n        Logger.error(`Display ${svgFile.nodeId}: Error parsing display content.\n          Message: ${err.message}`);\n        callback(null);\n      } else {\n        try {\n          const displayContent = xmlObj.children[0];\n          const metadata = xmlObj.find('*/metadata');\n          const parameters = config.parameters.reverse();\n          const dependencies = config.dependencies;\n          const display = DisplayTransformer.combineFiles(\n            Object.keys(files).map(ext => files[ext]),\n            '.xml'\n          );\n\n          // Insert parameters\n          if (parameters && parameters.length > 0) {\n            if (metadata.children[0]) {\n              const meta = metadata.children[0].children;\n\n              parameters.forEach(param => meta.unshift(this.createTag('atv:parameter',\n                param, metadata)));\n            } else {\n              Logger.error(`Display ${svgFile.nodeId}: Metadata tag is missing.`,\n                'Can not append parameters');\n            }\n          }\n\n          // Insert dependencies\n          if (dependencies && dependencies.length > 0) {\n            dependencies.forEach(dependency => displayContent.children\n              .push(this.createTag('script', { 'xlink:href': dependency, type: 'text/ecmascript' },\n                metadata)));\n          }\n\n          // Insert script\n          if (scriptFile) {\n            const script = this.createTag('script', { type: 'text/ecmascript' }, displayContent);\n\n            script.append(this.createCData(inlineScript));\n            displayContent.children.push(script);\n          }\n\n          this.encodeContents(xmlObj, (encodeError, xmlString) => {\n            if (encodeError) {\n              Logger.error(`Display ${svgFile.nodeId}: Could not encode svg file`);\n              callback(null);\n            } else {\n              display.contents = Buffer.from(xmlString);\n              callback(null, display);\n            }\n          });\n        } catch (e) {\n          callback(e);\n        }\n      }\n    });\n  }\n\n}\n"]}