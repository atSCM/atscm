{"version":3,"sources":["../../src/transform/Newlines.js"],"names":["trailingNewlineRegExp","NewlinesTransformer","shouldBeTransformed","file","stem","dataType","ByteString","transformFromDB","enc","callback","str","contents","toString","replace","match","Buffer","from","transformFromFilesystem","transformsReferenceConfigFiles"],"mappings":";;;;;;AAAA;;AACA;;AACA;;;;;;AAEA;;;AAGA,MAAMA,wBAAwB,QAA9B;;AAEA;;;;;AAKe,MAAMC,mBAAN,sCAAqD;;AAElE;;;;AAIAC,sBAAoBC,IAApB,EAA0B;AACxB,WAAOA,KAAKC,IAAL,CAAU,CAAV,MAAiB,GAAjB,IAAwBD,KAAKE,QAAL,KAAkB,oBAASC,UAA1D;AACD;;AAED;;;;;;AAMAC,kBAAgBJ,IAAhB,EAAsBK,GAAtB,EAA2BC,QAA3B,EAAqC;AACnC,QAAIC,MAAMP,KAAKQ,QAAL,CAAcC,QAAd,GAAyBC,OAAzB,CAAiC,QAAjC,UAAV;;AAEA,QAAI,CAACH,IAAII,KAAJ,CAAUd,qBAAV,CAAL,EAAuC;AACrCU;AACD;;AAEDP,SAAKQ,QAAL,GAAgBI,OAAOC,IAAP,CAAYN,GAAZ,CAAhB,CAPmC,CAOD;;AAElCD,aAAS,IAAT,EAAeN,IAAf;AACD;;AAED;;;;;;AAMAc,0BAAwBd,IAAxB,EAA8BK,GAA9B,EAAmCC,QAAnC,EAA6C;AAC3C,UAAMC,MAAMP,KAAKQ,QAAL,CAAcC,QAAd,GACTC,OADS,CACD,QADC,EACS,MADT,EAETA,OAFS,CAEDb,qBAFC,EAEsB,EAFtB,CAAZ;;AAIAG,SAAKQ,QAAL,GAAgBI,OAAOC,IAAP,CAAYN,GAAZ,CAAhB,CAL2C,CAKT;;AAElCD,aAAS,IAAT,EAAeN,IAAf;AACD;;AAED;;;;AAIA,MAAIe,8BAAJ,GAAqC;AACnC,WAAO,IAAP;AACD;;AAlDiE;kBAA/CjB,mB","file":"Newlines.js","sourcesContent":["import { EOL } from 'os';\nimport { DataType } from 'node-opcua';\nimport PartialTransformer from '../lib/transform/PartialTransformer';\n\n/**\n * A regular expression matching trailing newlines.\n */\nconst trailingNewlineRegExp = /\\r\\n+$/;\n\n/**\n * A transformer that handles newline characters in files. During a pull, all breaks are converted\n * the OS-native EOL character and a trailing newline is added (for better git diffs). On push, CRLF\n * characters are used and those trailing newlines are removed again.\n */\nexport default class NewlinesTransformer extends PartialTransformer {\n\n  /**\n   * Returns `true` for all files except binary ones.\n   * @param {AtviseFile} file The file being transformed.\n   */\n  shouldBeTransformed(file) {\n    return file.stem[0] === '.' || file.dataType !== DataType.ByteString;\n  }\n\n  /**\n   * Adds converts line breaks to the current OS's native EOL characters and adds trailing newlines.\n   * @param {AtviseFile} file The file being transformed.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the corrected file.\n   */\n  transformFromDB(file, enc, callback) {\n    let str = file.contents.toString().replace(/\\r?\\n/g, EOL);\n\n    if (!str.match(trailingNewlineRegExp)) {\n      str += EOL;\n    }\n\n    file.contents = Buffer.from(str); // eslint-disable-line no-param-reassign\n\n    callback(null, file);\n  }\n\n  /**\n   * Removes trailing newlines and converts all breaks to CRLF.\n   * @param {AtviseFile} file The file being transformed.\n   * @param {string} enc The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with resulting file.\n   */\n  transformFromFilesystem(file, enc, callback) {\n    const str = file.contents.toString()\n      .replace(/\\r?\\n/g, '\\r\\n')\n      .replace(trailingNewlineRegExp, '');\n\n    file.contents = Buffer.from(str); // eslint-disable-line no-param-reassign\n\n    callback(null, file);\n  }\n\n  /**\n   * `true` because we want to transform all files.\n   * @type {boolean}\n   */\n  get transformsReferenceConfigFiles() {\n    return true;\n  }\n\n}\n"]}