{"version":3,"sources":["../../src/transform/Mapping.js"],"names":["MappingTransformer","transformFromDB","readResult","encoding","callback","file","fromReadResult","relative","match","rc","clone","extname","basename","stem","contents","Buffer","from","JSON","stringify","typeDefinition","push","e","message","nodeId","toString","debug","transformFromFilesystem","isDirectory","slice","atFile","cwd","base","path","rcFile","err","data","parse","_typeDefinition","error"],"mappings":";;;;;;AAAA;;AACA;;;;AACA;;AACA;;;;AACA;;;;AACA;;;;;;AAEA;;;AAGe,MAAMA,kBAAN,+BAA6C;;AAE1D;;;;;;;;AAQAC,kBAAgBC,UAAhB,EAA4BC,QAA5B,EAAsCC,QAAtC,EAAgD;AAC9C,QAAI;AACF,YAAMC,OAAO,qBAAWC,cAAX,CAA0BJ,UAA1B,CAAb;;AAEA,UAAIG,KAAKE,QAAL,CAAcC,KAAd,CAAoB,SAApB,CAAJ,EAAoC;AAClC,cAAMC,KAAKJ,KAAKK,KAAL,EAAX;;AAEAD,WAAGE,OAAH,GAAa,EAAb;AACAF,WAAGG,QAAH,GAAe,IAAGH,GAAGI,IAAK,KAA1B;;AAEAJ,WAAGK,QAAH,GAAcC,OAAOC,IAAP,CAAYC,KAAKC,SAAL,CAAe;AACvCC,0BAAgBd,KAAKc;AADkB,SAAf,EAEvB,IAFuB,EAEjB,IAFiB,CAAZ,CAAd;;AAIA,aAAKC,IAAL,CAAUX,EAAV;AACD;;AAEDL,eAAS,IAAT,EAAeC,IAAf;AACD,KAjBD,CAiBE,OAAOgB,CAAP,EAAU;AACV,wBAAOA,EAAEC,OAAF,KAAc,UAAd,GAA2B,OAA3B,GAAqC,MAA5C,EACG,iBAAgBpB,WAAWqB,MAAX,CAAkBC,QAAlB,EAA6B,KAAIH,EAAEC,OAAQ,EAD9D;AAGA,wBAAOG,KAAP,CAAaJ,CAAb;;AAEAjB,eAAS,IAAT;AACD;AACF;;AAED;;;;;;;AAOAsB,0BAAwBrB,IAAxB,EAA8BF,QAA9B,EAAwCC,QAAxC,EAAkD;AAChD,QAAIC,KAAKsB,WAAL,EAAJ,EAAwB;AACtBvB,eAAS,IAAT;AACD,KAFD,MAEO,IAAIC,KAAKQ,IAAL,CAAU,CAAV,MAAiB,GAAjB,IAAwB,CAAC,qBAAUR,KAAKQ,IAAL,CAAUe,KAAV,CAAgB,CAAhB,CAAV,CAA7B,EAA4D;AACjE,wBAAOH,KAAP,CAAa,eAAb,EAA8BpB,KAAKE,QAAnC;AACAH,eAAS,IAAT;AACD,KAHM,MAGA;AACL,YAAMyB,SAAS,yBAAe;AAC5BC,aAAKzB,KAAKyB,GADkB;AAE5BC,cAAM1B,KAAK0B,IAFiB;AAG5BC,cAAM3B,KAAK2B,IAHiB;AAI5BlB,kBAAUT,KAAKS;AAJa,OAAf,CAAf;;AAOA,UAAIT,KAAKE,QAAL,CAAcC,KAAd,CAAoB,SAApB,CAAJ,EAAoC;AAClC,cAAMyB,SAAS5B,KAAKK,KAAL,CAAW,EAAEI,UAAU,KAAZ,EAAX,CAAf;AACAmB,eAAOtB,OAAP,GAAiB,EAAjB;AACAsB,eAAOrB,QAAP,GAAmB,IAAGqB,OAAOpB,IAAK,KAAlC;;AAEA,0BAASoB,OAAOD,IAAhB,EAAsB,MAAtB,EAA8B,CAACE,GAAD,EAAMC,IAAN,KAAe;AAC3C,cAAI;AACF,kBAAM1B,KAAKQ,KAAKmB,KAAL,CAAWD,IAAX,CAAX;AACAN,mBAAOQ,eAAP,GAAyB,qBAAW5B,GAAGU,cAAd,CAAzB;;AAEAf,qBAAS,IAAT,EAAeyB,MAAf;AACD,WALD,CAKE,OAAOR,CAAP,EAAU;AACV,8BAAOiB,KAAP,CAAc,2CAA0CjC,KAAKE,QAAS,EAAtE;AACAH,qBAAS8B,OAAOb,CAAhB;AACD;AACF,SAVD;AAWD,OAhBD,MAgBO;AACLjB,iBAAS,IAAT,EAAeyB,MAAf;AACD;AACF;AACF;;AA/EyD;kBAAvC7B,kB","file":"Mapping.js","sourcesContent":["import { readFile } from 'fs';\nimport Logger from 'gulplog';\nimport { NodeClass } from 'node-opcua';\nimport Transformer from '../lib/transform/Transformer';\nimport AtviseFile from '../lib/server/AtviseFile';\nimport NodeId from '../lib/model/opcua/NodeId';\n\n/**\n * A Transformer that maps {@link ReadStream.ReadResult}s to {@link AtviseFile}s.\n */\nexport default class MappingTransformer extends Transformer {\n\n  /**\n   * Writes an {@link AtviseFile} for each {@link ReadStream.ReadResult} read. If a read file has a\n   * non-standard type (definition) an additional `rc` file is pushed holding this type.\n   * @param {ReadStream.ReadResult} readResult The read result to create the file for.\n   * @param {string} encoding The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\n   * while transforming the read result or the resulting file.\n   */\n  transformFromDB(readResult, encoding, callback) {\n    try {\n      const file = AtviseFile.fromReadResult(readResult);\n\n      if (file.relative.match(/\\.var\\./)) {\n        const rc = file.clone();\n\n        rc.extname = '';\n        rc.basename = `.${rc.stem}.rc`;\n\n        rc.contents = Buffer.from(JSON.stringify({\n          typeDefinition: file.typeDefinition,\n        }, null, '  '));\n\n        this.push(rc);\n      }\n\n      callback(null, file);\n    } catch (e) {\n      Logger[e.message === 'no value' ? 'debug' : 'warn'](\n        `Unable to map ${readResult.nodeId.toString()}: ${e.message}`\n      );\n      Logger.debug(e);\n\n      callback(null);\n    }\n  }\n\n  /**\n   * Writes an {@link AtviseFile} for each {@link vinyl~File} read.\n   * @param {vinyl~File} file The raw file.\n   * @param {string} encoding The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\n   * while transforming the read result or the resulting file.\n   */\n  transformFromFilesystem(file, encoding, callback) {\n    if (file.isDirectory()) {\n      callback(null);\n    } else if (file.stem[0] === '.' && !NodeClass[file.stem.slice(1)]) {\n      Logger.debug('Ignoring file', file.relative);\n      callback(null);\n    } else {\n      const atFile = new AtviseFile({\n        cwd: file.cwd,\n        base: file.base,\n        path: file.path,\n        contents: file.contents,\n      });\n\n      if (file.relative.match(/\\.var\\./)) {\n        const rcFile = file.clone({ contents: false });\n        rcFile.extname = '';\n        rcFile.basename = `.${rcFile.stem}.rc`;\n\n        readFile(rcFile.path, 'utf8', (err, data) => {\n          try {\n            const rc = JSON.parse(data);\n            atFile._typeDefinition = new NodeId(rc.typeDefinition);\n\n            callback(null, atFile);\n          } catch (e) {\n            Logger.error(`Unable to get runtime configuration for ${file.relative}`);\n            callback(err || e);\n          }\n        });\n      } else {\n        callback(null, atFile);\n      }\n    }\n  }\n\n}\n"]}