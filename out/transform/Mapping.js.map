{"version":3,"sources":["../../src/transform/Mapping.js"],"names":["MappingTransformer","transformFromDB","readResult","encoding","callback","file","fromReadResult","relative","match","rc","clone","extname","basename","stem","contents","from","JSON","stringify","typeDefinition","push","e","message","nodeId","toString","debug","transformFromFilesystem","isDirectory","atFile","cwd","base","path","rcFile","err","data","parse","_typeDefinition","error"],"mappings":";;;;;;AAAA;;AACA;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA;;;AAGe,MAAMA,kBAAN,+BAA6C;;AAE1D;;;;;;;;AAQAC,kBAAgBC,UAAhB,EAA4BC,QAA5B,EAAsCC,QAAtC,EAAgD;AAC9C,QAAI;AACF,YAAMC,OAAO,qBAAWC,cAAX,CAA0BJ,UAA1B,CAAb;;AAEA,UAAIG,KAAKE,QAAL,CAAcC,KAAd,CAAoB,SAApB,CAAJ,EAAoC;AAClC,cAAMC,KAAKJ,KAAKK,KAAL,EAAX;;AAEAD,WAAGE,OAAH,GAAa,EAAb;AACAF,WAAGG,QAAH,GAAe,IAAGH,GAAGI,IAAK,KAA1B;;AAEAJ,WAAGK,QAAH,GAAc,eAAOC,IAAP,CAAYC,KAAKC,SAAL,CAAe;AACvCC,0BAAgBb,KAAKa;AADkB,SAAf,EAEvB,IAFuB,EAEjB,IAFiB,CAAZ,CAAd;;AAIA,aAAKC,IAAL,CAAUV,EAAV;AACD;;AAEDL,eAAS,IAAT,EAAeC,IAAf;AACD,KAjBD,CAiBE,OAAOe,CAAP,EAAU;AACV,wBAAOA,EAAEC,OAAF,KAAc,UAAd,GAA2B,OAA3B,GAAqC,MAA5C,EACG,iBAAgBnB,WAAWoB,MAAX,CAAkBC,QAAlB,EAA6B,KAAIH,EAAEC,OAAQ,EAD9D;AAGA,wBAAOG,KAAP,CAAaJ,CAAb;;AAEAhB,eAAS,IAAT;AACD;AACF;;AAED;;;;;;;AAOAqB,0BAAwBpB,IAAxB,EAA8BF,QAA9B,EAAwCC,QAAxC,EAAkD;AAChD,QAAIC,KAAKqB,WAAL,EAAJ,EAAwB;AACtBtB,eAAS,IAAT;AACD,KAFD,MAEO;AACL,YAAMuB,SAAS,yBAAe;AAC5BC,aAAKvB,KAAKuB,GADkB;AAE5BC,cAAMxB,KAAKwB,IAFiB;AAG5BC,cAAMzB,KAAKyB,IAHiB;AAI5BhB,kBAAUT,KAAKS;AAJa,OAAf,CAAf;;AAOA,UAAIT,KAAKE,QAAL,CAAcC,KAAd,CAAoB,SAApB,CAAJ,EAAoC;AAClC,cAAMuB,SAAS1B,KAAKK,KAAL,CAAW,EAAEI,UAAU,KAAZ,EAAX,CAAf;AACAiB,eAAOpB,OAAP,GAAiB,EAAjB;AACAoB,eAAOnB,QAAP,GAAmB,IAAGmB,OAAOlB,IAAK,KAAlC;;AAEA,0BAASkB,OAAOD,IAAhB,EAAsB,MAAtB,EAA8B,CAACE,GAAD,EAAMC,IAAN,KAAe;AAC3C,cAAI;AACF,kBAAMxB,KAAKO,KAAKkB,KAAL,CAAWD,IAAX,CAAX;AACAN,mBAAOQ,eAAP,GAAyB,qBAAW1B,GAAGS,cAAd,CAAzB;;AAEAd,qBAAS,IAAT,EAAeuB,MAAf;AACD,WALD,CAKE,OAAOP,CAAP,EAAU;AACV,8BAAOgB,KAAP,CAAc,2CAA0C/B,KAAKE,QAAS,EAAtE;AACAH,qBAAS4B,OAAOZ,CAAhB;AACD;AACF,SAVD;AAWD,OAhBD,MAgBO;AACLhB,iBAAS,IAAT,EAAeuB,MAAf;AACD;AACF;AACF;;AA5EyD;kBAAvC3B,kB","file":"Mapping.js","sourcesContent":["import { Buffer } from 'buffer';\nimport { readFile } from 'fs';\nimport Logger from 'gulplog';\nimport Transformer from '../lib/transform/Transformer';\nimport AtviseFile from '../lib/server/AtviseFile';\nimport NodeId from '../lib/server/NodeId';\n\n/**\n * A Transformer that maps {@link ReadStream.ReadResult}s to {@link AtviseFile}s.\n */\nexport default class MappingTransformer extends Transformer {\n\n  /**\n   * Writes an {@link AtviseFile} for each {@link ReadStream.ReadResult} read. If a read file has a\n   * non-standard type (definition) an additional `.rc` file is pushed holding this type.\n   * @param {ReadStream.ReadResult} readResult The read result to create the file for.\n   * @param {String} encoding The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\n   * while transforming the read result or the resulting file.\n   */\n  transformFromDB(readResult, encoding, callback) {\n    try {\n      const file = AtviseFile.fromReadResult(readResult);\n\n      if (file.relative.match(/\\.var\\./)) {\n        const rc = file.clone();\n\n        rc.extname = '';\n        rc.basename = `.${rc.stem}.rc`;\n\n        rc.contents = Buffer.from(JSON.stringify({\n          typeDefinition: file.typeDefinition,\n        }, null, '  '));\n\n        this.push(rc);\n      }\n\n      callback(null, file);\n    } catch (e) {\n      Logger[e.message === 'no value' ? 'debug' : 'warn'](\n        `Unable to map ${readResult.nodeId.toString()}: ${e.message}`\n      );\n      Logger.debug(e);\n\n      callback(null);\n    }\n  }\n\n  /**\n   * Writes an {@link AtviseFile} for each {@link vinyl~File} read.\n   * @param {vinyl~File} file The raw file.\n   * @param {String} encoding The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\n   * while transforming the read result or the resulting file.\n   */\n  transformFromFilesystem(file, encoding, callback) {\n    if (file.isDirectory()) {\n      callback(null);\n    } else {\n      const atFile = new AtviseFile({\n        cwd: file.cwd,\n        base: file.base,\n        path: file.path,\n        contents: file.contents,\n      });\n\n      if (file.relative.match(/\\.var\\./)) {\n        const rcFile = file.clone({ contents: false });\n        rcFile.extname = '';\n        rcFile.basename = `.${rcFile.stem}.rc`;\n\n        readFile(rcFile.path, 'utf8', (err, data) => {\n          try {\n            const rc = JSON.parse(data);\n            atFile._typeDefinition = new NodeId(rc.typeDefinition);\n\n            callback(null, atFile);\n          } catch (e) {\n            Logger.error(`Unable to get runtime configuration for ${file.relative}`);\n            callback(err || e);\n          }\n        });\n      } else {\n        callback(null, atFile);\n      }\n    }\n  }\n\n}\n"]}