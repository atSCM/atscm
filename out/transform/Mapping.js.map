{"version":3,"sources":["../../src/transform/Mapping.js"],"names":["standardTypes","extension","dataType","ByteString","XmlElement","extensionForDataType","Boolean","key","SByte","Byte","Int16","UInt16","Int32","UInt32","Int64","UInt64","Float","Double","String","DateTime","Guid","NodeId","ExpandedNodeId","StatusCode","QualifiedName","LocalizedText","ExtensionObject","DataValue","Variant","DiagnosticInfo","extensionForArrayType","Array","Matrix","MappingTransformer","constructor","args","_readReferenceFiles","transformFromDB","node","encoding","callback","fullyMapped","parentResolvesMetadata","typeDefinition","isStandardTypeNode","def","Object","entries","isVariable","renameTo","name","fileName","endsWith","Error","nodeId","type","ext","value","arrayType","ignore","Set","c","parent","_compactMappingApplied","has","id","assign","transformFromFilesystem","equal","transformsReferenceConfigFiles"],"mappings":"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","file":"Mapping.js","sourcesContent":["import { basename } from 'path';\nimport assert from 'assert';\nimport { VariantArrayType, DataType } from 'node-opcua/lib/datamodel/variant';\nimport Transformer from '../lib/transform/Transformer';\n\n/**\n * Atvise specific types that need special extensions.\n * @type {Map<string, Object>}\n */\nconst standardTypes = {\n  'VariableTypes.ATVISE.HtmlHelp': {\n    extension: '.help.html',\n    dataType: DataType.ByteString,\n  },\n  'VariableTypes.ATVISE.TranslationTable': {\n    extension: '.locs.xml',\n    dataType: DataType.XmlElement,\n  },\n};\n\n/**\n * Extensions to use for {@link node-opcua~DataType}s.\n * @type {Map<string, string>}\n */\nconst extensionForDataType = {\n  [DataType.Boolean.key]: '.bool',\n  [DataType.SByte.key]: '.sbyte',\n  [DataType.Byte.key]: '.byte',\n  [DataType.Int16.key]: '.int16',\n  [DataType.UInt16.key]: '.uint16',\n  [DataType.Int32.key]: '.int32',\n  [DataType.UInt32.key]: '.uint32',\n  [DataType.Int64.key]: '.int64',\n  [DataType.UInt64.key]: '.uint64',\n  [DataType.Float.key]: '.float',\n  [DataType.Double.key]: '.double',\n  [DataType.String.key]: '.string',\n  [DataType.DateTime.key]: '.datetime',\n  [DataType.Guid.key]: '.guid',\n  // [DataType.ByteString.key]: '.bytestring',\n  [DataType.XmlElement.key]: '.xml',\n  [DataType.NodeId.key]: '.nodeid',\n  [DataType.ExpandedNodeId.key]: '.enodeid',\n  [DataType.StatusCode.key]: '.status',\n  [DataType.QualifiedName.key]: '.name',\n  [DataType.LocalizedText.key]: '.text',\n  [DataType.ExtensionObject.key]: '.obj',\n  [DataType.DataValue.key]: '.value',\n  [DataType.Variant.key]: '.variant',\n  [DataType.DiagnosticInfo.key]: '.info',\n};\n\n/**\n * Extensions to use for {@link node-opcua~VariantArrayType}s.\n * @type {Map<string, string>}\n */\nconst extensionForArrayType = {\n  [VariantArrayType.Array.key]: '.array',\n  [VariantArrayType.Matrix.key]: '.matrix',\n};\n\n/**\n * A Transformer that maps {@link ReadStream.ReadResult}s to {@link AtviseFile}s.\n */\nexport default class MappingTransformer extends Transformer {\n\n  /**\n   * Creates a new mapping transformer.\n   * @param {any[]} args The arguments passed to the {@link Transformer} constructor.\n   */\n  constructor(...args) {\n    super(...args);\n\n    /**\n     * Contents of the reference files read but not used yet.\n     * @type {Object}\n     */\n    this._readReferenceFiles = {};\n  }\n\n  /**\n   * Writes an {@link AtviseFile} for each {@link ReadStream.ReadResult} read. If a read file has a\n   * non-standard type (definition) an additional `rc` file is pushed holding this type.\n   * @param {Node} node The read result to create the file for.\n   * @param {string} encoding The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\n   * while transforming the read result or the resulting file.\n   */\n  transformFromDB(node, encoding, callback) {\n    if (!node.fullyMapped && !node.parentResolvesMetadata) { // Skip mapping for e.g. split files\n      const typeDefinition = node.typeDefinition;\n      let isStandardTypeNode = false;\n\n      // Add extensions for standard types\n      for (const [def, { extension }] of Object.entries(standardTypes)) {\n        if (node.isVariable && typeDefinition === def) {\n          node.renameTo(`${node.name}${extension}`);\n          isStandardTypeNode = true;\n\n          // FIXME: Set dataType and mark as resolved\n          // FIXME: Set typeDefinition and mark as resolved\n        } else if (node.fileName.endsWith(extension)) {\n          callback(new Error(`Name conflict: ${node.nodeId} should not end with '${extension}'`));\n          return;\n        }\n      }\n\n      // Add extensions for data types\n      for (const [type, ext] of Object.entries(extensionForDataType)) {\n        if (node.isVariable && node.value.dataType.key === type) {\n          if (!isStandardTypeNode) {\n            node.renameTo(`${node.name}${ext}`);\n          }\n\n          // FIXME: Set dataType and mark as resolved\n        } else if (node.fileName.endsWith(ext)) {\n          callback(new Error(`Name conflict: ${node.nodeId} should not end with '${ext}'`));\n          return;\n        }\n      }\n\n      // Add extensions for array types\n      for (const [type, ext] of Object.entries(extensionForArrayType)) {\n        if (node.isVariable && node.value.arrayType.key === type) {\n          if (!isStandardTypeNode) {\n            node.renameTo(`${node.name}${ext}`);\n          }\n\n          // FIXME: Set arrayType and mark as resolved\n        } else if (node.fileName.endsWith(ext)) {\n          callback(new Error(`Name conflict: ${node.nodeId} should not end with '${ext}'`));\n          return;\n        }\n      }\n    }\n\n    // Compact mapping: Root source folders are AGENT, SYSTEM, ObjectTypes and VariableTypes\n    // FIXME: Make optional\n    const ignore = new Set([\n      58, // Objects -> Types -> BaseObjectType\n      62, // Objects -> Types -> BaseVariableType\n      85, // Objects\n      86, // Objects -> Types\n    ]);\n\n    for (let c = node; c && c.parent && !c._compactMappingApplied; c = c.parent) {\n      if (ignore.has(c.parent.id.value)) {\n        c.parent = c.parent.parent;\n        c = node;\n      }\n    }\n\n    Object.assign(node, {\n      _compactMappingApplied: true,\n    });\n\n    callback(null, node);\n  }\n\n  /**\n   * Writes an {@link AtviseFile} for each {@link Node} read.\n   * @param {Node} node The raw file.\n   * @param {string} encoding The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\n   * while transforming the read result or the resulting file.\n   */\n  transformFromFilesystem(node, encoding, callback) {\n    let isStandardTypeNode = false;\n\n    // Resolve standard type from extension\n    for (const [, { extension }] of Object.entries(standardTypes)) {\n      if (node.name.endsWith(extension)) {\n        isStandardTypeNode = true;\n\n        // FIXME: Set dataType and mark as resolved\n        // FIXME: Set typeDefinition and mark as resolved\n\n        node.renameTo(basename(node.name, extension));\n      }\n    }\n\n    // Resolve arrayType from extension\n    for (const [type, extension] of Object.entries(extensionForArrayType)) {\n      if (node.name.endsWith(extension) && !isStandardTypeNode) {\n        assert.equal(node.arrayType.key, type);\n\n        // FIXME: Set arrayType and mark as resolved\n\n        node.renameTo(basename(node.name, extension));\n      }\n    }\n\n    // Resolve dataType from extension\n    for (const [type, extension] of Object.entries(extensionForDataType)) {\n      if (node.name.endsWith(extension) && !isStandardTypeNode) {\n        assert.equal(node.dataType.key, type);\n\n        // FIXME: Set dataType and mark as resolved\n\n        node.renameTo(basename(node.name, extension));\n      }\n    }\n\n    return callback(null, node);\n  }\n\n  /**\n   * `true` as the mapping transformer should infer references from config files.\n   */\n  get transformsReferenceConfigFiles() {\n    return true;\n  }\n\n}\n"]}