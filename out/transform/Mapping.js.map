{"version":3,"sources":["../../src/transform/Mapping.js"],"names":["standardTypes","extension","dataType","DataType","ByteString","XmlElement","extensionForDataType","Boolean","key","SByte","Byte","Int16","UInt16","Int32","UInt32","Int64","UInt64","Float","Double","String","DateTime","Guid","NodeId","ExpandedNodeId","StatusCode","QualifiedName","LocalizedText","ExtensionObject","DataValue","Variant","DiagnosticInfo","extensionForArrayType","VariantArrayType","Array","Matrix","MappingTransformer","Transformer","constructor","args","_readReferenceFiles","transformFromDB","node","encoding","callback","fullyMapped","parentResolvesMetadata","typeDefinition","isStandardTypeNode","def","Object","entries","isVariable","renameTo","name","fileName","endsWith","Error","nodeId","type","ext","value","arrayType","ignore","Set","c","parent","_compactMappingApplied","has","id","assign","transformFromFilesystem","assert","equal","transformsReferenceConfigFiles"],"mappings":"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","sourcesContent":["import { basename } from 'path';\nimport assert from 'assert';\nimport { VariantArrayType, DataType } from 'node-opcua/lib/datamodel/variant';\nimport Transformer from '../lib/transform/Transformer';\n\n/**\n * Atvise specific types that need special extensions.\n * @type {Map<string, Object>}\n */\nconst standardTypes = {\n  'VariableTypes.ATVISE.HtmlHelp': {\n    extension: '.help.html',\n    dataType: DataType.ByteString,\n  },\n  'VariableTypes.ATVISE.TranslationTable': {\n    extension: '.locs.xml',\n    dataType: DataType.XmlElement,\n  },\n};\n\n/**\n * Extensions to use for {@link node-opcua~DataType}s.\n * @type {Map<string, string>}\n */\nconst extensionForDataType = {\n  [DataType.Boolean.key]: '.bool',\n  [DataType.SByte.key]: '.sbyte',\n  [DataType.Byte.key]: '.byte',\n  [DataType.Int16.key]: '.int16',\n  [DataType.UInt16.key]: '.uint16',\n  [DataType.Int32.key]: '.int32',\n  [DataType.UInt32.key]: '.uint32',\n  [DataType.Int64.key]: '.int64',\n  [DataType.UInt64.key]: '.uint64',\n  [DataType.Float.key]: '.float',\n  [DataType.Double.key]: '.double',\n  [DataType.String.key]: '.string',\n  [DataType.DateTime.key]: '.datetime',\n  [DataType.Guid.key]: '.guid',\n  // [DataType.ByteString.key]: '.bytestring',\n  [DataType.XmlElement.key]: '.xml',\n  [DataType.NodeId.key]: '.nodeid',\n  [DataType.ExpandedNodeId.key]: '.enodeid',\n  [DataType.StatusCode.key]: '.status',\n  [DataType.QualifiedName.key]: '.name',\n  [DataType.LocalizedText.key]: '.text',\n  [DataType.ExtensionObject.key]: '.obj',\n  [DataType.DataValue.key]: '.value',\n  [DataType.Variant.key]: '.variant',\n  [DataType.DiagnosticInfo.key]: '.info',\n};\n\n/**\n * Extensions to use for {@link node-opcua~VariantArrayType}s.\n * @type {Map<string, string>}\n */\nconst extensionForArrayType = {\n  [VariantArrayType.Array.key]: '.array',\n  [VariantArrayType.Matrix.key]: '.matrix',\n};\n\n/**\n * A Transformer that maps {@link ReadStream.ReadResult}s to {@link AtviseFile}s.\n */\nexport default class MappingTransformer extends Transformer {\n\n  /**\n   * Creates a new mapping transformer.\n   * @param {any[]} args The arguments passed to the {@link Transformer} constructor.\n   */\n  constructor(...args) {\n    super(...args);\n\n    /**\n     * Contents of the reference files read but not used yet.\n     * @type {Object}\n     */\n    this._readReferenceFiles = {};\n  }\n\n  /**\n   * Writes an {@link AtviseFile} for each {@link ReadStream.ReadResult} read. If a read file has a\n   * non-standard type (definition) an additional `rc` file is pushed holding this type.\n   * @param {Node} node The read result to create the file for.\n   * @param {string} encoding The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\n   * while transforming the read result or the resulting file.\n   */\n  transformFromDB(node, encoding, callback) {\n    if (!node.fullyMapped && !node.parentResolvesMetadata) { // Skip mapping for e.g. split files\n      const typeDefinition = node.typeDefinition;\n      let isStandardTypeNode = false;\n\n      // Add extensions for standard types\n      for (const [def, { extension }] of Object.entries(standardTypes)) {\n        if (node.isVariable && typeDefinition === def) {\n          node.renameTo(`${node.name}${extension}`);\n          isStandardTypeNode = true;\n\n          // FIXME: Set dataType and mark as resolved\n          // FIXME: Set typeDefinition and mark as resolved\n        } else if (node.fileName.endsWith(extension)) {\n          callback(new Error(`Name conflict: ${node.nodeId} should not end with '${extension}'`));\n          return;\n        }\n      }\n\n      // Add extensions for data types\n      for (const [type, ext] of Object.entries(extensionForDataType)) {\n        if (node.isVariable && node.value.dataType.key === type) {\n          if (!isStandardTypeNode) {\n            node.renameTo(`${node.name}${ext}`);\n          }\n\n          // FIXME: Set dataType and mark as resolved\n        } else if (node.fileName.endsWith(ext)) {\n          callback(new Error(`Name conflict: ${node.nodeId} should not end with '${ext}'`));\n          return;\n        }\n      }\n\n      // Add extensions for array types\n      for (const [type, ext] of Object.entries(extensionForArrayType)) {\n        if (node.isVariable && node.value.arrayType.key === type) {\n          if (!isStandardTypeNode) {\n            node.renameTo(`${node.name}${ext}`);\n          }\n\n          // FIXME: Set arrayType and mark as resolved\n        } else if (node.fileName.endsWith(ext)) {\n          callback(new Error(`Name conflict: ${node.nodeId} should not end with '${ext}'`));\n          return;\n        }\n      }\n    }\n\n    // Compact mapping: Root source folders are AGENT, SYSTEM, ObjectTypes and VariableTypes\n    // FIXME: Make optional\n    const ignore = new Set([\n      58, // Objects -> Types -> BaseObjectType\n      62, // Objects -> Types -> BaseVariableType\n      85, // Objects\n      86, // Objects -> Types\n    ]);\n\n    for (let c = node; c && c.parent && !c._compactMappingApplied; c = c.parent) {\n      if (ignore.has(c.parent.id.value)) {\n        c.parent = c.parent.parent;\n        c = node;\n      }\n    }\n\n    Object.assign(node, {\n      _compactMappingApplied: true,\n    });\n\n    callback(null, node);\n  }\n\n  /**\n   * Writes an {@link AtviseFile} for each {@link Node} read.\n   * @param {Node} node The raw file.\n   * @param {string} encoding The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\n   * while transforming the read result or the resulting file.\n   */\n  transformFromFilesystem(node, encoding, callback) {\n    let isStandardTypeNode = false;\n\n    // Resolve standard type from extension\n    for (const [, { extension }] of Object.entries(standardTypes)) {\n      if (node.name.endsWith(extension)) {\n        isStandardTypeNode = true;\n\n        // FIXME: Set dataType and mark as resolved\n        // FIXME: Set typeDefinition and mark as resolved\n\n        node.renameTo(basename(node.name, extension));\n      }\n    }\n\n    // Resolve arrayType from extension\n    for (const [type, extension] of Object.entries(extensionForArrayType)) {\n      if (node.name.endsWith(extension) && !isStandardTypeNode) {\n        assert.equal(node.arrayType.key, type);\n\n        // FIXME: Set arrayType and mark as resolved\n\n        node.renameTo(basename(node.name, extension));\n      }\n    }\n\n    // Resolve dataType from extension\n    for (const [type, extension] of Object.entries(extensionForDataType)) {\n      if (node.name.endsWith(extension) && !isStandardTypeNode) {\n        assert.equal(node.dataType.key, type);\n\n        // FIXME: Set dataType and mark as resolved\n\n        node.renameTo(basename(node.name, extension));\n      }\n    }\n\n    return callback(null, node);\n  }\n\n  /**\n   * `true` as the mapping transformer should infer references from config files.\n   */\n  get transformsReferenceConfigFiles() {\n    return true;\n  }\n\n}\n"],"file":"Mapping.js"}