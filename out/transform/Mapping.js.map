{"version":3,"sources":["../../src/transform/Mapping.js"],"names":["MappingTransformer","constructor","args","_readReferenceFiles","transformFromDB","readResult","encoding","callback","file","fromReadResult","parent","value","match","relativePath","nodeId","split","path","filePath","join","nodeClass","Variable","unmappedReferences","Object","assign","references","toParent","relative","HasTypeDefinition","keys","length","rc","clone","basename","contents","Buffer","from","JSON","stringify","push","e","message","debug","transformFromFilesystem","isDirectory","stem","slice","extname","config","parse","Error","refName","innerMatch","replace","atFile","cwd","base","getMetadata","_references","entries","reduce","result","type","refs","Array","isArray","map","v","transformsReferenceConfigFiles"],"mappings":";;;;;;AAAA;;AACA;;;;AACA;;AACA;;;;AACA;;;;AACA;;;;;;AAEA;;;AAGe,MAAMA,kBAAN,+BAA6C;;AAE1D;;;;AAIAC,cAAY,GAAGC,IAAf,EAAqB;AACnB,UAAM,GAAGA,IAAT;;AAEA;;;;AAIA,SAAKC,mBAAL,GAA2B,EAA3B;AACD;;AAED;;;;;;;;AAQAC,kBAAgBC,UAAhB,EAA4BC,QAA5B,EAAsCC,QAAtC,EAAgD;AAC9C,QAAI;AACF,YAAMC,OAAO,qBAAWC,cAAX,CAA0BJ,UAA1B,CAAb;;AAEA,UAAIA,WAAWK,MAAX,IAAqBL,WAAWK,MAAX,CAAkBC,KAAlB,CAAwBC,KAAxB,CAA8B,eAA9B,CAAzB,EAAyE;AACvE,cAAMC,eAAeR,WAAWS,MAAX,CAAkBH,KAAlB,CAAwBI,KAAxB,CAA8BV,WAAWK,MAAX,CAAkBC,KAAhD,EAAuD,CAAvD,CAArB;;AAEA,YAAIE,aAAa,CAAb,MAAoB,GAAxB,EAA6B;AAC3BL,eAAKQ,IAAL,GAAYR,KAAKQ,IAAL,CAAUD,KAAV,CAAiB,GAAE,gBAAKV,WAAWK,MAAX,CAAkBO,QAAvB,CAAiC,GAApD,EACTC,IADS,CACH,GAAEb,WAAWK,MAAX,CAAkBO,QAAS,SAD1B,CAAZ;AAED;AACF;;AAED,UAAIZ,WAAWc,SAAX,KAAyB,qBAAUC,QAAvC,EAAiD;AAC/C,cAAMC,qBAAqBC,OAAOC,MAAP,CAAc,EAAd,EAAkBf,KAAKgB,UAAvB,CAA3B;;AAEA,YAAIH,mBAAmBI,QAAnB,KAAgC,cAApC,EAAoD;AAClD,iBAAOJ,mBAAmBI,QAA1B;AACD;;AAED,YAAI,CAACjB,KAAKkB,QAAL,CAAcd,KAAd,CAAoB,SAApB,CAAL,EAAqC;AACnC,iBAAOS,mBAAmBM,iBAA1B;AACD;;AAED,YAAIL,OAAOM,IAAP,CAAYP,kBAAZ,EAAgCQ,MAApC,EAA4C;AAC1C,gBAAMC,KAAKtB,KAAKuB,KAAL,EAAX;;AAEAD,aAAGE,QAAH,GAAe,IAAGF,GAAGE,QAAS,OAA9B;;AAEAF,aAAGG,QAAH,GAAcC,OAAOC,IAAP,CAAYC,KAAKC,SAAL,CAAe;AACvCb,wBAAYH;AAD2B,WAAf,EAEvB,IAFuB,EAEjB,IAFiB,CAAZ,CAAd;;AAIA,eAAKiB,IAAL,CAAUR,EAAV;AACD;AACF;;AAEDvB,eAAS,IAAT,EAAeC,IAAf;AACD,KArCD,CAqCE,OAAO+B,CAAP,EAAU;AACV,wBAAOA,EAAEC,OAAF,KAAc,UAAd,GAA2B,OAA3B,GAAqC,MAA5C,EACG,iBAAgBnC,WAAWS,MAAX,CAAkBH,KAAM,KAAI4B,EAAEC,OAAQ,EADzD;AAGA,wBAAOC,KAAP,CAAaF,CAAb;;AAEAhC,eAAS,IAAT;AACD;AACF;;AAED;;;;;;;AAOAmC,0BAAwBlC,IAAxB,EAA8BF,QAA9B,EAAwCC,QAAxC,EAAkD;AAChD,QAAIC,KAAKmC,WAAL,EAAJ,EAAwB;AACtBpC,eAAS,IAAT;AACD,KAFD,MAEO,IAAIC,KAAKoC,IAAL,CAAU,CAAV,MAAiB,GAAjB,IAAwB,CAAC,qBAAUpC,KAAKoC,IAAL,CAAUC,KAAV,CAAgB,CAAhB,CAAV,CAA7B,EAA4D;AACjE,UAAIrC,KAAKsC,OAAL,KAAiB,OAArB,EAA8B;AAC5B,0BAAOL,KAAP,CAAa,eAAb,EAA8BjC,KAAKkB,QAAnC;AACAnB,iBAAS,IAAT;AACA;AACD;AACD,UAAI;AACF,cAAMwC,SAASX,KAAKY,KAAL,CAAWxC,KAAKyB,QAAhB,CAAf;AACA,aAAK9B,mBAAL,CAAyBK,KAAKoC,IAAL,CAAUC,KAAV,CAAgB,CAAhB,CAAzB,IAA+CE,MAA/C;AACD,OAHD,CAGE,OAAOR,CAAP,EAAU;AACV,YAAI/B,KAAKkB,QAAL,CAAcd,KAAd,CAAoB,SAApB,CAAJ,EAAoC;AAClCL,mBAAS,IAAI0C,KAAJ,CAAW,mCAAkCV,EAAEC,OAAQ,EAAvD,CAAT;AACA;AACD;;AAED,0BAAOC,KAAP,CAAa,eAAb,EAA8BjC,KAAKkB,QAAnC;AACD;;AAEDnB,eAAS,IAAT;AACD,KAnBM,MAmBA;AACL,UAAIS,OAAOR,KAAKQ,IAAhB;AACA,YAAMkC,UAAU1C,KAAKwB,QAArB;AACA,YAAMmB,aAAanC,KAAKJ,KAAL,CAAW,6CAAX,CAAnB;;AAEA,UAAIuC,UAAJ,EAAgB;AACdnC,eAAO,gBAAKmC,WAAW,CAAX,CAAL,EAAoBA,WAAW,CAAX,EAAcC,OAAd,CAAsB,QAAtB,EAAgC,GAAhC,CAApB,CAAP;AACD;;AAED,YAAMC,SAAS,yBAAe;AAC5BC,aAAK9C,KAAK8C,GADkB;AAE5BC,cAAM/C,KAAK+C,IAFiB;AAG5BvC,YAH4B;AAI5BiB,kBAAUzB,KAAKyB;AAJa,OAAf,CAAf;;AAOA,YAAMc,SAAS,KAAK5C,mBAAL,CAAyB+C,OAAzB,CAAf;AACA,UAAIH,MAAJ,EAAY;AACVM,eAAOG,WAAP,GADU,CACY;AACtBlC,eAAOC,MAAP,CAAc8B,OAAOI,WAArB,EACEnC,OAAOoC,OAAP,CAAeX,OAAOvB,UAAP,IAAqB,EAApC,EACGmC,MADH,CACU,CAACC,MAAD,EAAS,CAACC,IAAD,EAAOC,IAAP,CAAT,KAA0BxC,OAAOC,MAAP,CAAcqC,MAAd,EAAsB;AACtD,WAACC,IAAD,GAAQE,MAAMC,OAAN,CAAcF,IAAd,IAAsBA,KAAKG,GAAL,CAASC,KAAK,qBAAWA,CAAX,CAAd,CAAtB,GAAqD,qBAAWJ,IAAX;AADP,SAAtB,CADpC,EAGM,EAHN,CADF;;AAOA,eAAO,KAAK3D,mBAAL,CAAyB+C,OAAzB,CAAP;AACD,OAVD,MAUO,IAAI1C,KAAKkB,QAAL,CAAcd,KAAd,CAAoB,SAApB,CAAJ,EAAoC;AACzCL,iBAAS,IAAI0C,KAAJ,CAAW,4BAA2BC,OAAQ,oBAA9C,CAAT;AACA;AACD;;AAED3C,eAAS,IAAT,EAAe8C,MAAf;AACD;AACF;;AAED;;;AAGA,MAAIc,8BAAJ,GAAqC;AACnC,WAAO,IAAP;AACD;;AA9IyD;kBAAvCnE,kB","file":"Mapping.js","sourcesContent":["import { join } from 'path';\nimport Logger from 'gulplog';\nimport { NodeClass } from 'node-opcua';\nimport Transformer from '../lib/transform/Transformer';\nimport AtviseFile from '../lib/server/AtviseFile';\nimport NodeId from '../lib/model/opcua/NodeId';\n\n/**\n * A Transformer that maps {@link ReadStream.ReadResult}s to {@link AtviseFile}s.\n */\nexport default class MappingTransformer extends Transformer {\n\n  /**\n   * Creates a new mapping transformer.\n   * @param {any[]} args The arguments passed to the {@link Transformer} constructor.\n   */\n  constructor(...args) {\n    super(...args);\n\n    /**\n     * Contents of the reference files read but not used yet.\n     * @type {Object}\n     */\n    this._readReferenceFiles = {};\n  }\n\n  /**\n   * Writes an {@link AtviseFile} for each {@link ReadStream.ReadResult} read. If a read file has a\n   * non-standard type (definition) an additional `rc` file is pushed holding this type.\n   * @param {ReadStream.ReadResult} readResult The read result to create the file for.\n   * @param {string} encoding The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\n   * while transforming the read result or the resulting file.\n   */\n  transformFromDB(readResult, encoding, callback) {\n    try {\n      const file = AtviseFile.fromReadResult(readResult);\n\n      if (readResult.parent && readResult.parent.value.match(/\\.RESOURCES\\//)) {\n        const relativePath = readResult.nodeId.value.split(readResult.parent.value)[1];\n\n        if (relativePath[0] === '.') {\n          file.path = file.path.split(`${join(readResult.parent.filePath)}.`)\n            .join(`${readResult.parent.filePath}.inner/`);\n        }\n      }\n\n      if (readResult.nodeClass === NodeClass.Variable) {\n        const unmappedReferences = Object.assign({}, file.references);\n\n        if (unmappedReferences.toParent === 'HasComponent') {\n          delete unmappedReferences.toParent;\n        }\n\n        if (!file.relative.match(/\\.var\\./)) {\n          delete unmappedReferences.HasTypeDefinition;\n        }\n\n        if (Object.keys(unmappedReferences).length) {\n          const rc = file.clone();\n\n          rc.basename = `.${rc.basename}.json`;\n\n          rc.contents = Buffer.from(JSON.stringify({\n            references: unmappedReferences,\n          }, null, '  '));\n\n          this.push(rc);\n        }\n      }\n\n      callback(null, file);\n    } catch (e) {\n      Logger[e.message === 'no value' ? 'debug' : 'warn'](\n        `Unable to map ${readResult.nodeId.value}: ${e.message}`\n      );\n      Logger.debug(e);\n\n      callback(null);\n    }\n  }\n\n  /**\n   * Writes an {@link AtviseFile} for each {@link vinyl~File} read.\n   * @param {vinyl~File} file The raw file.\n   * @param {string} encoding The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\n   * while transforming the read result or the resulting file.\n   */\n  transformFromFilesystem(file, encoding, callback) {\n    if (file.isDirectory()) {\n      callback(null);\n    } else if (file.stem[0] === '.' && !NodeClass[file.stem.slice(1)]) {\n      if (file.extname !== '.json') {\n        Logger.debug('Ignoring file', file.relative);\n        callback(null);\n        return;\n      }\n      try {\n        const config = JSON.parse(file.contents);\n        this._readReferenceFiles[file.stem.slice(1)] = config;\n      } catch (e) {\n        if (file.relative.match(/\\.var\\./)) {\n          callback(new Error(`Failed to parse reference file: ${e.message}`));\n          return;\n        }\n\n        Logger.debug('Ignoring file', file.relative);\n      }\n\n      callback(null);\n    } else {\n      let path = file.path;\n      const refName = file.basename;\n      const innerMatch = path.match(/(.*[/\\\\]RESOURCES[/\\\\].*)(\\.inner)[/\\\\](.*)/);\n\n      if (innerMatch) {\n        path = join(innerMatch[1], innerMatch[3].replace(/[/\\\\]/g, '.'));\n      }\n\n      const atFile = new AtviseFile({\n        cwd: file.cwd,\n        base: file.base,\n        path,\n        contents: file.contents,\n      });\n\n      const config = this._readReferenceFiles[refName];\n      if (config) {\n        atFile.getMetadata(); // ensure #_getMetadata gets called\n        Object.assign(atFile._references,\n          Object.entries(config.references || {})\n            .reduce((result, [type, refs]) => Object.assign(result, {\n              [type]: Array.isArray(refs) ? refs.map(v => new NodeId(v)) : new NodeId(refs),\n            }), {})\n        );\n\n        delete this._readReferenceFiles[refName];\n      } else if (file.relative.match(/\\.var\\./)) {\n        callback(new Error(`Missing reference file, .${refName}.json should exist`));\n        return;\n      }\n\n      callback(null, atFile);\n    }\n  }\n\n  /**\n   * `true` as the mapping transformer should infer references from config files.\n   */\n  get transformsReferenceConfigFiles() {\n    return true;\n  }\n\n}\n"]}