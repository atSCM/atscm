{"version":3,"sources":["../../src/transform/Mapping.js"],"names":["MappingTransformer","constructor","args","_readReferenceFiles","transformFromDB","readResult","encoding","callback","file","fromReadResult","nodeClass","Variable","unmappedReferences","Object","assign","references","toParent","relative","match","HasTypeDefinition","keys","length","rc","clone","basename","contents","Buffer","from","JSON","stringify","push","e","message","nodeId","value","debug","transformFromFilesystem","isDirectory","stem","slice","extname","config","parse","Error","atFile","cwd","base","path","getMetadata","_references","entries","reduce","result","type","refs","Array","isArray","map","v"],"mappings":"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","file":"Mapping.js","sourcesContent":["import Logger from 'gulplog';\nimport { NodeClass } from 'node-opcua';\nimport Transformer from '../lib/transform/Transformer';\nimport AtviseFile from '../lib/server/AtviseFile';\nimport NodeId from '../lib/model/opcua/NodeId';\n\n/**\n * A Transformer that maps {@link ReadStream.ReadResult}s to {@link AtviseFile}s.\n */\nexport default class MappingTransformer extends Transformer {\n\n  /**\n   * Creates a new mapping transformer.\n   * @param {any[]} args The arguments passed to the {@link Transformer} constructor.\n   */\n  constructor(...args) {\n    super(...args);\n\n    /**\n     * Contents of the reference files read but not used yet.\n     * @type {Object}\n     */\n    this._readReferenceFiles = {};\n  }\n\n  /**\n   * Writes an {@link AtviseFile} for each {@link ReadStream.ReadResult} read. If a read file has a\n   * non-standard type (definition) an additional `rc` file is pushed holding this type.\n   * @param {ReadStream.ReadResult} readResult The read result to create the file for.\n   * @param {string} encoding The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\n   * while transforming the read result or the resulting file.\n   */\n  transformFromDB(readResult, encoding, callback) {\n    try {\n      const file = AtviseFile.fromReadResult(readResult);\n\n      if (readResult.nodeClass === NodeClass.Variable) {\n        const unmappedReferences = Object.assign({}, file.references);\n\n        if (unmappedReferences.toParent === 'HasComponent') {\n          delete unmappedReferences.toParent;\n        }\n\n        if (!file.relative.match(/\\.var\\./)) {\n          delete unmappedReferences.HasTypeDefinition;\n        }\n\n        if (Object.keys(unmappedReferences).length) {\n          const rc = file.clone();\n\n          rc.basename = `.${rc.basename}.json`;\n\n          rc.contents = Buffer.from(JSON.stringify({\n            references: unmappedReferences,\n          }, null, '  '));\n\n          this.push(rc);\n        }\n      }\n\n      callback(null, file);\n    } catch (e) {\n      Logger[e.message === 'no value' ? 'debug' : 'warn'](\n        `Unable to map ${readResult.nodeId.value}: ${e.message}`\n      );\n      Logger.debug(e);\n\n      callback(null);\n    }\n  }\n\n  /**\n   * Writes an {@link AtviseFile} for each {@link vinyl~File} read.\n   * @param {vinyl~File} file The raw file.\n   * @param {string} encoding The encoding used.\n   * @param {function(err: ?Error, data: ?AtviseFile)} callback Called with the error that occurred\n   * while transforming the read result or the resulting file.\n   */\n  transformFromFilesystem(file, encoding, callback) {\n    if (file.isDirectory()) {\n      callback(null);\n    } else if (file.stem[0] === '.' && !NodeClass[file.stem.slice(1)]) {\n      if (file.extname !== '.json') {\n        Logger.debug('Ignoring file', file.relative);\n        callback(null);\n        return;\n      }\n      try {\n        const config = JSON.parse(file.contents);\n        this._readReferenceFiles[file.stem.slice(1)] = config;\n      } catch (e) {\n        if (file.relative.match(/\\.var\\./)) {\n          callback(new Error(`Failed to parse reference file: ${e.message}`));\n          return;\n        }\n\n        Logger.debug('Ignoring file', file.relative);\n      }\n\n      callback(null);\n    } else {\n      const atFile = new AtviseFile({\n        cwd: file.cwd,\n        base: file.base,\n        path: file.path,\n        contents: file.contents,\n      });\n\n      const config = this._readReferenceFiles[file.basename];\n      if (config) {\n        atFile.getMetadata(); // ensure #_getMetadata gets called\n        Object.assign(atFile._references,\n          Object.entries(config.references || {})\n            .reduce((result, [type, refs]) => Object.assign(result, {\n              [type]: Array.isArray(refs) ? refs.map(v => new NodeId(v)) : new NodeId(refs),\n            }), {})\n        );\n\n        delete this._readReferenceFiles[file.basename];\n      } else if (file.relative.match(/\\.var\\./)) {\n        callback(new Error(`Missing reference file, .${file.basename}.json should exist`));\n        return;\n      }\n\n      callback(null, atFile);\n    }\n  }\n\n}\n"]}