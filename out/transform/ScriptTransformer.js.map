{"version":3,"sources":["../../src/transform/ScriptTransformer.js"],"names":["ScriptTransformer","shouldBeTransformed","file","isScript","isQuickDynamic","transformFromDB","enc","callback","decodeContents","err","results","document","findChild","warn","relative","config","metaTag","elements","forEach","child","type","name","icon","Object","assign","content","textContent","attributes","visible","Boolean","parseInt","title","description","paramTags","findChildren","length","parameters","push","codeNode","code","configFile","splitFile","contents","Buffer","from","JSON","stringify","scriptFile","createCombinedFile","files","lastFile","parse","toString","e","Error","message","result","meta","text","undefined","cdata","script","combineFiles","keys","map","ext","encodeContents","encodeErr","xmlString"],"mappings":"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","file":"ScriptTransformer.js","sourcesContent":["import Logger from 'gulplog';\nimport XMLTransformer from '../lib/transform/XMLTransformer';\n\n/**\n * A transformer that splits atvise scripts and quick dynamics into a code file and a .json file\n * containing parameters and metadata.\n */\nexport default class ScriptTransformer extends XMLTransformer {\n\n  /**\n   * Returns `true` for all files containing script code or quick dynamics.\n   * @param {AtviseFile} file The file to check.\n   * @return {boolean} `true` for all files containing script code or quick dynamics.\n   */\n  shouldBeTransformed(file) {\n    return file.isScript || file.isQuickDynamic;\n  }\n\n  /**\n   * Splits any read files containing scripts or quick dynamics into their JavaScript sources,\n   * alongside with a json file containing parameters and metadata.\n   * @param {AtviseFile} file The script file to split.\n   * @param {string} enc The encoding used.\n   * @param {function(err: Error, file: AtviseFile)} callback Called with the error that occured\n   * while transforming the script, or the file passed through.\n   */\n  transformFromDB(file, enc, callback) {\n    this.decodeContents(file, (err, results) => {\n      if (err) {\n        callback(err);\n      } else {\n        const document = results && this.findChild(results, 'script');\n\n        if (!document) {\n          Logger.warn(`Empty document at ${file.relative}`);\n        }\n\n        const config = {};\n\n        // Extract metadata\n        const metaTag = this.findChild(document, 'metadata');\n        if (metaTag && metaTag.elements) {\n          // TODO: Warn on multiple metadata tags\n          metaTag.elements.forEach(child => {\n            if (child.type === 'element') {\n              if (child.name === 'icon') { // - Icon\n                config.icon = Object.assign({\n                  content: this.textContent(child) || '',\n                }, child.attributes);\n              } else if (child.name === 'visible') { // - Visible\n                config.visible = Boolean(parseInt(this.textContent(child), 10));\n              } else if (child.name === 'title') {\n                config.title = this.textContent(child);\n              } else if (child.name === 'description') {\n                config.description = this.textContent(child);\n              } else {\n                Logger.warn(`Unknown metadata element '${child.name}' at ${file.relative}`);\n              }\n            }\n          });\n        }\n\n        // Extract Parameters\n        const paramTags = this.findChildren(document, 'parameter');\n        if (paramTags.length) {\n          config.parameters = [];\n          paramTags.forEach(({ attributes }) => config.parameters.push(attributes));\n        }\n\n        // Extract JavaScript\n        const codeNode = this.findChild(document, 'code');\n        const code = this.textContent(codeNode) || '';\n\n        // Write config file\n        const configFile = ScriptTransformer.splitFile(file, '.json');\n        configFile.contents = Buffer.from(JSON.stringify(config, null, '  '));\n        this.push(configFile);\n\n        // Write script file\n        const scriptFile = ScriptTransformer.splitFile(file, '.js');\n        scriptFile.contents = Buffer.from(code);\n        this.push(scriptFile);\n\n        callback(null);\n      }\n    });\n  }\n\n  /**\n   * Creates a script from the collected files.\n   * @param {Map<String, AtviseFile>} files The collected files, stored against their extension.\n   * @param {AtviseFile} lastFile The last file read. *Used for error messages only*.\n   * @param {function(err: ?Error, data: vinyl~File)} callback Called with the error that occured\n   * while creating the script or the resulting file.\n   */\n  createCombinedFile(files, lastFile, callback) {\n    const configFile = files['.json'];\n    let config = {};\n\n    if (configFile) {\n      try {\n        config = JSON.parse(configFile.contents.toString());\n      } catch (e) {\n        callback(new Error(`Error parsing JSON in ${configFile.relative}: ${e.message}`));\n        return;\n      }\n    }\n\n    const scriptFile = files['.js'];\n    let code = '';\n\n    if (scriptFile) {\n      code = scriptFile.contents.toString();\n    }\n\n    const document = {\n      type: 'element',\n      name: 'script',\n      elements: [],\n    };\n\n    const result = {\n      elements: [\n        document,\n      ],\n    };\n\n    // Insert metadata\n    if (lastFile.isQuickDynamic) {\n      const meta = [];\n\n      // - Icon\n      if (config.icon) {\n        const icon = config.icon.content;\n        delete config.icon.content;\n\n        meta.push({\n          type: 'element',\n          name: 'icon',\n          attributes: config.icon,\n          elements: [\n            {\n              type: 'text',\n              text: icon,\n            },\n          ],\n        });\n      }\n\n      // - Other fields\n      if (config.visible !== undefined) {\n        meta.push({\n          type: 'element',\n          name: 'visible',\n          elements: [\n            {\n              type: 'text',\n              text: config.visible ? 1 : 0,\n            },\n          ],\n        });\n      }\n\n      if (config.title !== undefined) {\n        meta.push({\n          type: 'element',\n          name: 'title',\n          elements: [\n            { type: 'text', text: config.title },\n          ],\n        });\n      }\n\n      if (config.description !== undefined) {\n        meta.push({\n          type: 'element',\n          name: 'description',\n          elements: [\n            { type: 'text', text: config.description },\n          ],\n        });\n      }\n\n      document.elements.push({\n        type: 'element',\n        name: 'metadata',\n        elements: meta,\n      });\n      // result.script.metadata = meta;\n    }\n\n    // Insert parameters\n    if (config.parameters) {\n      config.parameters.forEach(attributes => {\n        document.elements.push({\n          type: 'element',\n          name: 'parameter',\n          attributes,\n        });\n      });\n    }\n\n    // Insert script code\n    document.elements.push({\n      type: 'element',\n      name: 'code',\n      elements: [\n        {\n          type: 'cdata',\n          cdata: code,\n        },\n      ],\n    });\n\n    const script = ScriptTransformer.combineFiles(\n      Object.keys(files).map(ext => files[ext]),\n      '.xml'\n    );\n\n    this.encodeContents(result, (encodeErr, xmlString) => {\n      if (encodeErr) {\n        callback(encodeErr);\n      } else {\n        script.contents = Buffer.from(xmlString);\n\n        callback(null, script);\n      }\n    });\n  }\n\n}\n"]}