{"version":3,"sources":["../../src/transform/ScriptTransformer.js"],"names":["ScriptTransformer","shouldBeTransformed","file","isScript","isQuickDynamic","transformFromDB","enc","callback","decodeContents","err","results","script","undefined","warn","relative","document","config","code","tagNotEmpty","metadata","meta","icon","$","content","_","visible","Boolean","title","description","parameter","parameters","forEach","param","push","configFile","splitFile","contents","Buffer","from","JSON","stringify","scriptFile","createCombinedFile","files","lastFile","parse","toString","e","Error","message","result","map","forceCData","combineFiles","Object","keys","ext","encodeContents","encodeErr","xmlString"],"mappings":";;;;;;AAAA;;;;AACA;;;;;;AAEA;;;;AAIe,MAAMA,iBAAN,kCAA+C;;AAE5D;;;;;AAKAC,sBAAoBC,IAApB,EAA0B;AACxB,WAAOA,KAAKC,QAAL,IAAiBD,KAAKE,cAA7B;AACD;;AAED;;;;;;;;AAQAC,kBAAgBH,IAAhB,EAAsBI,GAAtB,EAA2BC,QAA3B,EAAqC;AACnC,SAAKC,cAAL,CAAoBN,IAApB,EAA0B,CAACO,GAAD,EAAMC,OAAN,KAAkB;AAC1C,UAAID,GAAJ,EAAS;AACPF,iBAASE,GAAT;AACD,OAFD,MAEO;AACL,YAAI,CAACC,OAAD,IAAYA,QAAQC,MAAR,KAAmBC,SAAnC,EAA8C;AAC5C,4BAAOC,IAAP,CAAa,qBAAoBX,KAAKY,QAAS,EAA/C;AACD;;AAED,cAAMC,WAAWL,WAAWA,QAAQC,MAAnB,GAA4BD,QAAQC,MAApC,GAA6C,EAA9D;;AAEA,cAAMK,SAAS,EAAf;AACA,YAAIC,OAAO,EAAX;;AAEA;AACA,YAAI,KAAKC,WAAL,CAAiBH,SAASI,QAA1B,CAAJ,EAAyC;AACvC;;AAEA,gBAAMC,OAAOL,SAASI,QAAT,CAAkB,CAAlB,CAAb;;AAEA;AACA,cAAI,KAAKD,WAAL,CAAiBE,KAAKC,IAAtB,CAAJ,EAAiC;AAC/B,kBAAMA,OAAOD,KAAKC,IAAL,CAAU,CAAV,CAAb;AACAL,mBAAOK,IAAP,GAAcA,KAAKC,CAAL,IAAU,EAAxB;AACAN,mBAAOK,IAAP,CAAYE,OAAZ,GAAsBF,KAAKG,CAAL,IAAU,EAAhC;AACD;;AAED;AACA,cAAI,KAAKN,WAAL,CAAiBE,KAAKK,OAAtB,CAAJ,EAAoC;AAClCT,mBAAOS,OAAP,GAAiBC,QAAQN,KAAKK,OAAL,CAAa,CAAb,CAAR,CAAjB;AACD;;AAED;AACA,cAAI,KAAKP,WAAL,CAAiBE,KAAKO,KAAtB,CAAJ,EAAkC;AAChCX,mBAAOW,KAAP,GAAeP,KAAKO,KAAL,CAAW,CAAX,CAAf;AACD;;AAED;AACA,cAAI,KAAKT,WAAL,CAAiBE,KAAKQ,WAAtB,CAAJ,EAAwC;AACtCZ,mBAAOY,WAAP,GAAqBR,KAAKQ,WAAL,CAAiB,CAAjB,CAArB;AACD;AACF;;AAED;AACA,YAAI,KAAKV,WAAL,CAAiBH,SAASc,SAA1B,CAAJ,EAA0C;AACxCb,iBAAOc,UAAP,GAAoB,EAApB;AACAf,mBAASc,SAAT,CAAmBE,OAAnB,CAA2BC,SAAShB,OAAOc,UAAP,CAAkBG,IAAlB,CAAuBD,MAAMV,CAA7B,CAApC;AACD;;AAED;AACA,YAAI,KAAKJ,WAAL,CAAiBH,SAASE,IAA1B,CAAJ,EAAqC;AACnCA,iBAAOF,SAASE,IAAT,CAAc,CAAd,CAAP;AACD;;AAED;AACA,cAAMiB,aAAalC,kBAAkBmC,SAAlB,CAA4BjC,IAA5B,EAAkC,OAAlC,CAAnB;AACAgC,mBAAWE,QAAX,GAAsBC,OAAOC,IAAP,CAAYC,KAAKC,SAAL,CAAexB,MAAf,EAAuB,IAAvB,EAA6B,IAA7B,CAAZ,CAAtB;AACA,aAAKiB,IAAL,CAAUC,UAAV;;AAEA;AACA,cAAMO,aAAazC,kBAAkBmC,SAAlB,CAA4BjC,IAA5B,EAAkC,KAAlC,CAAnB;AACAuC,mBAAWL,QAAX,GAAsBC,OAAOC,IAAP,CAAYrB,IAAZ,CAAtB;AACA,aAAKgB,IAAL,CAAUQ,UAAV;;AAEAlC,iBAAS,IAAT;AACD;AACF,KAjED;AAkED;;AAED;;;;;;;AAOAmC,qBAAmBC,KAAnB,EAA0BC,QAA1B,EAAoCrC,QAApC,EAA8C;AAC5C,UAAM2B,aAAaS,MAAM,OAAN,CAAnB;AACA,QAAI3B,SAAS,EAAb;;AAEA,QAAIkB,UAAJ,EAAgB;AACd,UAAI;AACFlB,iBAASuB,KAAKM,KAAL,CAAWX,WAAWE,QAAX,CAAoBU,QAApB,EAAX,CAAT;AACD,OAFD,CAEE,OAAOC,CAAP,EAAU;AACVxC,iBAAS,IAAIyC,KAAJ,CAAW,yBAAwBd,WAAWpB,QAAS,KAAIiC,EAAEE,OAAQ,EAArE,CAAT;AACA;AACD;AACF;;AAED,UAAMR,aAAaE,MAAM,KAAN,CAAnB;AACA,QAAI1B,OAAO,EAAX;;AAEA,QAAIwB,UAAJ,EAAgB;AACdxB,aAAOwB,WAAWL,QAAX,CAAoBU,QAApB,EAAP;AACD;;AAED,UAAMI,SAAS;AACbvC,cAAQ;AADK,KAAf;;AAIA;AACA,QAAIiC,SAASxC,cAAb,EAA6B;AAC3B,YAAMgB,OAAO,EAAb;;AAEA;AACA,UAAIJ,OAAOK,IAAX,EAAiB;AACf,cAAMA,OAAOL,OAAOK,IAAP,CAAYE,OAAzB;AACA,eAAOP,OAAOK,IAAP,CAAYE,OAAnB;;AAEAH,aAAKC,IAAL,GAAY;AACVC,aAAGN,OAAOK,IADA;AAEVG,aAAGH;AAFO,SAAZ;AAID;;AAED;AACA,UAAIL,OAAOS,OAAP,KAAmBb,SAAvB,EAAkC;AAChCQ,aAAKK,OAAL,GAAeT,OAAOS,OAAP,GAAiB,CAAjB,GAAqB,CAApC;AACD;;AAED,UAAIT,OAAOW,KAAP,KAAiBf,SAArB,EAAgC;AAC9BQ,aAAKO,KAAL,GAAaX,OAAOW,KAApB;AACD;;AAED,UAAIX,OAAOY,WAAP,KAAuBhB,SAA3B,EAAsC;AACpCQ,aAAKQ,WAAL,GAAmBZ,OAAOY,WAA1B;AACD;;AAEDsB,aAAOvC,MAAP,CAAcQ,QAAd,GAAyBC,IAAzB;AACD;;AAED;AACA8B,WAAOvC,MAAP,CAAckB,SAAd,GAA0Bb,OAAOc,UAAP,GACxBd,OAAOc,UAAP,CAAkBqB,GAAlB,CAAsBnB,UAAU,EAAEV,GAAGU,KAAL,EAAV,CAAtB,CADwB,GAExB,EAFF;;AAIAkB,WAAOvC,MAAP,CAAcM,IAAd,GAAqBjB,kBAAkBoD,UAAlB,CAA6BnC,IAA7B,CAArB;;AAEA,UAAMN,SAASX,kBAAkBqD,YAAlB,CACbC,OAAOC,IAAP,CAAYZ,KAAZ,EAAmBQ,GAAnB,CAAuBK,OAAOb,MAAMa,GAAN,CAA9B,CADa,EAEb,MAFa,CAAf;;AAKA,SAAKC,cAAL,CAAoBP,MAApB,EAA4B,CAACQ,SAAD,EAAYC,SAAZ,KAA0B;AACpD,UAAID,SAAJ,EAAe;AACbnD,iBAASmD,SAAT;AACD,OAFD,MAEO;AACL/C,eAAOyB,QAAP,GAAkBC,OAAOC,IAAP,CAAYqB,SAAZ,CAAlB;;AAEApD,iBAAS,IAAT,EAAeI,MAAf;AACD;AACF,KARD;AASD;;AA3K2D;kBAAzCX,iB","file":"ScriptTransformer.js","sourcesContent":["import Logger from 'gulplog';\nimport XMLTransformer from '../lib/transform/XMLTransformer';\n\n/**\n * A transformer that splits atvise scripts and quick dynamics into a code file and a .json file\n * containing parameters and metadata.\n */\nexport default class ScriptTransformer extends XMLTransformer {\n\n  /**\n   * Returns `true` for all files containing script code or quick dynamics.\n   * @param {AtviseFile} file The file to check.\n   * @return {boolean} `true` for all files containing script code or quick dynamics.\n   */\n  shouldBeTransformed(file) {\n    return file.isScript || file.isQuickDynamic;\n  }\n\n  /**\n   * Splits any read files containing scripts or quick dynamics into their JavaScript sources,\n   * alongside with a json file containing parameters and metadata.\n   * @param {AtviseFile} file The script file to split.\n   * @param {string} enc The encoding used.\n   * @param {function(err: Error, file: AtviseFile)} callback Called with the error that occured\n   * while transforming the script, or the file passed through.\n   */\n  transformFromDB(file, enc, callback) {\n    this.decodeContents(file, (err, results) => {\n      if (err) {\n        callback(err);\n      } else {\n        if (!results || results.script === undefined) {\n          Logger.warn(`Empty document at ${file.relative}`);\n        }\n\n        const document = results && results.script ? results.script : {};\n\n        const config = {};\n        let code = '';\n\n        // Extract metadata\n        if (this.tagNotEmpty(document.metadata)) {\n          // TODO: Warn on multiple metadata tags\n\n          const meta = document.metadata[0];\n\n          // - Icon\n          if (this.tagNotEmpty(meta.icon)) {\n            const icon = meta.icon[0];\n            config.icon = icon.$ || {};\n            config.icon.content = icon._ || '';\n          }\n\n          // - Visible\n          if (this.tagNotEmpty(meta.visible)) {\n            config.visible = Boolean(meta.visible[0]);\n          }\n\n          // - Title\n          if (this.tagNotEmpty(meta.title)) {\n            config.title = meta.title[0];\n          }\n\n          // - Description\n          if (this.tagNotEmpty(meta.description)) {\n            config.description = meta.description[0];\n          }\n        }\n\n        // Extract Parameters\n        if (this.tagNotEmpty(document.parameter)) {\n          config.parameters = [];\n          document.parameter.forEach(param => config.parameters.push(param.$));\n        }\n\n        // Extract JavaScript\n        if (this.tagNotEmpty(document.code)) {\n          code = document.code[0];\n        }\n\n        // Write config file\n        const configFile = ScriptTransformer.splitFile(file, '.json');\n        configFile.contents = Buffer.from(JSON.stringify(config, null, '  '));\n        this.push(configFile);\n\n        // Write script file\n        const scriptFile = ScriptTransformer.splitFile(file, '.js');\n        scriptFile.contents = Buffer.from(code);\n        this.push(scriptFile);\n\n        callback(null);\n      }\n    });\n  }\n\n  /**\n   * Creates a script from the collected files.\n   * @param {Map<String, AtviseFile>} files The collected files, stored against their extension.\n   * @param {AtviseFile} lastFile The last file read. *Used for error messages only*.\n   * @param {function(err: ?Error, data: vinyl~File)} callback Called with the error that occured\n   * while creating the script or the resulting file.\n   */\n  createCombinedFile(files, lastFile, callback) {\n    const configFile = files['.json'];\n    let config = {};\n\n    if (configFile) {\n      try {\n        config = JSON.parse(configFile.contents.toString());\n      } catch (e) {\n        callback(new Error(`Error parsing JSON in ${configFile.relative}: ${e.message}`));\n        return;\n      }\n    }\n\n    const scriptFile = files['.js'];\n    let code = '';\n\n    if (scriptFile) {\n      code = scriptFile.contents.toString();\n    }\n\n    const result = {\n      script: { },\n    };\n\n    // Insert metadata\n    if (lastFile.isQuickDynamic) {\n      const meta = {};\n\n      // - Icon\n      if (config.icon) {\n        const icon = config.icon.content;\n        delete config.icon.content;\n\n        meta.icon = {\n          $: config.icon,\n          _: icon,\n        };\n      }\n\n      // - Other fields\n      if (config.visible !== undefined) {\n        meta.visible = config.visible ? 1 : 0;\n      }\n\n      if (config.title !== undefined) {\n        meta.title = config.title;\n      }\n\n      if (config.description !== undefined) {\n        meta.description = config.description;\n      }\n\n      result.script.metadata = meta;\n    }\n\n    // Insert parameters\n    result.script.parameter = config.parameters ?\n      config.parameters.map(param => ({ $: param })) :\n      [];\n\n    result.script.code = ScriptTransformer.forceCData(code);\n\n    const script = ScriptTransformer.combineFiles(\n      Object.keys(files).map(ext => files[ext]),\n      '.xml'\n    );\n\n    this.encodeContents(result, (encodeErr, xmlString) => {\n      if (encodeErr) {\n        callback(encodeErr);\n      } else {\n        script.contents = Buffer.from(xmlString);\n\n        callback(null, script);\n      }\n    });\n  }\n\n}\n"]}