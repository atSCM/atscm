{"version":3,"sources":["../../src/util/fs.js"],"names":["getStat","path","Promise","resolve","reject","err","stats","validateDirectoryExists","directoryPath","then","isDirectory","Error","stat"],"mappings":";;;;;;;;AAAA;;AACA;;AAEA;;;;;;AAMO,SAASA,OAAT,CAAiBC,IAAjB,EAAuB;AAC5B,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,kBAAK,mBAAYH,IAAZ,CAAL,EAAwB,CAACI,GAAD,EAAMC,KAAN,KAAgB;AACtC,UAAID,GAAJ,EAAS;AACPD,QAAAA,MAAM,CAACC,GAAD,CAAN;AACD,OAFD,MAEO;AACLF,QAAAA,OAAO,CAACG,KAAD,CAAP;AACD;AACF,KAND;AAOD,GARM,CAAP;AASD;AAED;;;;;;;;AAMO,SAASC,uBAAT,CAAiCC,aAAjC,EAAgD;AACrD,SAAOR,OAAO,CAACQ,aAAD,CAAP,CAAuBC,IAAvB,CAA6BH,KAAD,IAAW;AAC5C,QAAI,CAACA,KAAK,CAACI,WAAN,EAAL,EAA0B;AACxB,YAAM,IAAIC,KAAJ,CAAW,GAAE,mBAAYH,aAAZ,CAA2B,qBAAxC,CAAN;AACD;;AAED,WAAOI,QAAP;AACD,GANM,CAAP;AAOD","sourcesContent":["import { resolve as resolvePath } from 'path';\nimport { stat } from 'fs';\n\n/**\n * Returns the {@link fs~Stats} for a path.\n * @param {string} path The path to look at.\n * @return {Promise<fs~Stats, Error>} Fulfilled with the requested stats or rejected with the error\n * that occurred.\n */\nexport function getStat(path) {\n  return new Promise((resolve, reject) => {\n    stat(resolvePath(path), (err, stats) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(stats);\n      }\n    });\n  });\n}\n\n/**\n * Checks it a given path holds a directory and returns it's {@link fs~Stats} if found.\n * @param {string} directoryPath The path to look at.\n * @return {Promise<fs~Stats, Error>} Fulfilled with the directory's stats or rejected with the\n * error that occurred.\n */\nexport function validateDirectoryExists(directoryPath) {\n  return getStat(directoryPath).then((stats) => {\n    if (!stats.isDirectory()) {\n      throw new Error(`${resolvePath(directoryPath)} is not a directory`);\n    }\n\n    return stat;\n  });\n}\n"],"file":"fs.js"}