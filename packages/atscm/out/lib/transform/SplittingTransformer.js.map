{"version":3,"sources":["../../../src/lib/transform/SplittingTransformer.js"],"names":["SplittingTransformer","PartialTransformer","extension","Error","sourceExtensions","splitFile","node","newExtension","Object","assign","fullyMapped","value","noWrite","createChild","transformFromDB","context","renameTo","name","constructor","readNodeFile","shouldBeTransformed","undefined","combineNodes","sourceNodes","_combineNodes","transformFromFilesystem","hasExtension","fileName","split","relative","regExp","RegExp","join","sourceFiles","childFiles","children","reduce","current","f","match","push","path","includes","Promise","all","map","readNode","tree","parent","result","n"],"mappings":"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","sourcesContent":["import { extname, basename, join } from 'path';\nimport { readdir } from 'fs-extra';\nimport { escapeForRegExp } from '../regexp';\nimport PartialTransformer from './PartialTransformer.js';\n\n/**\n * A transformer that splits a node into multiple source nodes when pulling.\n */\nexport default class SplittingTransformer extends PartialTransformer {\n  /**\n   * The extension to add to container node names when they are pulled.\n   * @abstract\n   * @type {string}\n   */\n  static get extension() {\n    throw new Error('Must be implemented by all subclasses');\n  }\n\n  /**\n   * The source file extensions to allow.\n   * @abstract\n   * @type {string[]}\n   */\n  static get sourceExtensions() {\n    throw new Error('Must be implemented by all subclasses');\n  }\n\n  /**\n   * Splits a {@link Node}: The resulting is a clone of the input file, with a different path.\n   * @param {Node} node The file to split.\n   * @param {?string} newExtension The extension the resulting file gets.\n   * @return {Node} The resulting node.\n   */\n  static splitFile(node, newExtension) {\n    Object.assign(node, {\n      fullyMapped: true,\n      value: Object.assign(node.value, {\n        noWrite: true,\n      }),\n    });\n\n    return node.createChild({ extension: newExtension });\n  }\n\n  /**\n   * Renames a container node, should be called by all subclasses.\n   * @param {BrowsedNode} node A container node.\n   * @param {any} context The tranform context.\n   */\n  // eslint-disable-next-line no-unused-vars\n  async transformFromDB(node, context) {\n    node.renameTo(`${node.name}${this.constructor.extension}`);\n  }\n\n  /**\n   * Returns `false` for all container nodes, so they don't get read.\n   * @param {BrowsedNode} node The node to check.\n   * @return {?boolean} If the node should be read.\n   */\n  readNodeFile(node) {\n    return this.shouldBeTransformed(node) ? false : undefined;\n  }\n\n  /**\n   * Combines the container node and the source nodes to one single node.\n   * @abstract\n   * @param {BrowsedNode} node The container node.\n   * @param {Map<string, BrowsedNode>} sourceNodes The source nodes.\n   * @param {any} context The current context.\n   */\n  // eslint-disable-next-line no-unused-vars\n  combineNodes(node, sourceNodes, context) {\n    throw new Error('Must be implemented by all subclasses');\n  }\n\n  /**\n   * Combines the container node and the source nodes to one single node by calling\n   * {@link SplittingTransformer#combineNodes}.\n   * @param {BrowsedNode} node The container node.\n   * @param {{ [extension: string]: BrowedNode }} sourceNodes The source nodes.\n   * @param {any} context The current context.\n   */\n  _combineNodes(node, sourceNodes, context) {\n    this.combineNodes(node, sourceNodes, context);\n    node.renameTo(basename(node.name, this.constructor.extension));\n  }\n\n  /**\n   * Reads a given container nodes source nodes and combines them.\n   * @param {BrowsedNode} node The node to transform.\n   * @param {Object} context The browser context.\n   */\n  async transformFromFilesystem(node, context) {\n    if (!this.shouldBeTransformed(node)) {\n      return;\n    }\n\n    const [name, hasExtension] = node.fileName.split(this.constructor.extension);\n\n    if (hasExtension !== '') {\n      // FIXME: Remove\n      throw new Error(`${node.relative} shouldn't be transformed`);\n    }\n\n    const regExp = new RegExp(\n      `^\\\\.${escapeForRegExp(name)}(${this.constructor.sourceExtensions.join('|')})\\\\.json$`\n    );\n\n    // Find source files an child definition files\n    const sourceFiles = [];\n    const childFiles = [];\n\n    const children = (await readdir(node.relative)).reduce((current, f) => {\n      if (f.match(regExp)) {\n        sourceFiles.push(f);\n      } else if (f.match(/^\\..*\\.json$/)) {\n        // Other definition file -> child node\n        current.push({ name: f, path: join(node.relative, f) });\n        childFiles.push(f);\n      } else if (!sourceFiles.includes(`.${f}.json`) && !childFiles.includes(`.${f}.json`)) {\n        // This might be a child object's folder...\n        current.push({ name: f, path: join(node.relative, f) });\n      }\n\n      return current;\n    }, []);\n\n    // Manually set node.children for the container as source browser only handles definition files\n    Object.assign(node, { children });\n\n    const sourceNodes = await Promise.all(\n      sourceFiles.map((f) =>\n        context.readNode({\n          path: join(node.relative, f),\n          tree: { parent: node },\n        })\n      )\n    );\n\n    this._combineNodes(\n      node,\n      sourceNodes.reduce(\n        (result, n) =>\n          Object.assign(result, {\n            [extname(n.fileName)]: n,\n          }),\n        {}\n      ),\n      context\n    );\n  }\n}\n"],"file":"SplittingTransformer.js"}