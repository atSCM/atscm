{"version":3,"sources":["../../../src/lib/server/Stream.js"],"names":["Stream","objectMode","constructor","options","_keepSessionAlive","keepSessionAlive","Session","create","then","session","emit","catch","err","_flush","callback","close"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEA;;;AAGe,MAAMA,MAAN,SAAqB,mBAAmB;AAAEC,EAAAA,UAAU,EAAE;AAAd,CAAnB,CAArB,CAA8D;AAC3E;;;;;;;;;AASAC,EAAAA,WAAW,CAACC,OAAO,GAAG,EAAX,EAAe;AACxB,UAAMA,OAAN;AAEA;;;;;AAIA,SAAKC,iBAAL,GAAyBD,OAAO,CAACE,gBAAR,IAA4B,KAArD;;AAEAC,qBAAQC,MAAR,GACGC,IADH,CACSC,OAAD,IAAc,KAAKA,OAAL,GAAeA,OADrC,EAEGD,IAFH,CAESC,OAAD,IAAa,KAAKC,IAAL,CAAU,cAAV,EAA0BD,OAA1B,CAFrB,EAGGE,KAHH,CAGUC,GAAD,IAAS,KAAKF,IAAL,CAAU,OAAV,EAAmBE,GAAnB,CAHlB;AAID;AAED;;;;;;AAIAC,EAAAA,MAAM,CAACC,QAAD,EAAW;AACf,QAAI,KAAKL,OAAL,IAAgB,CAAC,KAAKL,iBAA1B,EAA6C;AAC3CE,uBAAQS,KAAR,CAAc,KAAKN,OAAnB,EACGD,IADH,CACQ,MAAMM,QAAQ,EADtB,EAEGH,KAFH,CAEUC,GAAD,IAASE,QAAQ,CAACF,GAAD,CAF1B;AAGD,KAJD,MAIO;AACLE,MAAAA,QAAQ;AACT;AACF;;AArC0E","sourcesContent":["import { ctor as throughStreamClass } from 'through2';\nimport Session from './Session';\n\n/**\n * An object transform stream connected to atvise server.\n */\nexport default class Stream extends throughStreamClass({ objectMode: true }) {\n  /**\n   * Creates a new Stream and starts opening a new session to atvise server.\n   * @param {Object} [options] The options to use. See the through2 documentation for details.\n   * @param {boolean} [options.keepSessionAlive=false] If the ativse server session should be closed\n   * one the stream ends.\n   * @emits {Session} Emits an `session-open` event once the session is open, passing the Session\n   * instance.\n   * @see https://github.Com/rvagg/through2#options\n   */\n  constructor(options = {}) {\n    super(options);\n\n    /**\n     * `true` if the stream's atvise server session should be kept alive once the stream ends.\n     * @type {Boolean}\n     */\n    this._keepSessionAlive = options.keepSessionAlive || false;\n\n    Session.create()\n      .then((session) => (this.session = session))\n      .then((session) => this.emit('session-open', session))\n      .catch((err) => this.emit('error', err));\n  }\n\n  /**\n   * Called just before the stream is closed: Closes the open session.\n   * @param {function(err: ?Error, data: Object)} callback Called once the session is closed.\n   */\n  _flush(callback) {\n    if (this.session && !this._keepSessionAlive) {\n      Session.close(this.session)\n        .then(() => callback())\n        .catch((err) => callback(err));\n    } else {\n      callback();\n    }\n  }\n}\n"],"file":"Stream.js"}