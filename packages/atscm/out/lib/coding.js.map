{"version":3,"sources":["../../src/lib/coding.js"],"names":["asIs","b","mapPropertyAs","map","obj","key","dataType","Object","assign","toRawValue","DataType","Null","StatusCode","name","QualifiedName","namespaceIndex","LocalizedText","text","locale","DataValue","value","options","Variant","arrayType","dimensions","getRawValue","DiagnosticInfo","info","VariantArrayType","Scalar","Array","isArray","from","val","encodeVariant","Buffer","rawValue","stringify","a","toJSON","JSON","stringified","toString","trim","decodeAsString","decodeAsInt","parseInt","decodeAsFloat","parseFloat","decodeAsJson","parse","decodeRawValue","Boolean","SByte","Byte","Int16","UInt16","Int32","UInt32","Int64","UInt64","Float","Double","String","DateTime","Guid","XmlElement","NodeId","ExpandedNodeId","toNodeValue","s","Date","ByteString","data","nodeId","defs","split","identifierType","namespace","namespaceUri","serverIndex","reduce","opts","def","match","slice","StatusCodes","getNodeValue","Error","raw","decodeVariant","buffer","length"],"mappings":"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","sourcesContent":["import { DataType, VariantArrayType, Variant } from 'node-opcua/lib/datamodel/variant';\nimport { resolveNodeId } from 'node-opcua/lib/datamodel/nodeid';\nimport { LocalizedText } from 'node-opcua/lib/datamodel/localized_text';\nimport { StatusCodes } from 'node-opcua/lib/datamodel/opcua_status_code';\nimport { QualifiedName } from 'node-opcua/lib/datamodel/qualified_name';\nimport { DataValue } from 'node-opcua/lib/datamodel/datavalue';\nimport { ExpandedNodeId } from 'node-opcua/lib/datamodel/expanded_nodeid';\nimport { DiagnosticInfo } from 'node-opcua/lib/datamodel/diagnostic_info';\nimport { pick } from './helpers/Object';\n\n/**\n * Function that returns the passed argument as is.\n * @param {*} b The input argument.\n * @return {*} The value passed.\n */\nconst asIs = (b) => b;\n\n/**\n * Maps a single property of an object using the the mapper defined in *map* for the given\n * *dataType*.\n * @param {Map<node-opcua~DataType, function} map The mappings to use.\n * @param {Object} obj The object to process.\n * @param {string} key Name of the property to map.\n * @param {node-opcua~DataType} dataType The data type to map the property to.\n */\nconst mapPropertyAs = (map, obj, key, dataType) => {\n  if (obj[key]) {\n    return Object.assign(obj, {\n      [key]: map[dataType](obj[key]),\n    });\n  }\n\n  return obj;\n};\n\n/**\n * A set of functions that return raw values from {@link node-opcua~Variant} for specific\n * {@link node-opcua~DataType}s.\n * @type {Map<node-opcua~DataType, function(value: any): any>}\n */\nconst toRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.StatusCode]: ({ name }) => name,\n  [DataType.QualifiedName]: ({ namespaceIndex, name }) => ({ namespaceIndex, name }),\n  [DataType.LocalizedText]: ({ text, locale }) => ({ text: text || null, locale }),\n  [DataType.DataValue]: (value) => {\n    const options = pick(value, [\n      'value',\n      'statusCode',\n      'sourceTimestamp',\n      'sourcePicoseconds',\n      'serverTimestamp',\n      'serverPicoseconds',\n    ]);\n\n    mapPropertyAs(toRawValue, options, 'value', DataType.Variant);\n    mapPropertyAs(toRawValue, options, 'statusCode', DataType.StatusCode);\n    // NOTE: server- and sourceTimstamps get mapped as dates\n\n    return options;\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) => ({\n    dataType,\n    arrayType,\n    // eslint-disable-next-line no-use-before-define\n    value: getRawValue({ value, dataType, arrayType }),\n    dimensions,\n  }),\n  [DataType.DiagnosticInfo]: (info) => {\n    const options = pick(info, [\n      'namespaceUri',\n      'symbolicId',\n      'locale',\n      'localizedText',\n      'additionalInfo',\n      'innerStatusCode',\n      'innerDiagnosticInfo',\n    ]);\n\n    mapPropertyAs(toRawValue, options, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toRawValue, options, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n    return options;\n  },\n};\n\n/**\n * Returns the raw value for a {@link node-opcua~Variant}.\n * @param {node-opcua~Variant} variant The variant to convert.\n */\nfunction getRawValue({ value, dataType, arrayType }) {\n  if (arrayType !== VariantArrayType.Scalar) {\n    return (Array.isArray(value) ? value : Array.from(value)).map((val) =>\n      getRawValue({\n        value: val,\n        dataType,\n        arrayType: VariantArrayType[arrayType.value - 1],\n      })\n    );\n  }\n\n  return (toRawValue[dataType] || asIs)(value);\n}\n\n/**\n * Returns a buffer containing a {@link node-opcua~Variant}s encoded value.\n * @param {node-opcua~Variant} variant The variant to encode.\n * @return {Buffer} A buffer containing the encoded value.\n */\nexport function encodeVariant({ value, dataType, arrayType }) {\n  if (value === null) {\n    return Buffer.from([]);\n  }\n\n  const rawValue = getRawValue({ value, dataType, arrayType });\n\n  if (rawValue instanceof Buffer) {\n    return rawValue;\n  }\n\n  const stringify = (a) => (a.toJSON ? a.toJSON() : JSON.stringify(a, null, '  '));\n\n  const stringified =\n    typeof rawValue === 'object' ? stringify(rawValue) : rawValue.toString().trim();\n\n  return Buffer.from(stringified);\n}\n\n/**\n * Decodes a buffer to a string.\n * @param {Buffer} b The buffer to decode from.\n * @return {string} The buffer's string representation.\n */\nconst decodeAsString = (b) => b.toString().trim();\n\n/**\n * Decodes a buffer to an integer value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded integer.\n */\nconst decodeAsInt = (b) => parseInt(decodeAsString(b), 10);\n\n/**\n * Decodes a buffer to a float value.\n * @param {Buffer} b The buffer to decode from.\n * @return {number} The decoded float.\n */\nconst decodeAsFloat = (b) => parseFloat(decodeAsString(b));\n\n/**\n * Decodes a buffer using JSON.\n * @param {Buffer} b The buffer to decode from.\n * @return {*} The decoded value, most likely an Object.\n */\nconst decodeAsJson = (b) => JSON.parse(b.toString());\n\n/**\n * Mapping functions that return raw values for a stored value of the given type.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst decodeRawValue = {\n  [DataType.Null]: () => null,\n  [DataType.Boolean]: (b) => decodeAsString(b) === 'true',\n  [DataType.SByte]: decodeAsInt,\n  [DataType.Byte]: decodeAsInt,\n  [DataType.Int16]: decodeAsInt,\n  [DataType.UInt16]: decodeAsInt,\n  [DataType.Int32]: decodeAsInt,\n  [DataType.UInt32]: decodeAsInt,\n  [DataType.Int64]: decodeAsJson,\n  [DataType.UInt64]: decodeAsJson,\n  [DataType.Float]: decodeAsFloat,\n  [DataType.Double]: decodeAsFloat,\n  [DataType.String]: decodeAsString,\n  [DataType.DateTime]: decodeAsString,\n  [DataType.Guid]: decodeAsString,\n  // ByteString maps to Buffer\n  [DataType.XmlElement]: decodeAsString,\n  [DataType.NodeId]: decodeAsString,\n  [DataType.ExpandedNodeId]: decodeAsString,\n  [DataType.StatusCode]: decodeAsString,\n  [DataType.QualifiedName]: decodeAsJson,\n  [DataType.LocalizedText]: decodeAsJson,\n  // FIXME: Add ExtensionObject\n  [DataType.DataValue]: decodeAsJson,\n  [DataType.Variant]: decodeAsJson,\n  [DataType.DiagnosticInfo]: decodeAsJson,\n};\n\n/**\n * Mapping functions that return OPC-UA node values for raw values.\n * @type {Map<node-opcua~DataType, function>}\n */\nconst toNodeValue = {\n  [DataType.DateTime]: (s) => new Date(s),\n  [DataType.ByteString]: (b) => {\n    if (b instanceof Buffer) {\n      return b;\n    }\n\n    return Buffer.from(b.data, 'binary');\n  },\n  [DataType.NodeId]: (s) => resolveNodeId(s),\n\n  // Jep, node-opcua does not provide a resolve function for expanded nodeids\n  [DataType.ExpandedNodeId]: (s) => {\n    const nodeId = resolveNodeId(s);\n    const [value, ...defs] = nodeId.value.split(';');\n\n    const { identifierType, namespace, namespaceUri, serverIndex } = defs.reduce((opts, def) => {\n      const match = def.match(/^([^:]+):(.*)/);\n      if (!match) {\n        return opts;\n      }\n\n      let [key, val] = match.slice(1); // eslint-disable-line prefer-const\n\n      if (key === 'serverIndex') {\n        val = parseInt(val, 10);\n      }\n\n      return Object.assign(opts, { [key]: val });\n    }, Object.assign({}, nodeId));\n\n    return new ExpandedNodeId(identifierType, value, namespace, namespaceUri, serverIndex);\n  },\n\n  [DataType.StatusCode]: (name) => StatusCodes[name],\n  [DataType.QualifiedName]: (options) => new QualifiedName(options),\n  [DataType.LocalizedText]: (options) => new LocalizedText(options),\n  [DataType.DataValue]: (options) => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'value', DataType.Variant);\n    mapPropertyAs(toNodeValue, opts, 'statusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'sourceTimestamp', DataType.DateTime);\n    mapPropertyAs(toNodeValue, opts, 'serverTimestamp', DataType.DateTime);\n\n    return new DataValue(opts);\n  },\n  [DataType.Variant]: ({ dataType, arrayType, value, dimensions }) =>\n    new Variant({\n      dataType,\n      arrayType: VariantArrayType[arrayType],\n      value,\n      dimensions,\n    }),\n  [DataType.DiagnosticInfo]: (options) => {\n    const opts = options;\n\n    mapPropertyAs(toNodeValue, opts, 'innerStatusCode', DataType.StatusCode);\n    mapPropertyAs(toNodeValue, opts, 'innerDiagnosticInfo', DataType.DiagnosticInfo);\n\n    return new DiagnosticInfo(opts);\n  },\n};\n\n/**\n * Returns a node's OPC-UA value based on it's raw value and type.\n * @param {*} rawValue A node's raw value.\n * @param {node-opcua~DataType} dataType A node's data type.\n * @param {node-opcua~VariantArrayType} arrayType A node's array type.\n */\nconst getNodeValue = (rawValue, dataType, arrayType) => {\n  if (arrayType.value !== VariantArrayType.Scalar.value) {\n    if (!Array.isArray(rawValue)) {\n      throw new Error('Value is not an array');\n    }\n\n    return rawValue.map((raw) =>\n      getNodeValue(raw, dataType, VariantArrayType[arrayType.value - 1])\n    );\n  }\n\n  return (toNodeValue[dataType] || asIs)(rawValue);\n};\n\n/**\n * Returns a {@link node-opcua~Variant} from a Buffer with the given *dataType* and *arrayType*.\n * @param {Buffer} buffer The buffer to decode from.\n * @param {Object} options The options to use.\n * @param {node-opcua~DataType} options.dataType The data type to decode to.\n * @param {node-opcua~VariantArrayType} options.arrayType The array type to decode to.\n */\nexport function decodeVariant(buffer, { dataType, arrayType }) {\n  if (buffer === null || buffer.length === 0) {\n    return null;\n  }\n\n  if (dataType === DataType.ByteString && arrayType === VariantArrayType.Scalar) {\n    return buffer;\n  }\n\n  const rawValue =\n    arrayType === VariantArrayType.Scalar\n      ? (decodeRawValue[dataType] || asIs)(buffer)\n      : JSON.parse(buffer.toString());\n\n  return getNodeValue(rawValue, dataType, arrayType);\n}\n"],"file":"coding.js"}